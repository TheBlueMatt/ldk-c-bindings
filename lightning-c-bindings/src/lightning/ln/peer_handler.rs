// This file is Copyright its original authors, visible in version control
// history and in the source files from which this was generated.
//
// This file is licensed under the license available in the LICENSE or LICENSE.md
// file in the root of this repository or, if no such file exists, the same
// license as that which applies to the original source files from which this
// source was automatically generated.

//! Top level peer message handling and socket handling logic lives here.
//!
//! Instead of actually servicing sockets ourselves we require that you implement the
//! SocketDescriptor interface and use that to receive actions which you should perform on the
//! socket, and call into PeerManager with bytes read from the socket. The PeerManager will then
//! call into the provided message handlers (probably a ChannelManager and P2PGossipSync) with
//! messages they should handle, and encoding/sending response messages.

use alloc::str::FromStr;
use alloc::string::String;
use core::ffi::c_void;
use core::convert::Infallible;
use bitcoin::hashes::Hash;
use crate::c_types::*;
#[cfg(feature="no-std")]
use alloc::{vec::Vec, boxed::Box};

/// A handler provided to [`PeerManager`] for reading and handling custom messages.
///
/// [BOLT 1] specifies a custom message type range for use with experimental or application-specific
/// messages. `CustomMessageHandler` allows for user-defined handling of such types. See the
/// [`lightning_custom_message`] crate for tools useful in composing more than one custom handler.
///
/// [BOLT 1]: https://github.com/lightning/bolts/blob/master/01-messaging.md
/// [`lightning_custom_message`]: https://docs.rs/lightning_custom_message/latest/lightning_custom_message
#[repr(C)]
pub struct CustomMessageHandler {
	/// An opaque pointer which is passed to your function implementations as an argument.
	/// This has no meaning in the LDK, and can be NULL or any other value.
	pub this_arg: *mut c_void,
	/// Handles the given message sent from `sender_node_id`, possibly producing messages for
	/// [`CustomMessageHandler::get_and_clear_pending_msg`] to return and thus for [`PeerManager`]
	/// to send.
	pub handle_custom_message: extern "C" fn (this_arg: *const c_void, msg: crate::lightning::ln::wire::Type, sender_node_id: crate::c_types::PublicKey) -> crate::c_types::derived::CResult_NoneLightningErrorZ,
	/// Returns the list of pending messages that were generated by the handler, clearing the list
	/// in the process. Each message is paired with the node id of the intended recipient. If no
	/// connection to the node exists, then the message is simply not sent.
	pub get_and_clear_pending_msg: extern "C" fn (this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_PublicKeyTypeZZ,
	/// Indicates a peer disconnected.
	pub peer_disconnected: extern "C" fn (this_arg: *const c_void, their_node_id: crate::c_types::PublicKey),
	/// Handle a peer connecting.
	///
	/// May return an `Err(())` if the features the peer supports are not sufficient to communicate
	/// with us. Implementors should be somewhat conservative about doing so, however, as other
	/// message handlers may still wish to communicate with this peer.
	pub peer_connected: extern "C" fn (this_arg: *const c_void, their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::Init, inbound: bool) -> crate::c_types::derived::CResult_NoneNoneZ,
	/// Gets the node feature flags which this handler itself supports. All available handlers are
	/// queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
	/// which are broadcasted in our [`NodeAnnouncement`] message.
	///
	/// [`NodeAnnouncement`]: crate::ln::msgs::NodeAnnouncement
	pub provided_node_features: extern "C" fn (this_arg: *const c_void) -> crate::lightning_types::features::NodeFeatures,
	/// Gets the init feature flags which should be sent to the given peer. All available handlers
	/// are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
	/// which are sent in our [`Init`] message.
	///
	/// [`Init`]: crate::ln::msgs::Init
	pub provided_init_features: extern "C" fn (this_arg: *const c_void, their_node_id: crate::c_types::PublicKey) -> crate::lightning_types::features::InitFeatures,
	/// Implementation of CustomMessageReader for this object.
	pub CustomMessageReader: crate::lightning::ln::wire::CustomMessageReader,
	/// Frees any resources associated with this object given its this_arg pointer.
	/// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
	pub free: Option<extern "C" fn(this_arg: *mut c_void)>,
}
unsafe impl Send for CustomMessageHandler {}
unsafe impl Sync for CustomMessageHandler {}
#[allow(unused)]
pub(crate) fn CustomMessageHandler_clone_fields(orig: &CustomMessageHandler) -> CustomMessageHandler {
	CustomMessageHandler {
		this_arg: orig.this_arg,
		handle_custom_message: Clone::clone(&orig.handle_custom_message),
		get_and_clear_pending_msg: Clone::clone(&orig.get_and_clear_pending_msg),
		peer_disconnected: Clone::clone(&orig.peer_disconnected),
		peer_connected: Clone::clone(&orig.peer_connected),
		provided_node_features: Clone::clone(&orig.provided_node_features),
		provided_init_features: Clone::clone(&orig.provided_init_features),
		CustomMessageReader: crate::lightning::ln::wire::CustomMessageReader_clone_fields(&orig.CustomMessageReader),
		free: Clone::clone(&orig.free),
	}
}
impl lightning::ln::wire::CustomMessageReader for CustomMessageHandler {
	type CustomMessage = crate::lightning::ln::wire::Type;
	fn read<R:crate::c_types::io::Read>(&self, mut message_type: u16, mut buffer: &mut R) -> Result<Option<crate::lightning::ln::wire::Type>, lightning::ln::msgs::DecodeError> {
		let mut ret = (self.CustomMessageReader.read)(self.CustomMessageReader.this_arg, message_type, crate::c_types::u8slice::from_vec(&crate::c_types::reader_to_vec(buffer)));
		let mut local_ret = match ret.result_ok { true => Ok( { let mut local_ret_0 = { /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) })*/ let ret_0_opt = (*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) }); if ret_0_opt.is_none() { None } else { Some({ { { ret_0_opt.take() } }})} }; local_ret_0 }), false => Err( { (*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.err)) }).into_native() })};
		local_ret
	}
}
impl lightning::ln::wire::CustomMessageReader for CustomMessageHandlerRef {
	type CustomMessage = crate::lightning::ln::wire::Type;
	fn read<R:crate::c_types::io::Read>(&self, mut message_type: u16, mut buffer: &mut R) -> Result<Option<crate::lightning::ln::wire::Type>, lightning::ln::msgs::DecodeError> {
		let mut ret = (self.0.CustomMessageReader.read)(self.0.CustomMessageReader.this_arg, message_type, crate::c_types::u8slice::from_vec(&crate::c_types::reader_to_vec(buffer)));
		let mut local_ret = match ret.result_ok { true => Ok( { let mut local_ret_0 = { /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) })*/ let ret_0_opt = (*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) }); if ret_0_opt.is_none() { None } else { Some({ { { ret_0_opt.take() } }})} }; local_ret_0 }), false => Err( { (*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.err)) }).into_native() })};
		local_ret
	}
}

use lightning::ln::peer_handler::CustomMessageHandler as rustCustomMessageHandler;
impl rustCustomMessageHandler for CustomMessageHandler {
	fn handle_custom_message(&self, mut msg: crate::lightning::ln::wire::Type, mut sender_node_id: bitcoin::secp256k1::PublicKey) -> Result<(), lightning::ln::msgs::LightningError> {
		let mut ret = (self.handle_custom_message)(self.this_arg, Into::into(msg), crate::c_types::PublicKey::from_rust(&sender_node_id));
		let mut local_ret = match ret.result_ok { true => Ok( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) })*/ }), false => Err( { *unsafe { Box::from_raw((*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.err)) }).take_inner()) } })};
		local_ret
	}
	fn get_and_clear_pending_msg(&self) -> Vec<(bitcoin::secp256k1::PublicKey, crate::lightning::ln::wire::Type)> {
		let mut ret = (self.get_and_clear_pending_msg)(self.this_arg);
		let mut local_ret = Vec::new(); for mut item in ret.into_rust().drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item.to_rust(); let mut local_ret_0 = (orig_ret_0_0.into_rust(), orig_ret_0_1); local_ret_0 }); };
		local_ret
	}
	fn peer_disconnected(&self, mut their_node_id: bitcoin::secp256k1::PublicKey) {
		(self.peer_disconnected)(self.this_arg, crate::c_types::PublicKey::from_rust(&their_node_id))
	}
	fn peer_connected(&self, mut their_node_id: bitcoin::secp256k1::PublicKey, mut msg: &lightning::ln::msgs::Init, mut inbound: bool) -> Result<(), ()> {
		let mut ret = (self.peer_connected)(self.this_arg, crate::c_types::PublicKey::from_rust(&their_node_id), &crate::lightning::ln::msgs::Init { inner: unsafe { ObjOps::nonnull_ptr_to_inner((msg as *const lightning::ln::msgs::Init<>) as *mut _) }, is_owned: false }, inbound);
		let mut local_ret = match ret.result_ok { true => Ok( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) })*/ }), false => Err( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.err)) })*/ })};
		local_ret
	}
	fn provided_node_features(&self) -> lightning_types::features::NodeFeatures {
		let mut ret = (self.provided_node_features)(self.this_arg);
		*unsafe { Box::from_raw(ret.take_inner()) }
	}
	fn provided_init_features(&self, mut their_node_id: bitcoin::secp256k1::PublicKey) -> lightning_types::features::InitFeatures {
		let mut ret = (self.provided_init_features)(self.this_arg, crate::c_types::PublicKey::from_rust(&their_node_id));
		*unsafe { Box::from_raw(ret.take_inner()) }
	}
}

pub struct CustomMessageHandlerRef(CustomMessageHandler);
impl rustCustomMessageHandler for CustomMessageHandlerRef {
	fn handle_custom_message(&self, mut msg: crate::lightning::ln::wire::Type, mut sender_node_id: bitcoin::secp256k1::PublicKey) -> Result<(), lightning::ln::msgs::LightningError> {
		let mut ret = (self.0.handle_custom_message)(self.0.this_arg, Into::into(msg), crate::c_types::PublicKey::from_rust(&sender_node_id));
		let mut local_ret = match ret.result_ok { true => Ok( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) })*/ }), false => Err( { *unsafe { Box::from_raw((*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.err)) }).take_inner()) } })};
		local_ret
	}
	fn get_and_clear_pending_msg(&self) -> Vec<(bitcoin::secp256k1::PublicKey, crate::lightning::ln::wire::Type)> {
		let mut ret = (self.0.get_and_clear_pending_msg)(self.0.this_arg);
		let mut local_ret = Vec::new(); for mut item in ret.into_rust().drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item.to_rust(); let mut local_ret_0 = (orig_ret_0_0.into_rust(), orig_ret_0_1); local_ret_0 }); };
		local_ret
	}
	fn peer_disconnected(&self, mut their_node_id: bitcoin::secp256k1::PublicKey) {
		(self.0.peer_disconnected)(self.0.this_arg, crate::c_types::PublicKey::from_rust(&their_node_id))
	}
	fn peer_connected(&self, mut their_node_id: bitcoin::secp256k1::PublicKey, mut msg: &lightning::ln::msgs::Init, mut inbound: bool) -> Result<(), ()> {
		let mut ret = (self.0.peer_connected)(self.0.this_arg, crate::c_types::PublicKey::from_rust(&their_node_id), &crate::lightning::ln::msgs::Init { inner: unsafe { ObjOps::nonnull_ptr_to_inner((msg as *const lightning::ln::msgs::Init<>) as *mut _) }, is_owned: false }, inbound);
		let mut local_ret = match ret.result_ok { true => Ok( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) })*/ }), false => Err( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.err)) })*/ })};
		local_ret
	}
	fn provided_node_features(&self) -> lightning_types::features::NodeFeatures {
		let mut ret = (self.0.provided_node_features)(self.0.this_arg);
		*unsafe { Box::from_raw(ret.take_inner()) }
	}
	fn provided_init_features(&self, mut their_node_id: bitcoin::secp256k1::PublicKey) -> lightning_types::features::InitFeatures {
		let mut ret = (self.0.provided_init_features)(self.0.this_arg, crate::c_types::PublicKey::from_rust(&their_node_id));
		*unsafe { Box::from_raw(ret.take_inner()) }
	}
}

// We're essentially a pointer already, or at least a set of pointers, so allow us to be used
// directly as a Deref trait in higher-level structs:
impl core::ops::Deref for CustomMessageHandler {
	type Target = CustomMessageHandlerRef;
	fn deref(&self) -> &Self::Target {
		unsafe { &*(self as *const _ as *const CustomMessageHandlerRef) }
	}
}
impl core::ops::DerefMut for CustomMessageHandler {
	fn deref_mut(&mut self) -> &mut CustomMessageHandlerRef {
		unsafe { &mut *(self as *mut _ as *mut CustomMessageHandlerRef) }
	}
}
/// Calls the free function if one is set
#[no_mangle]
pub extern "C" fn CustomMessageHandler_free(this_ptr: CustomMessageHandler) { }
impl Drop for CustomMessageHandler {
	fn drop(&mut self) {
		if let Some(f) = self.free {
			f(self.this_arg);
		}
	}
}

use lightning::ln::peer_handler::IgnoringMessageHandler as nativeIgnoringMessageHandlerImport;
pub(crate) type nativeIgnoringMessageHandler = nativeIgnoringMessageHandlerImport;

/// A dummy struct which implements `RoutingMessageHandler` without storing any routing information
/// or doing any processing. You can provide one of these as the route_handler in a MessageHandler.
#[must_use]
#[repr(C)]
pub struct IgnoringMessageHandler {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeIgnoringMessageHandler,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for IgnoringMessageHandler {
	type Target = nativeIgnoringMessageHandler;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for IgnoringMessageHandler { }
unsafe impl core::marker::Sync for IgnoringMessageHandler { }
impl Drop for IgnoringMessageHandler {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeIgnoringMessageHandler>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the IgnoringMessageHandler, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_free(this_obj: IgnoringMessageHandler) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn IgnoringMessageHandler_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeIgnoringMessageHandler) };
}
#[allow(unused)]
impl IgnoringMessageHandler {
	pub(crate) fn get_native_ref(&self) -> &'static nativeIgnoringMessageHandler {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeIgnoringMessageHandler {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeIgnoringMessageHandler {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// Constructs a new IgnoringMessageHandler given each field
#[must_use]
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_new() -> IgnoringMessageHandler {
	IgnoringMessageHandler { inner: ObjOps::heap_alloc(nativeIgnoringMessageHandler {
	}), is_owned: true }
}
impl From<nativeIgnoringMessageHandler> for crate::lightning::events::MessageSendEventsProvider {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_MessageSendEventsProvider(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_MessageSendEventsProvider(this_arg: &IgnoringMessageHandler) -> crate::lightning::events::MessageSendEventsProvider {
	crate::lightning::events::MessageSendEventsProvider {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		get_and_clear_pending_msg_events: IgnoringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg: *const c_void) -> crate::c_types::derived::CVec_MessageSendEventZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::events::MessageSendEventsProvider>::get_and_clear_pending_msg_events(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::events::MessageSendEvent::native_into(item) }); };
	local_ret.into()
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::ln::msgs::RoutingMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_RoutingMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_RoutingMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::ln::msgs::RoutingMessageHandler {
	crate::lightning::ln::msgs::RoutingMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_node_announcement: IgnoringMessageHandler_RoutingMessageHandler_handle_node_announcement,
		handle_channel_announcement: IgnoringMessageHandler_RoutingMessageHandler_handle_channel_announcement,
		handle_channel_update: IgnoringMessageHandler_RoutingMessageHandler_handle_channel_update,
		get_next_channel_announcement: IgnoringMessageHandler_RoutingMessageHandler_get_next_channel_announcement,
		get_next_node_announcement: IgnoringMessageHandler_RoutingMessageHandler_get_next_node_announcement,
		peer_connected: IgnoringMessageHandler_RoutingMessageHandler_peer_connected,
		handle_reply_channel_range: IgnoringMessageHandler_RoutingMessageHandler_handle_reply_channel_range,
		handle_reply_short_channel_ids_end: IgnoringMessageHandler_RoutingMessageHandler_handle_reply_short_channel_ids_end,
		handle_query_channel_range: IgnoringMessageHandler_RoutingMessageHandler_handle_query_channel_range,
		handle_query_short_channel_ids: IgnoringMessageHandler_RoutingMessageHandler_handle_query_short_channel_ids,
		processing_queue_high: IgnoringMessageHandler_RoutingMessageHandler_processing_queue_high,
		provided_node_features: IgnoringMessageHandler_RoutingMessageHandler_provided_node_features,
		provided_init_features: IgnoringMessageHandler_RoutingMessageHandler_provided_init_features,
		MessageSendEventsProvider: crate::lightning::events::MessageSendEventsProvider {
			this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
			free: None,
			get_and_clear_pending_msg_events: IgnoringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events,
		},
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_node_announcement(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::NodeAnnouncement) -> crate::c_types::derived::CResult_boolLightningErrorZ {
	let mut local_their_node_id = if their_node_id.is_null() { None } else { Some( { their_node_id.into_rust() }) };
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::handle_node_announcement(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, local_their_node_id, msg.get_native_ref());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { o }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_channel_announcement(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelAnnouncement) -> crate::c_types::derived::CResult_boolLightningErrorZ {
	let mut local_their_node_id = if their_node_id.is_null() { None } else { Some( { their_node_id.into_rust() }) };
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::handle_channel_announcement(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, local_their_node_id, msg.get_native_ref());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { o }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_channel_update(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelUpdate) -> crate::c_types::derived::CResult_boolLightningErrorZ {
	let mut local_their_node_id = if their_node_id.is_null() { None } else { Some( { their_node_id.into_rust() }) };
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::handle_channel_update(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, local_their_node_id, msg.get_native_ref());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { o }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_get_next_channel_announcement(this_arg: *const c_void, mut starting_point: u64) -> crate::c_types::derived::COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::get_next_channel_announcement(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, starting_point);
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ::None } else { crate::c_types::derived::COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ::Some( { let (mut orig_ret_0_0, mut orig_ret_0_1, mut orig_ret_0_2) = (ret.unwrap()); let mut local_orig_ret_0_1 = crate::lightning::ln::msgs::ChannelUpdate { inner: if orig_ret_0_1.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((orig_ret_0_1.unwrap())) } }, is_owned: true }; let mut local_orig_ret_0_2 = crate::lightning::ln::msgs::ChannelUpdate { inner: if orig_ret_0_2.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((orig_ret_0_2.unwrap())) } }, is_owned: true }; let mut local_ret_0 = (crate::lightning::ln::msgs::ChannelAnnouncement { inner: ObjOps::heap_alloc(orig_ret_0_0), is_owned: true }, local_orig_ret_0_1, local_orig_ret_0_2).into(); local_ret_0 }) };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_get_next_node_announcement(this_arg: *const c_void, mut starting_point: crate::lightning::routing::gossip::NodeId) -> crate::lightning::ln::msgs::NodeAnnouncement {
	let mut local_starting_point = if starting_point.inner.is_null() { None } else { Some( { starting_point.get_native_ref() }) };
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::get_next_node_announcement(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, local_starting_point);
	let mut local_ret = crate::lightning::ln::msgs::NodeAnnouncement { inner: if ret.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((ret.unwrap())) } }, is_owned: true };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_peer_connected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, init: &crate::lightning::ln::msgs::Init, mut inbound: bool) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::peer_connected(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust(), init.get_native_ref(), inbound);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_reply_channel_range(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, mut msg: crate::lightning::ln::msgs::ReplyChannelRange) -> crate::c_types::derived::CResult_NoneLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::handle_reply_channel_range(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust(), *unsafe { Box::from_raw(msg.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_reply_short_channel_ids_end(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, mut msg: crate::lightning::ln::msgs::ReplyShortChannelIdsEnd) -> crate::c_types::derived::CResult_NoneLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::handle_reply_short_channel_ids_end(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust(), *unsafe { Box::from_raw(msg.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_query_channel_range(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, mut msg: crate::lightning::ln::msgs::QueryChannelRange) -> crate::c_types::derived::CResult_NoneLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::handle_query_channel_range(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust(), *unsafe { Box::from_raw(msg.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_query_short_channel_ids(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, mut msg: crate::lightning::ln::msgs::QueryShortChannelIds) -> crate::c_types::derived::CResult_NoneLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::handle_query_short_channel_ids(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust(), *unsafe { Box::from_raw(msg.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_processing_queue_high(this_arg: *const c_void) -> bool {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::processing_queue_high(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning_types::features::NodeFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	crate::lightning_types::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_provided_init_features(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) -> crate::lightning_types::features::InitFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler>::provided_init_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust());
	crate::lightning_types::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::ln::msgs::OnionMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_OnionMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new OnionMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned OnionMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_OnionMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::ln::msgs::OnionMessageHandler {
	crate::lightning::ln::msgs::OnionMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_onion_message: IgnoringMessageHandler_OnionMessageHandler_handle_onion_message,
		next_onion_message_for_peer: IgnoringMessageHandler_OnionMessageHandler_next_onion_message_for_peer,
		peer_connected: IgnoringMessageHandler_OnionMessageHandler_peer_connected,
		peer_disconnected: IgnoringMessageHandler_OnionMessageHandler_peer_disconnected,
		timer_tick_occurred: IgnoringMessageHandler_OnionMessageHandler_timer_tick_occurred,
		provided_node_features: IgnoringMessageHandler_OnionMessageHandler_provided_node_features,
		provided_init_features: IgnoringMessageHandler_OnionMessageHandler_provided_init_features,
	}
}

extern "C" fn IgnoringMessageHandler_OnionMessageHandler_handle_onion_message(this_arg: *const c_void, mut peer_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::OnionMessage) {
	<nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler>::handle_onion_message(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, peer_node_id.into_rust(), msg.get_native_ref())
}
#[must_use]
extern "C" fn IgnoringMessageHandler_OnionMessageHandler_next_onion_message_for_peer(this_arg: *const c_void, mut peer_node_id: crate::c_types::PublicKey) -> crate::lightning::ln::msgs::OnionMessage {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler>::next_onion_message_for_peer(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, peer_node_id.into_rust());
	let mut local_ret = crate::lightning::ln::msgs::OnionMessage { inner: if ret.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((ret.unwrap())) } }, is_owned: true };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_OnionMessageHandler_peer_connected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, init: &crate::lightning::ln::msgs::Init, mut inbound: bool) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler>::peer_connected(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust(), init.get_native_ref(), inbound);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}
extern "C" fn IgnoringMessageHandler_OnionMessageHandler_peer_disconnected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) {
	<nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler>::peer_disconnected(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust())
}
extern "C" fn IgnoringMessageHandler_OnionMessageHandler_timer_tick_occurred(this_arg: *const c_void) {
	<nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler>::timer_tick_occurred(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, )
}
#[must_use]
extern "C" fn IgnoringMessageHandler_OnionMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning_types::features::NodeFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	crate::lightning_types::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn IgnoringMessageHandler_OnionMessageHandler_provided_init_features(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) -> crate::lightning_types::features::InitFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler>::provided_init_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust());
	crate::lightning_types::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::onion_message::offers::OffersMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_OffersMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new OffersMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned OffersMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_OffersMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::onion_message::offers::OffersMessageHandler {
	crate::lightning::onion_message::offers::OffersMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_message: IgnoringMessageHandler_OffersMessageHandler_handle_message,
		release_pending_messages: IgnoringMessageHandler_OffersMessageHandler_release_pending_messages,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_OffersMessageHandler_handle_message(this_arg: *const c_void, mut message: crate::lightning::onion_message::offers::OffersMessage, mut context: crate::c_types::derived::COption_OffersContextZ, mut responder: crate::lightning::onion_message::messenger::Responder) -> crate::c_types::derived::COption_C2Tuple_OffersMessageResponseInstructionZZ {
	let mut local_context = { /*context*/ let context_opt = context; if context_opt.is_none() { None } else { Some({ { { context_opt.take() }.into_native() }})} };
	let mut local_responder = if responder.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(responder.take_inner()) } }) };
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::offers::OffersMessageHandler>::handle_message(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, message.into_native(), local_context, local_responder);
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_C2Tuple_OffersMessageResponseInstructionZZ::None } else { crate::c_types::derived::COption_C2Tuple_OffersMessageResponseInstructionZZ::Some( { let (mut orig_ret_0_0, mut orig_ret_0_1) = (ret.unwrap()); let mut local_ret_0 = (crate::lightning::onion_message::offers::OffersMessage::native_into(orig_ret_0_0), crate::lightning::onion_message::messenger::ResponseInstruction { inner: ObjOps::heap_alloc(orig_ret_0_1), is_owned: true }).into(); local_ret_0 }) };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_OffersMessageHandler_release_pending_messages(this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_OffersMessageMessageSendInstructionsZZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::offers::OffersMessageHandler>::release_pending_messages(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_ret_0 = (crate::lightning::onion_message::offers::OffersMessage::native_into(orig_ret_0_0), crate::lightning::onion_message::messenger::MessageSendInstructions::native_into(orig_ret_0_1)).into(); local_ret_0 }); };
	local_ret.into()
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::onion_message::async_payments::AsyncPaymentsMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_AsyncPaymentsMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new AsyncPaymentsMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned AsyncPaymentsMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_AsyncPaymentsMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::onion_message::async_payments::AsyncPaymentsMessageHandler {
	crate::lightning::onion_message::async_payments::AsyncPaymentsMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_held_htlc_available: IgnoringMessageHandler_AsyncPaymentsMessageHandler_handle_held_htlc_available,
		handle_release_held_htlc: IgnoringMessageHandler_AsyncPaymentsMessageHandler_handle_release_held_htlc,
		release_pending_messages: IgnoringMessageHandler_AsyncPaymentsMessageHandler_release_pending_messages,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_AsyncPaymentsMessageHandler_handle_held_htlc_available(this_arg: *const c_void, mut message: crate::lightning::onion_message::async_payments::HeldHtlcAvailable, mut responder: crate::lightning::onion_message::messenger::Responder) -> crate::c_types::derived::COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ {
	let mut local_responder = if responder.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(responder.take_inner()) } }) };
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::async_payments::AsyncPaymentsMessageHandler>::handle_held_htlc_available(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, *unsafe { Box::from_raw(message.take_inner()) }, local_responder);
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ::None } else { crate::c_types::derived::COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ::Some( { let (mut orig_ret_0_0, mut orig_ret_0_1) = (ret.unwrap()); let mut local_ret_0 = (crate::lightning::onion_message::async_payments::ReleaseHeldHtlc { inner: ObjOps::heap_alloc(orig_ret_0_0), is_owned: true }, crate::lightning::onion_message::messenger::ResponseInstruction { inner: ObjOps::heap_alloc(orig_ret_0_1), is_owned: true }).into(); local_ret_0 }) };
	local_ret
}
extern "C" fn IgnoringMessageHandler_AsyncPaymentsMessageHandler_handle_release_held_htlc(this_arg: *const c_void, mut message: crate::lightning::onion_message::async_payments::ReleaseHeldHtlc, mut context: crate::lightning::blinded_path::message::AsyncPaymentsContext) {
	<nativeIgnoringMessageHandler as lightning::onion_message::async_payments::AsyncPaymentsMessageHandler>::handle_release_held_htlc(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, *unsafe { Box::from_raw(message.take_inner()) }, context.into_native())
}
#[must_use]
extern "C" fn IgnoringMessageHandler_AsyncPaymentsMessageHandler_release_pending_messages(this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::async_payments::AsyncPaymentsMessageHandler>::release_pending_messages(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_ret_0 = (crate::lightning::onion_message::async_payments::AsyncPaymentsMessage::native_into(orig_ret_0_0), crate::lightning::onion_message::messenger::MessageSendInstructions::native_into(orig_ret_0_1)).into(); local_ret_0 }); };
	local_ret.into()
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::onion_message::dns_resolution::DNSResolverMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_DNSResolverMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new DNSResolverMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned DNSResolverMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_DNSResolverMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::onion_message::dns_resolution::DNSResolverMessageHandler {
	crate::lightning::onion_message::dns_resolution::DNSResolverMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_dnssec_query: IgnoringMessageHandler_DNSResolverMessageHandler_handle_dnssec_query,
		handle_dnssec_proof: IgnoringMessageHandler_DNSResolverMessageHandler_handle_dnssec_proof,
		provided_node_features: IgnoringMessageHandler_DNSResolverMessageHandler_provided_node_features,
		release_pending_messages: IgnoringMessageHandler_DNSResolverMessageHandler_release_pending_messages,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_DNSResolverMessageHandler_handle_dnssec_query(this_arg: *const c_void, mut message: crate::lightning::onion_message::dns_resolution::DNSSECQuery, mut responder: crate::lightning::onion_message::messenger::Responder) -> crate::c_types::derived::COption_C2Tuple_DNSResolverMessageResponseInstructionZZ {
	let mut local_responder = if responder.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(responder.take_inner()) } }) };
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::dns_resolution::DNSResolverMessageHandler>::handle_dnssec_query(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, *unsafe { Box::from_raw(message.take_inner()) }, local_responder);
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_C2Tuple_DNSResolverMessageResponseInstructionZZ::None } else { crate::c_types::derived::COption_C2Tuple_DNSResolverMessageResponseInstructionZZ::Some( { let (mut orig_ret_0_0, mut orig_ret_0_1) = (ret.unwrap()); let mut local_ret_0 = (crate::lightning::onion_message::dns_resolution::DNSResolverMessage::native_into(orig_ret_0_0), crate::lightning::onion_message::messenger::ResponseInstruction { inner: ObjOps::heap_alloc(orig_ret_0_1), is_owned: true }).into(); local_ret_0 }) };
	local_ret
}
extern "C" fn IgnoringMessageHandler_DNSResolverMessageHandler_handle_dnssec_proof(this_arg: *const c_void, mut message: crate::lightning::onion_message::dns_resolution::DNSSECProof, mut context: crate::lightning::blinded_path::message::DNSResolverContext) {
	<nativeIgnoringMessageHandler as lightning::onion_message::dns_resolution::DNSResolverMessageHandler>::handle_dnssec_proof(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, *unsafe { Box::from_raw(message.take_inner()) }, *unsafe { Box::from_raw(context.take_inner()) })
}
#[must_use]
extern "C" fn IgnoringMessageHandler_DNSResolverMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning_types::features::NodeFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::dns_resolution::DNSResolverMessageHandler>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	crate::lightning_types::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn IgnoringMessageHandler_DNSResolverMessageHandler_release_pending_messages(this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_DNSResolverMessageMessageSendInstructionsZZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::dns_resolution::DNSResolverMessageHandler>::release_pending_messages(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_ret_0 = (crate::lightning::onion_message::dns_resolution::DNSResolverMessage::native_into(orig_ret_0_0), crate::lightning::onion_message::messenger::MessageSendInstructions::native_into(orig_ret_0_1)).into(); local_ret_0 }); };
	local_ret.into()
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::onion_message::messenger::CustomOnionMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_CustomOnionMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new CustomOnionMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned CustomOnionMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_CustomOnionMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::onion_message::messenger::CustomOnionMessageHandler {
	crate::lightning::onion_message::messenger::CustomOnionMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_custom_message: IgnoringMessageHandler_CustomOnionMessageHandler_handle_custom_message,
		read_custom_message: IgnoringMessageHandler_CustomOnionMessageHandler_read_custom_message,
		release_pending_custom_messages: IgnoringMessageHandler_CustomOnionMessageHandler_release_pending_custom_messages,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_CustomOnionMessageHandler_handle_custom_message(this_arg: *const c_void, mut message: crate::lightning::onion_message::packet::OnionMessageContents, mut context: crate::c_types::derived::COption_CVec_u8ZZ, mut responder: crate::lightning::onion_message::messenger::Responder) -> crate::c_types::derived::COption_C2Tuple_OnionMessageContentsResponseInstructionZZ {
	unreachable!();
}
#[must_use]
extern "C" fn IgnoringMessageHandler_CustomOnionMessageHandler_read_custom_message(this_arg: *const c_void, mut message_type: u64, mut buffer: crate::c_types::u8slice) -> crate::c_types::derived::CResult_COption_OnionMessageContentsZDecodeErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::messenger::CustomOnionMessageHandler>::read_custom_message(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, message_type, &mut buffer.to_reader());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let mut local_ret_0 = if o.is_none() { crate::c_types::derived::COption_OnionMessageContentsZ::None } else { crate::c_types::derived::COption_OnionMessageContentsZ::Some( { Into::into(o.unwrap()) }) }; local_ret_0 }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_CustomOnionMessageHandler_release_pending_custom_messages(this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_OnionMessageContentsMessageSendInstructionsZZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::messenger::CustomOnionMessageHandler>::release_pending_custom_messages(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_ret_0 = (Into::into(orig_ret_0_0), crate::lightning::onion_message::messenger::MessageSendInstructions::native_into(orig_ret_0_1)).into(); local_ret_0 }); };
	local_ret.into()
}

impl From<nativeInfallible> for crate::lightning::onion_message::packet::OnionMessageContents {
	fn from(obj: nativeInfallible) -> Self {
		unreachable!();
	}
}
impl From<nativeInfallible> for crate::lightning::ln::wire::Type {
	fn from(obj: nativeInfallible) -> Self {
		unreachable!();
	}
}
impl From<nativeIgnoringMessageHandler> for crate::lightning::ln::wire::CustomMessageReader {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_CustomMessageReader(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new CustomMessageReader which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned CustomMessageReader must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_CustomMessageReader(this_arg: &IgnoringMessageHandler) -> crate::lightning::ln::wire::CustomMessageReader {
	crate::lightning::ln::wire::CustomMessageReader {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		read: IgnoringMessageHandler_CustomMessageReader_read,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageReader_read(this_arg: *const c_void, mut message_type: u16, mut buffer: crate::c_types::u8slice) -> crate::c_types::derived::CResult_COption_TypeZDecodeErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::wire::CustomMessageReader>::read(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, message_type, &mut buffer.to_reader());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let mut local_ret_0 = if o.is_none() { crate::c_types::derived::COption_TypeZ::None } else { crate::c_types::derived::COption_TypeZ::Some( { Into::into(o.unwrap()) }) }; local_ret_0 }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_ret
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::ln::peer_handler::CustomMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_CustomMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new CustomMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned CustomMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_CustomMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::ln::peer_handler::CustomMessageHandler {
	crate::lightning::ln::peer_handler::CustomMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_custom_message: IgnoringMessageHandler_CustomMessageHandler_handle_custom_message,
		get_and_clear_pending_msg: IgnoringMessageHandler_CustomMessageHandler_get_and_clear_pending_msg,
		peer_disconnected: IgnoringMessageHandler_CustomMessageHandler_peer_disconnected,
		peer_connected: IgnoringMessageHandler_CustomMessageHandler_peer_connected,
		provided_node_features: IgnoringMessageHandler_CustomMessageHandler_provided_node_features,
		provided_init_features: IgnoringMessageHandler_CustomMessageHandler_provided_init_features,
		CustomMessageReader: crate::lightning::ln::wire::CustomMessageReader {
			this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
			free: None,
			read: IgnoringMessageHandler_CustomMessageReader_read,
		},
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageHandler_handle_custom_message(this_arg: *const c_void, mut msg: crate::lightning::ln::wire::Type, mut sender_node_id: crate::c_types::PublicKey) -> crate::c_types::derived::CResult_NoneLightningErrorZ {
	unreachable!();
}
#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageHandler_get_and_clear_pending_msg(this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_PublicKeyTypeZZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::peer_handler::CustomMessageHandler>::get_and_clear_pending_msg(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_ret_0 = (crate::c_types::PublicKey::from_rust(&orig_ret_0_0), Into::into(orig_ret_0_1)).into(); local_ret_0 }); };
	local_ret.into()
}
extern "C" fn IgnoringMessageHandler_CustomMessageHandler_peer_disconnected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) {
	<nativeIgnoringMessageHandler as lightning::ln::peer_handler::CustomMessageHandler>::peer_disconnected(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust())
}
#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageHandler_peer_connected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::Init, mut inbound: bool) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::peer_handler::CustomMessageHandler>::peer_connected(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref(), inbound);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning_types::features::NodeFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::peer_handler::CustomMessageHandler>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	crate::lightning_types::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageHandler_provided_init_features(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) -> crate::lightning_types::features::InitFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::peer_handler::CustomMessageHandler>::provided_init_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, their_node_id.into_rust());
	crate::lightning_types::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}


use lightning::ln::peer_handler::ErroringMessageHandler as nativeErroringMessageHandlerImport;
pub(crate) type nativeErroringMessageHandler = nativeErroringMessageHandlerImport;

/// A dummy struct which implements `ChannelMessageHandler` without having any channels.
/// You can provide one of these as the route_handler in a MessageHandler.
#[must_use]
#[repr(C)]
pub struct ErroringMessageHandler {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeErroringMessageHandler,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for ErroringMessageHandler {
	type Target = nativeErroringMessageHandler;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for ErroringMessageHandler { }
unsafe impl core::marker::Sync for ErroringMessageHandler { }
impl Drop for ErroringMessageHandler {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeErroringMessageHandler>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the ErroringMessageHandler, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn ErroringMessageHandler_free(this_obj: ErroringMessageHandler) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ErroringMessageHandler_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeErroringMessageHandler) };
}
#[allow(unused)]
impl ErroringMessageHandler {
	pub(crate) fn get_native_ref(&self) -> &'static nativeErroringMessageHandler {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeErroringMessageHandler {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeErroringMessageHandler {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// Constructs a new ErroringMessageHandler
#[must_use]
#[no_mangle]
pub extern "C" fn ErroringMessageHandler_new() -> crate::lightning::ln::peer_handler::ErroringMessageHandler {
	let mut ret = lightning::ln::peer_handler::ErroringMessageHandler::new();
	crate::lightning::ln::peer_handler::ErroringMessageHandler { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

impl From<nativeErroringMessageHandler> for crate::lightning::events::MessageSendEventsProvider {
	fn from(obj: nativeErroringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::ErroringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ErroringMessageHandler_as_MessageSendEventsProvider(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ErroringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ErroringMessageHandler_as_MessageSendEventsProvider(this_arg: &ErroringMessageHandler) -> crate::lightning::events::MessageSendEventsProvider {
	crate::lightning::events::MessageSendEventsProvider {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		get_and_clear_pending_msg_events: ErroringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events,
	}
}

#[must_use]
extern "C" fn ErroringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg: *const c_void) -> crate::c_types::derived::CVec_MessageSendEventZ {
	let mut ret = <nativeErroringMessageHandler as lightning::events::MessageSendEventsProvider>::get_and_clear_pending_msg_events(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::events::MessageSendEvent::native_into(item) }); };
	local_ret.into()
}

impl From<nativeErroringMessageHandler> for crate::lightning::ln::msgs::ChannelMessageHandler {
	fn from(obj: nativeErroringMessageHandler) -> Self {
		let rust_obj = crate::lightning::ln::peer_handler::ErroringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ErroringMessageHandler_as_ChannelMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ErroringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ErroringMessageHandler_as_ChannelMessageHandler(this_arg: &ErroringMessageHandler) -> crate::lightning::ln::msgs::ChannelMessageHandler {
	crate::lightning::ln::msgs::ChannelMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_open_channel: ErroringMessageHandler_ChannelMessageHandler_handle_open_channel,
		handle_open_channel_v2: ErroringMessageHandler_ChannelMessageHandler_handle_open_channel_v2,
		handle_accept_channel: ErroringMessageHandler_ChannelMessageHandler_handle_accept_channel,
		handle_accept_channel_v2: ErroringMessageHandler_ChannelMessageHandler_handle_accept_channel_v2,
		handle_funding_created: ErroringMessageHandler_ChannelMessageHandler_handle_funding_created,
		handle_funding_signed: ErroringMessageHandler_ChannelMessageHandler_handle_funding_signed,
		handle_channel_ready: ErroringMessageHandler_ChannelMessageHandler_handle_channel_ready,
		handle_shutdown: ErroringMessageHandler_ChannelMessageHandler_handle_shutdown,
		handle_closing_signed: ErroringMessageHandler_ChannelMessageHandler_handle_closing_signed,
		handle_stfu: ErroringMessageHandler_ChannelMessageHandler_handle_stfu,
		handle_tx_add_input: ErroringMessageHandler_ChannelMessageHandler_handle_tx_add_input,
		handle_tx_add_output: ErroringMessageHandler_ChannelMessageHandler_handle_tx_add_output,
		handle_tx_remove_input: ErroringMessageHandler_ChannelMessageHandler_handle_tx_remove_input,
		handle_tx_remove_output: ErroringMessageHandler_ChannelMessageHandler_handle_tx_remove_output,
		handle_tx_complete: ErroringMessageHandler_ChannelMessageHandler_handle_tx_complete,
		handle_tx_signatures: ErroringMessageHandler_ChannelMessageHandler_handle_tx_signatures,
		handle_tx_init_rbf: ErroringMessageHandler_ChannelMessageHandler_handle_tx_init_rbf,
		handle_tx_ack_rbf: ErroringMessageHandler_ChannelMessageHandler_handle_tx_ack_rbf,
		handle_tx_abort: ErroringMessageHandler_ChannelMessageHandler_handle_tx_abort,
		handle_update_add_htlc: ErroringMessageHandler_ChannelMessageHandler_handle_update_add_htlc,
		handle_update_fulfill_htlc: ErroringMessageHandler_ChannelMessageHandler_handle_update_fulfill_htlc,
		handle_update_fail_htlc: ErroringMessageHandler_ChannelMessageHandler_handle_update_fail_htlc,
		handle_update_fail_malformed_htlc: ErroringMessageHandler_ChannelMessageHandler_handle_update_fail_malformed_htlc,
		handle_commitment_signed: ErroringMessageHandler_ChannelMessageHandler_handle_commitment_signed,
		handle_revoke_and_ack: ErroringMessageHandler_ChannelMessageHandler_handle_revoke_and_ack,
		handle_update_fee: ErroringMessageHandler_ChannelMessageHandler_handle_update_fee,
		handle_announcement_signatures: ErroringMessageHandler_ChannelMessageHandler_handle_announcement_signatures,
		peer_disconnected: ErroringMessageHandler_ChannelMessageHandler_peer_disconnected,
		peer_connected: ErroringMessageHandler_ChannelMessageHandler_peer_connected,
		handle_channel_reestablish: ErroringMessageHandler_ChannelMessageHandler_handle_channel_reestablish,
		handle_channel_update: ErroringMessageHandler_ChannelMessageHandler_handle_channel_update,
		handle_error: ErroringMessageHandler_ChannelMessageHandler_handle_error,
		provided_node_features: ErroringMessageHandler_ChannelMessageHandler_provided_node_features,
		provided_init_features: ErroringMessageHandler_ChannelMessageHandler_provided_init_features,
		get_chain_hashes: ErroringMessageHandler_ChannelMessageHandler_get_chain_hashes,
		message_received: ErroringMessageHandler_ChannelMessageHandler_message_received,
		MessageSendEventsProvider: crate::lightning::events::MessageSendEventsProvider {
			this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
			free: None,
			get_and_clear_pending_msg_events: ErroringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events,
		},
	}
}

extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_open_channel(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::OpenChannel) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_open_channel(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_open_channel_v2(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::OpenChannelV2) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_open_channel_v2(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_accept_channel(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::AcceptChannel) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_accept_channel(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_accept_channel_v2(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::AcceptChannelV2) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_accept_channel_v2(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_funding_created(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::FundingCreated) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_funding_created(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_funding_signed(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::FundingSigned) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_funding_signed(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_channel_ready(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelReady) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_channel_ready(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_shutdown(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::Shutdown) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_shutdown(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_closing_signed(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ClosingSigned) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_closing_signed(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_stfu(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::Stfu) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_stfu(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_add_input(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAddInput) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_add_input(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_add_output(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAddOutput) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_add_output(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_remove_input(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxRemoveInput) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_remove_input(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_remove_output(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxRemoveOutput) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_remove_output(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_complete(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxComplete) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_complete(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_signatures(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxSignatures) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_signatures(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_init_rbf(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxInitRbf) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_init_rbf(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_ack_rbf(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAckRbf) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_ack_rbf(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_abort(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAbort) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_abort(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_update_add_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateAddHTLC) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_update_add_htlc(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_update_fulfill_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFulfillHTLC) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_update_fulfill_htlc(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_update_fail_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFailHTLC) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_update_fail_htlc(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_update_fail_malformed_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFailMalformedHTLC) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_update_fail_malformed_htlc(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_commitment_signed(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::CommitmentSigned) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_commitment_signed(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_revoke_and_ack(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::RevokeAndACK) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_revoke_and_ack(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_update_fee(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFee) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_update_fee(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_announcement_signatures(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::AnnouncementSignatures) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_announcement_signatures(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_peer_disconnected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::peer_disconnected(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust())
}
#[must_use]
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_peer_connected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::Init, mut inbound: bool) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut ret = <nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::peer_connected(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref(), inbound);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_channel_reestablish(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelReestablish) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_channel_reestablish(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_channel_update(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelUpdate) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_channel_update(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_error(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ErrorMessage) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::handle_error(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust(), msg.get_native_ref())
}
#[must_use]
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning_types::features::NodeFeatures {
	let mut ret = <nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, );
	crate::lightning_types::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_provided_init_features(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) -> crate::lightning_types::features::InitFeatures {
	let mut ret = <nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::provided_init_features(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, their_node_id.into_rust());
	crate::lightning_types::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_get_chain_hashes(this_arg: *const c_void) -> crate::c_types::derived::COption_CVec_ThirtyTwoBytesZZ {
	let mut ret = <nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::get_chain_hashes(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, );
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_CVec_ThirtyTwoBytesZZ::None } else { crate::c_types::derived::COption_CVec_ThirtyTwoBytesZZ::Some( { let mut local_ret_0 = Vec::new(); for mut item in ret.unwrap().drain(..) { local_ret_0.push( { crate::c_types::ThirtyTwoBytes { data: *item.as_ref() } }); }; local_ret_0.into() }) };
	local_ret
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_message_received(this_arg: *const c_void) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler>::message_received(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, )
}


use lightning::ln::peer_handler::MessageHandler as nativeMessageHandlerImport;
pub(crate) type nativeMessageHandler = nativeMessageHandlerImport<crate::lightning::ln::msgs::ChannelMessageHandler, crate::lightning::ln::msgs::RoutingMessageHandler, crate::lightning::ln::msgs::OnionMessageHandler, crate::lightning::ln::peer_handler::CustomMessageHandler, >;

/// Provides references to trait impls which handle different types of messages.
#[must_use]
#[repr(C)]
pub struct MessageHandler {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeMessageHandler,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for MessageHandler {
	type Target = nativeMessageHandler;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for MessageHandler { }
unsafe impl core::marker::Sync for MessageHandler { }
impl Drop for MessageHandler {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeMessageHandler>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the MessageHandler, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn MessageHandler_free(this_obj: MessageHandler) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn MessageHandler_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeMessageHandler) };
}
#[allow(unused)]
impl MessageHandler {
	pub(crate) fn get_native_ref(&self) -> &'static nativeMessageHandler {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeMessageHandler {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeMessageHandler {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// A message handler which handles messages specific to channels. Usually this is just a
/// [`ChannelManager`] object or an [`ErroringMessageHandler`].
///
/// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
#[no_mangle]
pub extern "C" fn MessageHandler_get_chan_handler(this_ptr: &MessageHandler) -> *const crate::lightning::ln::msgs::ChannelMessageHandler {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().chan_handler;
	inner_val
}
/// A message handler which handles messages specific to channels. Usually this is just a
/// [`ChannelManager`] object or an [`ErroringMessageHandler`].
///
/// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
#[no_mangle]
pub extern "C" fn MessageHandler_set_chan_handler(this_ptr: &mut MessageHandler, mut val: crate::lightning::ln::msgs::ChannelMessageHandler) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.chan_handler = val;
}
/// A message handler which handles messages updating our knowledge of the network channel
/// graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
///
/// [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
#[no_mangle]
pub extern "C" fn MessageHandler_get_route_handler(this_ptr: &MessageHandler) -> *const crate::lightning::ln::msgs::RoutingMessageHandler {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().route_handler;
	inner_val
}
/// A message handler which handles messages updating our knowledge of the network channel
/// graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
///
/// [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
#[no_mangle]
pub extern "C" fn MessageHandler_set_route_handler(this_ptr: &mut MessageHandler, mut val: crate::lightning::ln::msgs::RoutingMessageHandler) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.route_handler = val;
}
/// A message handler which handles onion messages. This should generally be an
/// [`OnionMessenger`], but can also be an [`IgnoringMessageHandler`].
///
/// [`OnionMessenger`]: crate::onion_message::messenger::OnionMessenger
#[no_mangle]
pub extern "C" fn MessageHandler_get_onion_message_handler(this_ptr: &MessageHandler) -> *const crate::lightning::ln::msgs::OnionMessageHandler {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().onion_message_handler;
	inner_val
}
/// A message handler which handles onion messages. This should generally be an
/// [`OnionMessenger`], but can also be an [`IgnoringMessageHandler`].
///
/// [`OnionMessenger`]: crate::onion_message::messenger::OnionMessenger
#[no_mangle]
pub extern "C" fn MessageHandler_set_onion_message_handler(this_ptr: &mut MessageHandler, mut val: crate::lightning::ln::msgs::OnionMessageHandler) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.onion_message_handler = val;
}
/// A message handler which handles custom messages. The only LDK-provided implementation is
/// [`IgnoringMessageHandler`].
#[no_mangle]
pub extern "C" fn MessageHandler_get_custom_message_handler(this_ptr: &MessageHandler) -> *const crate::lightning::ln::peer_handler::CustomMessageHandler {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().custom_message_handler;
	inner_val
}
/// A message handler which handles custom messages. The only LDK-provided implementation is
/// [`IgnoringMessageHandler`].
#[no_mangle]
pub extern "C" fn MessageHandler_set_custom_message_handler(this_ptr: &mut MessageHandler, mut val: crate::lightning::ln::peer_handler::CustomMessageHandler) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.custom_message_handler = val;
}
/// Constructs a new MessageHandler given each field
#[must_use]
#[no_mangle]
pub extern "C" fn MessageHandler_new(mut chan_handler_arg: crate::lightning::ln::msgs::ChannelMessageHandler, mut route_handler_arg: crate::lightning::ln::msgs::RoutingMessageHandler, mut onion_message_handler_arg: crate::lightning::ln::msgs::OnionMessageHandler, mut custom_message_handler_arg: crate::lightning::ln::peer_handler::CustomMessageHandler) -> MessageHandler {
	MessageHandler { inner: ObjOps::heap_alloc(nativeMessageHandler {
		chan_handler: chan_handler_arg,
		route_handler: route_handler_arg,
		onion_message_handler: onion_message_handler_arg,
		custom_message_handler: custom_message_handler_arg,
	}), is_owned: true }
}
/// Provides an object which can be used to send data to and which uniquely identifies a connection
/// to a remote host. You will need to be able to generate multiple of these which meet Eq and
/// implement Hash to meet the PeerManager API.
///
/// For efficiency, [`Clone`] should be relatively cheap for this type.
///
/// Two descriptors may compare equal (by [`cmp::Eq`] and [`hash::Hash`]) as long as the original
/// has been disconnected, the [`PeerManager`] has been informed of the disconnection (either by it
/// having triggered the disconnection or a call to [`PeerManager::socket_disconnected`]), and no
/// further calls to the [`PeerManager`] related to the original socket occur. This allows you to
/// use a file descriptor for your SocketDescriptor directly, however for simplicity you may wish
/// to simply use another value which is guaranteed to be globally unique instead.
#[repr(C)]
pub struct SocketDescriptor {
	/// An opaque pointer which is passed to your function implementations as an argument.
	/// This has no meaning in the LDK, and can be NULL or any other value.
	pub this_arg: *mut c_void,
	/// Attempts to send some data from the given slice to the peer.
	///
	/// Returns the amount of data which was sent, possibly 0 if the socket has since disconnected.
	/// Note that in the disconnected case, [`PeerManager::socket_disconnected`] must still be
	/// called and further write attempts may occur until that time.
	///
	/// If the returned size is smaller than `data.len()`, a
	/// [`PeerManager::write_buffer_space_avail`] call must be made the next time more data can be
	/// written. Additionally, until a `send_data` event completes fully, no further
	/// [`PeerManager::read_event`] calls should be made for the same peer! Because this is to
	/// prevent denial-of-service issues, you should not read or buffer any data from the socket
	/// until then.
	///
	/// If a [`PeerManager::read_event`] call on this descriptor had previously returned true
	/// (indicating that read events should be paused to prevent DoS in the send buffer),
	/// `resume_read` may be set indicating that read events on this descriptor should resume. A
	/// `resume_read` of false carries no meaning, and should not cause any action.
	pub send_data: extern "C" fn (this_arg: *mut c_void, data: crate::c_types::u8slice, resume_read: bool) -> usize,
	/// Disconnect the socket pointed to by this SocketDescriptor.
	///
	/// You do *not* need to call [`PeerManager::socket_disconnected`] with this socket after this
	/// call (doing so is a noop).
	pub disconnect_socket: extern "C" fn (this_arg: *mut c_void),
	/// Checks if two objects are equal given this object's this_arg pointer and another object.
	pub eq: extern "C" fn (this_arg: *const c_void, other_arg: &SocketDescriptor) -> bool,
	/// Calculate a succinct non-cryptographic hash for an object given its this_arg pointer.
	/// This is used, for example, for inclusion of this object in a hash map.
	pub hash: extern "C" fn (this_arg: *const c_void) -> u64,
	/// Called, if set, after this SocketDescriptor has been cloned into a duplicate object.
	/// The new SocketDescriptor is provided, and should be mutated as needed to perform a
	/// deep copy of the object pointed to by this_arg or avoid any double-freeing.
	pub cloned: Option<extern "C" fn (new_SocketDescriptor: &mut SocketDescriptor)>,
	/// Frees any resources associated with this object given its this_arg pointer.
	/// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
	pub free: Option<extern "C" fn(this_arg: *mut c_void)>,
}
unsafe impl Send for SocketDescriptor {}
unsafe impl Sync for SocketDescriptor {}
#[allow(unused)]
pub(crate) fn SocketDescriptor_clone_fields(orig: &SocketDescriptor) -> SocketDescriptor {
	SocketDescriptor {
		this_arg: orig.this_arg,
		send_data: Clone::clone(&orig.send_data),
		disconnect_socket: Clone::clone(&orig.disconnect_socket),
		eq: Clone::clone(&orig.eq),
		hash: Clone::clone(&orig.hash),
		cloned: Clone::clone(&orig.cloned),
		free: Clone::clone(&orig.free),
	}
}
impl core::cmp::Eq for SocketDescriptor {}
impl core::cmp::PartialEq for SocketDescriptor {
	fn eq(&self, o: &Self) -> bool { (self.eq)(self.this_arg, o) }
}
impl core::cmp::Eq for SocketDescriptorRef {}
impl core::cmp::PartialEq for SocketDescriptorRef {
	fn eq(&self, o: &Self) -> bool { (self.0.eq)(self.0.this_arg, &o.0) }
}
impl core::hash::Hash for SocketDescriptor {
	fn hash<H: core::hash::Hasher>(&self, hasher: &mut H) { hasher.write_u64((self.hash)(self.this_arg)) }
}
impl core::hash::Hash for SocketDescriptorRef {
	fn hash<H: core::hash::Hasher>(&self, hasher: &mut H) { hasher.write_u64((self.0.hash)(self.0.this_arg)) }
}
#[no_mangle]
/// Creates a copy of a SocketDescriptor
pub extern "C" fn SocketDescriptor_clone(orig: &SocketDescriptor) -> SocketDescriptor {
	let mut res = SocketDescriptor_clone_fields(orig);
	if let Some(f) = orig.cloned { (f)(&mut res) };
	res
}
impl Clone for SocketDescriptor {
	fn clone(&self) -> Self {
		SocketDescriptor_clone(self)
	}
}
impl Clone for SocketDescriptorRef {
	fn clone(&self) -> Self {
		Self(SocketDescriptor_clone(&self.0))
	}
}

use lightning::ln::peer_handler::SocketDescriptor as rustSocketDescriptor;
impl rustSocketDescriptor for SocketDescriptor {
	fn send_data(&mut self, mut data: &[u8], mut resume_read: bool) -> usize {
		let mut local_data = crate::c_types::u8slice::from_slice(data);
		let mut ret = (self.send_data)(self.this_arg, local_data, resume_read);
		ret
	}
	fn disconnect_socket(&mut self) {
		(self.disconnect_socket)(self.this_arg)
	}
}

pub struct SocketDescriptorRef(SocketDescriptor);
impl rustSocketDescriptor for SocketDescriptorRef {
	fn send_data(&mut self, mut data: &[u8], mut resume_read: bool) -> usize {
		let mut local_data = crate::c_types::u8slice::from_slice(data);
		let mut ret = (self.0.send_data)(self.0.this_arg, local_data, resume_read);
		ret
	}
	fn disconnect_socket(&mut self) {
		(self.0.disconnect_socket)(self.0.this_arg)
	}
}

// We're essentially a pointer already, or at least a set of pointers, so allow us to be used
// directly as a Deref trait in higher-level structs:
impl core::ops::Deref for SocketDescriptor {
	type Target = SocketDescriptorRef;
	fn deref(&self) -> &Self::Target {
		unsafe { &*(self as *const _ as *const SocketDescriptorRef) }
	}
}
impl core::ops::DerefMut for SocketDescriptor {
	fn deref_mut(&mut self) -> &mut SocketDescriptorRef {
		unsafe { &mut *(self as *mut _ as *mut SocketDescriptorRef) }
	}
}
/// Calls the free function if one is set
#[no_mangle]
pub extern "C" fn SocketDescriptor_free(this_ptr: SocketDescriptor) { }
impl Drop for SocketDescriptor {
	fn drop(&mut self) {
		if let Some(f) = self.free {
			f(self.this_arg);
		}
	}
}

use lightning::ln::peer_handler::PeerDetails as nativePeerDetailsImport;
pub(crate) type nativePeerDetails = nativePeerDetailsImport;

/// Details of a connected peer as returned by [`PeerManager::list_peers`].
#[must_use]
#[repr(C)]
pub struct PeerDetails {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativePeerDetails,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for PeerDetails {
	type Target = nativePeerDetails;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for PeerDetails { }
unsafe impl core::marker::Sync for PeerDetails { }
impl Drop for PeerDetails {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativePeerDetails>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the PeerDetails, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn PeerDetails_free(this_obj: PeerDetails) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PeerDetails_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativePeerDetails) };
}
#[allow(unused)]
impl PeerDetails {
	pub(crate) fn get_native_ref(&self) -> &'static nativePeerDetails {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativePeerDetails {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativePeerDetails {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// The node id of the peer.
///
/// For outbound connections, this [`PublicKey`] will be the same as the `their_node_id` parameter
/// passed in to [`PeerManager::new_outbound_connection`].
#[no_mangle]
pub extern "C" fn PeerDetails_get_counterparty_node_id(this_ptr: &PeerDetails) -> crate::c_types::PublicKey {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().counterparty_node_id;
	crate::c_types::PublicKey::from_rust(&inner_val)
}
/// The node id of the peer.
///
/// For outbound connections, this [`PublicKey`] will be the same as the `their_node_id` parameter
/// passed in to [`PeerManager::new_outbound_connection`].
#[no_mangle]
pub extern "C" fn PeerDetails_set_counterparty_node_id(this_ptr: &mut PeerDetails, mut val: crate::c_types::PublicKey) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.counterparty_node_id = val.into_rust();
}
/// The socket address the peer provided in the initial handshake.
///
/// Will only be `Some` if an address had been previously provided to
/// [`PeerManager::new_outbound_connection`] or [`PeerManager::new_inbound_connection`].
///
/// Returns a copy of the field.
#[no_mangle]
pub extern "C" fn PeerDetails_get_socket_address(this_ptr: &PeerDetails) -> crate::c_types::derived::COption_SocketAddressZ {
	let mut inner_val = this_ptr.get_native_mut_ref().socket_address.clone();
	let mut local_inner_val = if inner_val.is_none() { crate::c_types::derived::COption_SocketAddressZ::None } else { crate::c_types::derived::COption_SocketAddressZ::Some( { crate::lightning::ln::msgs::SocketAddress::native_into(inner_val.unwrap()) }) };
	local_inner_val
}
/// The socket address the peer provided in the initial handshake.
///
/// Will only be `Some` if an address had been previously provided to
/// [`PeerManager::new_outbound_connection`] or [`PeerManager::new_inbound_connection`].
#[no_mangle]
pub extern "C" fn PeerDetails_set_socket_address(this_ptr: &mut PeerDetails, mut val: crate::c_types::derived::COption_SocketAddressZ) {
	let mut local_val = { /*val*/ let val_opt = val; if val_opt.is_none() { None } else { Some({ { { val_opt.take() }.into_native() }})} };
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.socket_address = local_val;
}
/// The features the peer provided in the initial handshake.
#[no_mangle]
pub extern "C" fn PeerDetails_get_init_features(this_ptr: &PeerDetails) -> crate::lightning_types::features::InitFeatures {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().init_features;
	crate::lightning_types::features::InitFeatures { inner: unsafe { ObjOps::nonnull_ptr_to_inner((inner_val as *const lightning_types::features::InitFeatures<>) as *mut _) }, is_owned: false }
}
/// The features the peer provided in the initial handshake.
#[no_mangle]
pub extern "C" fn PeerDetails_set_init_features(this_ptr: &mut PeerDetails, mut val: crate::lightning_types::features::InitFeatures) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.init_features = *unsafe { Box::from_raw(val.take_inner()) };
}
/// Indicates the direction of the peer connection.
///
/// Will be `true` for inbound connections, and `false` for outbound connections.
#[no_mangle]
pub extern "C" fn PeerDetails_get_is_inbound_connection(this_ptr: &PeerDetails) -> bool {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().is_inbound_connection;
	*inner_val
}
/// Indicates the direction of the peer connection.
///
/// Will be `true` for inbound connections, and `false` for outbound connections.
#[no_mangle]
pub extern "C" fn PeerDetails_set_is_inbound_connection(this_ptr: &mut PeerDetails, mut val: bool) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.is_inbound_connection = val;
}
/// Constructs a new PeerDetails given each field
#[must_use]
#[no_mangle]
pub extern "C" fn PeerDetails_new(mut counterparty_node_id_arg: crate::c_types::PublicKey, mut socket_address_arg: crate::c_types::derived::COption_SocketAddressZ, mut init_features_arg: crate::lightning_types::features::InitFeatures, mut is_inbound_connection_arg: bool) -> PeerDetails {
	let mut local_socket_address_arg = { /*socket_address_arg*/ let socket_address_arg_opt = socket_address_arg; if socket_address_arg_opt.is_none() { None } else { Some({ { { socket_address_arg_opt.take() }.into_native() }})} };
	PeerDetails { inner: ObjOps::heap_alloc(nativePeerDetails {
		counterparty_node_id: counterparty_node_id_arg.into_rust(),
		socket_address: local_socket_address_arg,
		init_features: *unsafe { Box::from_raw(init_features_arg.take_inner()) },
		is_inbound_connection: is_inbound_connection_arg,
	}), is_owned: true }
}

use lightning::ln::peer_handler::PeerHandleError as nativePeerHandleErrorImport;
pub(crate) type nativePeerHandleError = nativePeerHandleErrorImport;

/// Error for PeerManager errors. If you get one of these, you must disconnect the socket and
/// generate no further read_event/write_buffer_space_avail/socket_disconnected calls for the
/// descriptor.
#[must_use]
#[repr(C)]
pub struct PeerHandleError {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativePeerHandleError,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for PeerHandleError {
	type Target = nativePeerHandleError;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for PeerHandleError { }
unsafe impl core::marker::Sync for PeerHandleError { }
impl Drop for PeerHandleError {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativePeerHandleError>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the PeerHandleError, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn PeerHandleError_free(this_obj: PeerHandleError) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PeerHandleError_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativePeerHandleError) };
}
#[allow(unused)]
impl PeerHandleError {
	pub(crate) fn get_native_ref(&self) -> &'static nativePeerHandleError {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativePeerHandleError {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativePeerHandleError {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// Constructs a new PeerHandleError given each field
#[must_use]
#[no_mangle]
pub extern "C" fn PeerHandleError_new() -> PeerHandleError {
	PeerHandleError { inner: ObjOps::heap_alloc(nativePeerHandleError {
	}), is_owned: true }
}
impl Clone for PeerHandleError {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativePeerHandleError>::is_null(self.inner) { core::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PeerHandleError_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const nativePeerHandleError)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the PeerHandleError
pub extern "C" fn PeerHandleError_clone(orig: &PeerHandleError) -> PeerHandleError {
	orig.clone()
}
/// Get a string which allows debug introspection of a PeerHandleError object
pub extern "C" fn PeerHandleError_debug_str_void(o: *const c_void) -> Str {
	alloc::format!("{:?}", unsafe { o as *const crate::lightning::ln::peer_handler::PeerHandleError }).into()}
#[no_mangle]
/// Get the string representation of a PeerHandleError object
pub extern "C" fn PeerHandleError_to_str(o: &crate::lightning::ln::peer_handler::PeerHandleError) -> Str {
	alloc::format!("{}", o.get_native_ref()).into()
}

use lightning::ln::peer_handler::PeerManager as nativePeerManagerImport;
pub(crate) type nativePeerManager = nativePeerManagerImport<crate::lightning::ln::peer_handler::SocketDescriptor, crate::lightning::ln::msgs::ChannelMessageHandler, crate::lightning::ln::msgs::RoutingMessageHandler, crate::lightning::ln::msgs::OnionMessageHandler, crate::lightning::util::logger::Logger, crate::lightning::ln::peer_handler::CustomMessageHandler, crate::lightning::sign::NodeSigner, >;

/// A PeerManager manages a set of peers, described by their [`SocketDescriptor`] and marshalls
/// socket events into messages which it passes on to its [`MessageHandler`].
///
/// Locks are taken internally, so you must never assume that reentrancy from a
/// [`SocketDescriptor`] call back into [`PeerManager`] methods will not deadlock.
///
/// Calls to [`read_event`] will decode relevant messages and pass them to the
/// [`ChannelMessageHandler`], likely doing message processing in-line. Thus, the primary form of
/// parallelism in Rust-Lightning is in calls to [`read_event`]. Note, however, that calls to any
/// [`PeerManager`] functions related to the same connection must occur only in serial, making new
/// calls only after previous ones have returned.
///
/// Rather than using a plain [`PeerManager`], it is preferable to use either a [`SimpleArcPeerManager`]
/// a [`SimpleRefPeerManager`], for conciseness. See their documentation for more details, but
/// essentially you should default to using a [`SimpleRefPeerManager`], and use a
/// [`SimpleArcPeerManager`] when you require a `PeerManager` with a static lifetime, such as when
/// you're using lightning-net-tokio.
///
/// [`read_event`]: PeerManager::read_event
#[must_use]
#[repr(C)]
pub struct PeerManager {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativePeerManager,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for PeerManager {
	type Target = nativePeerManager;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for PeerManager { }
unsafe impl core::marker::Sync for PeerManager { }
impl Drop for PeerManager {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativePeerManager>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the PeerManager, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn PeerManager_free(this_obj: PeerManager) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PeerManager_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativePeerManager) };
}
#[allow(unused)]
impl PeerManager {
	pub(crate) fn get_native_ref(&self) -> &'static nativePeerManager {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativePeerManager {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativePeerManager {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// Constructs a new `PeerManager` with the given message handlers.
///
/// `ephemeral_random_data` is used to derive per-connection ephemeral keys and must be
/// cryptographically secure random bytes.
///
/// `current_time` is used as an always-increasing counter that survives across restarts and is
/// incremented irregularly internally. In general it is best to simply use the current UNIX
/// timestamp, however if it is not available a persistent counter that increases once per
/// minute should suffice.
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_new(mut message_handler: crate::lightning::ln::peer_handler::MessageHandler, mut current_time: u32, ephemeral_random_data: *const [u8; 32], mut logger: crate::lightning::util::logger::Logger, mut node_signer: crate::lightning::sign::NodeSigner) -> crate::lightning::ln::peer_handler::PeerManager {
	let mut ret = lightning::ln::peer_handler::PeerManager::new(*unsafe { Box::from_raw(message_handler.take_inner()) }, current_time, unsafe { &*ephemeral_random_data}, logger, node_signer);
	crate::lightning::ln::peer_handler::PeerManager { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Returns a list of [`PeerDetails`] for connected peers that have completed the initial
/// handshake.
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_list_peers(this_arg: &crate::lightning::ln::peer_handler::PeerManager) -> crate::c_types::derived::CVec_PeerDetailsZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.list_peers();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::ln::peer_handler::PeerDetails { inner: ObjOps::heap_alloc(item), is_owned: true } }); };
	local_ret.into()
}

/// Returns the [`PeerDetails`] of a connected peer that has completed the initial handshake.
///
/// Will return `None` if the peer is unknown or it hasn't completed the initial handshake.
///
/// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_peer_by_node_id(this_arg: &crate::lightning::ln::peer_handler::PeerManager, mut their_node_id: crate::c_types::PublicKey) -> crate::lightning::ln::peer_handler::PeerDetails {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.peer_by_node_id(&their_node_id.into_rust());
	let mut local_ret = crate::lightning::ln::peer_handler::PeerDetails { inner: if ret.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((ret.unwrap())) } }, is_owned: true };
	local_ret
}

/// Indicates a new outbound connection has been established to a node with the given `node_id`
/// and an optional remote network address.
///
/// The remote network address adds the option to report a remote IP address back to a connecting
/// peer using the init message.
/// The user should pass the remote network address of the host they are connected to.
///
/// If an `Err` is returned here you must disconnect the connection immediately.
///
/// Returns a small number of bytes to send to the remote node (currently always 50).
///
/// Panics if descriptor is duplicative with some other descriptor which has not yet been
/// [`socket_disconnected`].
///
/// [`socket_disconnected`]: PeerManager::socket_disconnected
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_new_outbound_connection(this_arg: &crate::lightning::ln::peer_handler::PeerManager, mut their_node_id: crate::c_types::PublicKey, mut descriptor: crate::lightning::ln::peer_handler::SocketDescriptor, mut remote_network_address: crate::c_types::derived::COption_SocketAddressZ) -> crate::c_types::derived::CResult_CVec_u8ZPeerHandleErrorZ {
	let mut local_remote_network_address = { /*remote_network_address*/ let remote_network_address_opt = remote_network_address; if remote_network_address_opt.is_none() { None } else { Some({ { { remote_network_address_opt.take() }.into_native() }})} };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.new_outbound_connection(their_node_id.into_rust(), descriptor, local_remote_network_address);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let mut local_ret_0 = Vec::new(); for mut item in o.drain(..) { local_ret_0.push( { item }); }; local_ret_0.into() }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::peer_handler::PeerHandleError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}

/// Indicates a new inbound connection has been established to a node with an optional remote
/// network address.
///
/// The remote network address adds the option to report a remote IP address back to a connecting
/// peer using the init message.
/// The user should pass the remote network address of the host they are connected to.
///
/// May refuse the connection by returning an Err, but will never write bytes to the remote end
/// (outbound connector always speaks first). If an `Err` is returned here you must disconnect
/// the connection immediately.
///
/// Panics if descriptor is duplicative with some other descriptor which has not yet been
/// [`socket_disconnected`].
///
/// [`socket_disconnected`]: PeerManager::socket_disconnected
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_new_inbound_connection(this_arg: &crate::lightning::ln::peer_handler::PeerManager, mut descriptor: crate::lightning::ln::peer_handler::SocketDescriptor, mut remote_network_address: crate::c_types::derived::COption_SocketAddressZ) -> crate::c_types::derived::CResult_NonePeerHandleErrorZ {
	let mut local_remote_network_address = { /*remote_network_address*/ let remote_network_address_opt = remote_network_address; if remote_network_address_opt.is_none() { None } else { Some({ { { remote_network_address_opt.take() }.into_native() }})} };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.new_inbound_connection(descriptor, local_remote_network_address);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::peer_handler::PeerHandleError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}

/// Indicates that there is room to write data to the given socket descriptor.
///
/// May return an Err to indicate that the connection should be closed.
///
/// May call [`send_data`] on the descriptor passed in (or an equal descriptor) before
/// returning. Thus, be very careful with reentrancy issues! The invariants around calling
/// [`write_buffer_space_avail`] in case a write did not fully complete must still hold - be
/// ready to call [`write_buffer_space_avail`] again if a write call generated here isn't
/// sufficient!
///
/// [`send_data`]: SocketDescriptor::send_data
/// [`write_buffer_space_avail`]: PeerManager::write_buffer_space_avail
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_write_buffer_space_avail(this_arg: &crate::lightning::ln::peer_handler::PeerManager, descriptor: &mut crate::lightning::ln::peer_handler::SocketDescriptor) -> crate::c_types::derived::CResult_NonePeerHandleErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.write_buffer_space_avail(descriptor);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::peer_handler::PeerHandleError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}

/// Indicates that data was read from the given socket descriptor.
///
/// May return an Err to indicate that the connection should be closed.
///
/// Will *not* call back into [`send_data`] on any descriptors to avoid reentrancy complexity.
/// Thus, however, you should call [`process_events`] after any `read_event` to generate
/// [`send_data`] calls to handle responses.
///
/// If `Ok(true)` is returned, further read_events should not be triggered until a
/// [`send_data`] call on this descriptor has `resume_read` set (preventing DoS issues in the
/// send buffer).
///
/// In order to avoid processing too many messages at once per peer, `data` should be on the
/// order of 4KiB.
///
/// [`send_data`]: SocketDescriptor::send_data
/// [`process_events`]: PeerManager::process_events
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_read_event(this_arg: &crate::lightning::ln::peer_handler::PeerManager, peer_descriptor: &mut crate::lightning::ln::peer_handler::SocketDescriptor, mut data: crate::c_types::u8slice) -> crate::c_types::derived::CResult_boolPeerHandleErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.read_event(peer_descriptor, data.to_slice());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { o }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::peer_handler::PeerHandleError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}

/// Checks for any events generated by our handlers and processes them. Includes sending most
/// response messages as well as messages generated by calls to handler functions directly (eg
/// functions like [`ChannelManager::process_pending_htlc_forwards`] or [`send_payment`]).
///
/// May call [`send_data`] on [`SocketDescriptor`]s. Thus, be very careful with reentrancy
/// issues!
///
/// This should be called any time we may have messages to send. It is automatically called by
/// [`lightning-net-tokio`] after processing incoming messages, and by
/// [`lightning-background-processor`] when channel state has changed. Therefore, If you are not
/// using both [`lightning-net-tokio`] and [`lightning-background-processor`], you may need to call
/// this function manually to prevent messages from being delayed.
///
/// Note that if there are any other calls to this function waiting on lock(s) this may return
/// without doing any work. All available events that need handling will be handled before the
/// other calls return.
///
/// [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
/// [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
/// [`send_data`]: SocketDescriptor::send_data
#[no_mangle]
pub extern "C" fn PeerManager_process_events(this_arg: &crate::lightning::ln::peer_handler::PeerManager) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.process_events()
}

/// Indicates that the given socket descriptor's connection is now closed.
#[no_mangle]
pub extern "C" fn PeerManager_socket_disconnected(this_arg: &crate::lightning::ln::peer_handler::PeerManager, descriptor: &crate::lightning::ln::peer_handler::SocketDescriptor) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.socket_disconnected(descriptor)
}

/// Disconnect a peer given its node id.
///
/// If a peer is connected, this will call [`disconnect_socket`] on the descriptor for the
/// peer. Thus, be very careful about reentrancy issues.
///
/// [`disconnect_socket`]: SocketDescriptor::disconnect_socket
#[no_mangle]
pub extern "C" fn PeerManager_disconnect_by_node_id(this_arg: &crate::lightning::ln::peer_handler::PeerManager, mut node_id: crate::c_types::PublicKey) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.disconnect_by_node_id(node_id.into_rust())
}

/// Disconnects all currently-connected peers. This is useful on platforms where there may be
/// an indication that TCP sockets have stalled even if we weren't around to time them out
/// using regular ping/pongs.
#[no_mangle]
pub extern "C" fn PeerManager_disconnect_all_peers(this_arg: &crate::lightning::ln::peer_handler::PeerManager) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.disconnect_all_peers()
}

/// Send pings to each peer and disconnect those which did not respond to the last round of
/// pings.
///
/// This may be called on any timescale you want, however, roughly once every ten seconds is
/// preferred. The call rate determines both how often we send a ping to our peers and how much
/// time they have to respond before we disconnect them.
///
/// May call [`send_data`] on all [`SocketDescriptor`]s. Thus, be very careful with reentrancy
/// issues!
///
/// [`send_data`]: SocketDescriptor::send_data
#[no_mangle]
pub extern "C" fn PeerManager_timer_tick_occurred(this_arg: &crate::lightning::ln::peer_handler::PeerManager) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.timer_tick_occurred()
}

/// Generates a signed node_announcement from the given arguments, sending it to all connected
/// peers. Note that peers will likely ignore this message unless we have at least one public
/// channel which has at least six confirmations on-chain.
///
/// `rgb` is a node \"color\" and `alias` is a printable human-readable string to describe this
/// node to humans. They carry no in-protocol meaning.
///
/// `addresses` represent the set (possibly empty) of socket addresses on which this node
/// accepts incoming connections. These will be included in the node_announcement, publicly
/// tying these addresses together and to this node. If you wish to preserve user privacy,
/// addresses should likely contain only Tor Onion addresses.
///
/// Panics if `addresses` is absurdly large (more than 100).
///
/// [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
#[no_mangle]
pub extern "C" fn PeerManager_broadcast_node_announcement(this_arg: &crate::lightning::ln::peer_handler::PeerManager, mut rgb: crate::c_types::ThreeBytes, mut alias: crate::c_types::ThirtyTwoBytes, mut addresses: crate::c_types::derived::CVec_SocketAddressZ) {
	let mut local_addresses = Vec::new(); for mut item in addresses.into_rust().drain(..) { local_addresses.push( { item.into_native() }); };
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.broadcast_node_announcement(rgb.data, alias.data, local_addresses)
}

use core::convert::Infallible as nativeInfallible;
