// This file is Copyright its original authors, visible in version control
// history and in the source files from which this was generated.
//
// This file is licensed under the license available in the LICENSE or LICENSE.md
// file in the root of this repository or, if no such file exists, the same
// license as that which applies to the original source files from which this
// source was automatically generated.

//! The top-level channel management and payment tracking stuff lives here.
//!
//! The [`ChannelManager`] is the main chunk of logic implementing the lightning protocol and is
//! responsible for tracking which channels are open, HTLCs are in flight and reestablishing those
//! upon reconnect to the relevant peer(s).
//!
//! It does not manage routing logic (see [`Router`] for that) nor does it manage constructing
//! on-chain transactions (it only monitors the chain to watch for any force-closes that might
//! imply it needs to fail HTLCs/payments/channels it manages).

use alloc::str::FromStr;
use alloc::string::String;
use core::ffi::c_void;
use core::convert::Infallible;
use bitcoin::hashes::Hash;
use crate::c_types::*;
#[cfg(feature="no-std")]
use alloc::{vec::Vec, boxed::Box};

/// Information about where a received HTLC('s onion) has indicated the HTLC should go.
#[derive(Clone)]
#[must_use]
#[repr(C)]
pub enum PendingHTLCRouting {
	/// An HTLC which should be forwarded on to another node.
	Forward {
		/// The onion which should be included in the forwarded HTLC, telling the next hop what to
		/// do with the HTLC.
		onion_packet: crate::lightning::ln::msgs::OnionPacket,
		/// The short channel ID of the channel which we were instructed to forward this HTLC to.
		///
		/// This could be a real on-chain SCID, an SCID alias, or some other SCID which has meaning
		/// to the receiving node, such as one returned from
		/// [`ChannelManager::get_intercept_scid`] or [`ChannelManager::get_phantom_scid`].
		short_channel_id: u64,
		/// Set if this HTLC is being forwarded within a blinded path.
		///
		/// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
		blinded: crate::lightning::ln::channelmanager::BlindedForward,
		/// The absolute CLTV of the inbound HTLC
		incoming_cltv_expiry: crate::c_types::derived::COption_u32Z,
	},
	/// The onion indicates that this is a payment for an invoice (supposedly) generated by us.
	///
	/// Note that at this point, we have not checked that the invoice being paid was actually
	/// generated by us, but rather it's claiming to pay an invoice of ours.
	Receive {
		/// Information about the amount the sender intended to pay and (potential) proof that this
		/// is a payment for an invoice we generated. This proof of payment is is also used for
		/// linking MPP parts of a larger payment.
		payment_data: crate::lightning::ln::msgs::FinalOnionHopData,
		/// Additional data which we (allegedly) instructed the sender to include in the onion.
		///
		/// For HTLCs received by LDK, this will ultimately be exposed in
		/// [`Event::PaymentClaimable::onion_fields`] as
		/// [`RecipientOnionFields::payment_metadata`].
		payment_metadata: crate::c_types::derived::COption_CVec_u8ZZ,
		/// The context of the payment included by the recipient in a blinded path, or `None` if a
		/// blinded path was not used.
		///
		/// Used in part to determine the [`events::PaymentPurpose`].
		payment_context: crate::c_types::derived::COption_PaymentContextZ,
		/// CLTV expiry of the received HTLC.
		///
		/// Used to track when we should expire pending HTLCs that go unclaimed.
		incoming_cltv_expiry: u32,
		/// If the onion had forwarding instructions to one of our phantom node SCIDs, this will
		/// provide the onion shared secret used to decrypt the next level of forwarding
		/// instructions.
		///
		/// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
		phantom_shared_secret: crate::c_types::ThirtyTwoBytes,
		/// Custom TLVs which were set by the sender.
		///
		/// For HTLCs received by LDK, this will ultimately be exposed in
		/// [`Event::PaymentClaimable::onion_fields`] as
		/// [`RecipientOnionFields::custom_tlvs`].
		custom_tlvs: crate::c_types::derived::CVec_C2Tuple_u64CVec_u8ZZZ,
		/// Set if this HTLC is the final hop in a multi-hop blinded path.
		requires_blinded_error: bool,
	},
	/// The onion indicates that this is for payment to us but which contains the preimage for
	/// claiming included, and is unrelated to any invoice we'd previously generated (aka a
	/// \"keysend\" or \"spontaneous\" payment).
	ReceiveKeysend {
		/// Information about the amount the sender intended to pay and possibly a token to
		/// associate MPP parts of a larger payment.
		///
		/// This will only be filled in if receiving MPP keysend payments is enabled, and it being
		/// present will cause deserialization to fail on versions of LDK prior to 0.0.116.
		///
		/// Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
		payment_data: crate::lightning::ln::msgs::FinalOnionHopData,
		/// Preimage for this onion payment. This preimage is provided by the sender and will be
		/// used to settle the spontaneous payment.
		payment_preimage: crate::c_types::ThirtyTwoBytes,
		/// Additional data which we (allegedly) instructed the sender to include in the onion.
		///
		/// For HTLCs received by LDK, this will ultimately bubble back up as
		/// [`RecipientOnionFields::payment_metadata`].
		payment_metadata: crate::c_types::derived::COption_CVec_u8ZZ,
		/// CLTV expiry of the received HTLC.
		///
		/// Used to track when we should expire pending HTLCs that go unclaimed.
		incoming_cltv_expiry: u32,
		/// Custom TLVs which were set by the sender.
		///
		/// For HTLCs received by LDK, these will ultimately bubble back up as
		/// [`RecipientOnionFields::custom_tlvs`].
		custom_tlvs: crate::c_types::derived::CVec_C2Tuple_u64CVec_u8ZZZ,
		/// Set if this HTLC is the final hop in a multi-hop blinded path.
		requires_blinded_error: bool,
		/// Set if we are receiving a keysend to a blinded path, meaning we created the
		/// [`PaymentSecret`] and should verify it using our
		/// [`NodeSigner::get_inbound_payment_key`].
		has_recipient_created_payment_secret: bool,
	},
}
use lightning::ln::channelmanager::PendingHTLCRouting as PendingHTLCRoutingImport;
pub(crate) type nativePendingHTLCRouting = PendingHTLCRoutingImport;

impl PendingHTLCRouting {
	#[allow(unused)]
	pub(crate) fn to_native(&self) -> nativePendingHTLCRouting {
		match self {
			PendingHTLCRouting::Forward {ref onion_packet, ref short_channel_id, ref blinded, ref incoming_cltv_expiry, } => {
				let mut onion_packet_nonref = Clone::clone(onion_packet);
				let mut short_channel_id_nonref = Clone::clone(short_channel_id);
				let mut blinded_nonref = Clone::clone(blinded);
				let mut local_blinded_nonref = if blinded_nonref.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(blinded_nonref.take_inner()) } }) };
				let mut incoming_cltv_expiry_nonref = Clone::clone(incoming_cltv_expiry);
				let mut local_incoming_cltv_expiry_nonref = if incoming_cltv_expiry_nonref.is_some() { Some( { incoming_cltv_expiry_nonref.take() }) } else { None };
				nativePendingHTLCRouting::Forward {
					onion_packet: *unsafe { Box::from_raw(onion_packet_nonref.take_inner()) },
					short_channel_id: short_channel_id_nonref,
					blinded: local_blinded_nonref,
					incoming_cltv_expiry: local_incoming_cltv_expiry_nonref,
				}
			},
			PendingHTLCRouting::Receive {ref payment_data, ref payment_metadata, ref payment_context, ref incoming_cltv_expiry, ref phantom_shared_secret, ref custom_tlvs, ref requires_blinded_error, } => {
				let mut payment_data_nonref = Clone::clone(payment_data);
				let mut payment_metadata_nonref = Clone::clone(payment_metadata);
				let mut local_payment_metadata_nonref = { /*payment_metadata_nonref*/ let payment_metadata_nonref_opt = payment_metadata_nonref; if payment_metadata_nonref_opt.is_none() { None } else { Some({ { let mut local_payment_metadata_nonref_0 = Vec::new(); for mut item in { payment_metadata_nonref_opt.take() }.into_rust().drain(..) { local_payment_metadata_nonref_0.push( { item }); }; local_payment_metadata_nonref_0 }})} };
				let mut payment_context_nonref = Clone::clone(payment_context);
				let mut local_payment_context_nonref = { /*payment_context_nonref*/ let payment_context_nonref_opt = payment_context_nonref; if payment_context_nonref_opt.is_none() { None } else { Some({ { { payment_context_nonref_opt.take() }.into_native() }})} };
				let mut incoming_cltv_expiry_nonref = Clone::clone(incoming_cltv_expiry);
				let mut phantom_shared_secret_nonref = Clone::clone(phantom_shared_secret);
				let mut local_phantom_shared_secret_nonref = if phantom_shared_secret_nonref.data == [0; 32] { None } else { Some( { phantom_shared_secret_nonref.data }) };
				let mut custom_tlvs_nonref = Clone::clone(custom_tlvs);
				let mut local_custom_tlvs_nonref = Vec::new(); for mut item in custom_tlvs_nonref.into_rust().drain(..) { local_custom_tlvs_nonref.push( { let (mut orig_custom_tlvs_nonref_0_0, mut orig_custom_tlvs_nonref_0_1) = item.to_rust(); let mut local_orig_custom_tlvs_nonref_0_1 = Vec::new(); for mut item in orig_custom_tlvs_nonref_0_1.into_rust().drain(..) { local_orig_custom_tlvs_nonref_0_1.push( { item }); }; let mut local_custom_tlvs_nonref_0 = (orig_custom_tlvs_nonref_0_0, local_orig_custom_tlvs_nonref_0_1); local_custom_tlvs_nonref_0 }); };
				let mut requires_blinded_error_nonref = Clone::clone(requires_blinded_error);
				nativePendingHTLCRouting::Receive {
					payment_data: *unsafe { Box::from_raw(payment_data_nonref.take_inner()) },
					payment_metadata: local_payment_metadata_nonref,
					payment_context: local_payment_context_nonref,
					incoming_cltv_expiry: incoming_cltv_expiry_nonref,
					phantom_shared_secret: local_phantom_shared_secret_nonref,
					custom_tlvs: local_custom_tlvs_nonref,
					requires_blinded_error: requires_blinded_error_nonref,
				}
			},
			PendingHTLCRouting::ReceiveKeysend {ref payment_data, ref payment_preimage, ref payment_metadata, ref incoming_cltv_expiry, ref custom_tlvs, ref requires_blinded_error, ref has_recipient_created_payment_secret, } => {
				let mut payment_data_nonref = Clone::clone(payment_data);
				let mut local_payment_data_nonref = if payment_data_nonref.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(payment_data_nonref.take_inner()) } }) };
				let mut payment_preimage_nonref = Clone::clone(payment_preimage);
				let mut payment_metadata_nonref = Clone::clone(payment_metadata);
				let mut local_payment_metadata_nonref = { /*payment_metadata_nonref*/ let payment_metadata_nonref_opt = payment_metadata_nonref; if payment_metadata_nonref_opt.is_none() { None } else { Some({ { let mut local_payment_metadata_nonref_0 = Vec::new(); for mut item in { payment_metadata_nonref_opt.take() }.into_rust().drain(..) { local_payment_metadata_nonref_0.push( { item }); }; local_payment_metadata_nonref_0 }})} };
				let mut incoming_cltv_expiry_nonref = Clone::clone(incoming_cltv_expiry);
				let mut custom_tlvs_nonref = Clone::clone(custom_tlvs);
				let mut local_custom_tlvs_nonref = Vec::new(); for mut item in custom_tlvs_nonref.into_rust().drain(..) { local_custom_tlvs_nonref.push( { let (mut orig_custom_tlvs_nonref_0_0, mut orig_custom_tlvs_nonref_0_1) = item.to_rust(); let mut local_orig_custom_tlvs_nonref_0_1 = Vec::new(); for mut item in orig_custom_tlvs_nonref_0_1.into_rust().drain(..) { local_orig_custom_tlvs_nonref_0_1.push( { item }); }; let mut local_custom_tlvs_nonref_0 = (orig_custom_tlvs_nonref_0_0, local_orig_custom_tlvs_nonref_0_1); local_custom_tlvs_nonref_0 }); };
				let mut requires_blinded_error_nonref = Clone::clone(requires_blinded_error);
				let mut has_recipient_created_payment_secret_nonref = Clone::clone(has_recipient_created_payment_secret);
				nativePendingHTLCRouting::ReceiveKeysend {
					payment_data: local_payment_data_nonref,
					payment_preimage: ::lightning::types::payment::PaymentPreimage(payment_preimage_nonref.data),
					payment_metadata: local_payment_metadata_nonref,
					incoming_cltv_expiry: incoming_cltv_expiry_nonref,
					custom_tlvs: local_custom_tlvs_nonref,
					requires_blinded_error: requires_blinded_error_nonref,
					has_recipient_created_payment_secret: has_recipient_created_payment_secret_nonref,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn into_native(self) -> nativePendingHTLCRouting {
		match self {
			PendingHTLCRouting::Forward {mut onion_packet, mut short_channel_id, mut blinded, mut incoming_cltv_expiry, } => {
				let mut local_blinded = if blinded.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(blinded.take_inner()) } }) };
				let mut local_incoming_cltv_expiry = if incoming_cltv_expiry.is_some() { Some( { incoming_cltv_expiry.take() }) } else { None };
				nativePendingHTLCRouting::Forward {
					onion_packet: *unsafe { Box::from_raw(onion_packet.take_inner()) },
					short_channel_id: short_channel_id,
					blinded: local_blinded,
					incoming_cltv_expiry: local_incoming_cltv_expiry,
				}
			},
			PendingHTLCRouting::Receive {mut payment_data, mut payment_metadata, mut payment_context, mut incoming_cltv_expiry, mut phantom_shared_secret, mut custom_tlvs, mut requires_blinded_error, } => {
				let mut local_payment_metadata = { /*payment_metadata*/ let payment_metadata_opt = payment_metadata; if payment_metadata_opt.is_none() { None } else { Some({ { let mut local_payment_metadata_0 = Vec::new(); for mut item in { payment_metadata_opt.take() }.into_rust().drain(..) { local_payment_metadata_0.push( { item }); }; local_payment_metadata_0 }})} };
				let mut local_payment_context = { /*payment_context*/ let payment_context_opt = payment_context; if payment_context_opt.is_none() { None } else { Some({ { { payment_context_opt.take() }.into_native() }})} };
				let mut local_phantom_shared_secret = if phantom_shared_secret.data == [0; 32] { None } else { Some( { phantom_shared_secret.data }) };
				let mut local_custom_tlvs = Vec::new(); for mut item in custom_tlvs.into_rust().drain(..) { local_custom_tlvs.push( { let (mut orig_custom_tlvs_0_0, mut orig_custom_tlvs_0_1) = item.to_rust(); let mut local_orig_custom_tlvs_0_1 = Vec::new(); for mut item in orig_custom_tlvs_0_1.into_rust().drain(..) { local_orig_custom_tlvs_0_1.push( { item }); }; let mut local_custom_tlvs_0 = (orig_custom_tlvs_0_0, local_orig_custom_tlvs_0_1); local_custom_tlvs_0 }); };
				nativePendingHTLCRouting::Receive {
					payment_data: *unsafe { Box::from_raw(payment_data.take_inner()) },
					payment_metadata: local_payment_metadata,
					payment_context: local_payment_context,
					incoming_cltv_expiry: incoming_cltv_expiry,
					phantom_shared_secret: local_phantom_shared_secret,
					custom_tlvs: local_custom_tlvs,
					requires_blinded_error: requires_blinded_error,
				}
			},
			PendingHTLCRouting::ReceiveKeysend {mut payment_data, mut payment_preimage, mut payment_metadata, mut incoming_cltv_expiry, mut custom_tlvs, mut requires_blinded_error, mut has_recipient_created_payment_secret, } => {
				let mut local_payment_data = if payment_data.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(payment_data.take_inner()) } }) };
				let mut local_payment_metadata = { /*payment_metadata*/ let payment_metadata_opt = payment_metadata; if payment_metadata_opt.is_none() { None } else { Some({ { let mut local_payment_metadata_0 = Vec::new(); for mut item in { payment_metadata_opt.take() }.into_rust().drain(..) { local_payment_metadata_0.push( { item }); }; local_payment_metadata_0 }})} };
				let mut local_custom_tlvs = Vec::new(); for mut item in custom_tlvs.into_rust().drain(..) { local_custom_tlvs.push( { let (mut orig_custom_tlvs_0_0, mut orig_custom_tlvs_0_1) = item.to_rust(); let mut local_orig_custom_tlvs_0_1 = Vec::new(); for mut item in orig_custom_tlvs_0_1.into_rust().drain(..) { local_orig_custom_tlvs_0_1.push( { item }); }; let mut local_custom_tlvs_0 = (orig_custom_tlvs_0_0, local_orig_custom_tlvs_0_1); local_custom_tlvs_0 }); };
				nativePendingHTLCRouting::ReceiveKeysend {
					payment_data: local_payment_data,
					payment_preimage: ::lightning::types::payment::PaymentPreimage(payment_preimage.data),
					payment_metadata: local_payment_metadata,
					incoming_cltv_expiry: incoming_cltv_expiry,
					custom_tlvs: local_custom_tlvs,
					requires_blinded_error: requires_blinded_error,
					has_recipient_created_payment_secret: has_recipient_created_payment_secret,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn from_native(native: &PendingHTLCRoutingImport) -> Self {
		let native = unsafe { &*(native as *const _ as *const c_void as *const nativePendingHTLCRouting) };
		match native {
			nativePendingHTLCRouting::Forward {ref onion_packet, ref short_channel_id, ref blinded, ref incoming_cltv_expiry, } => {
				let mut onion_packet_nonref = Clone::clone(onion_packet);
				let mut short_channel_id_nonref = Clone::clone(short_channel_id);
				let mut blinded_nonref = Clone::clone(blinded);
				let mut local_blinded_nonref = crate::lightning::ln::channelmanager::BlindedForward { inner: if blinded_nonref.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((blinded_nonref.unwrap())) } }, is_owned: true };
				let mut incoming_cltv_expiry_nonref = Clone::clone(incoming_cltv_expiry);
				let mut local_incoming_cltv_expiry_nonref = if incoming_cltv_expiry_nonref.is_none() { crate::c_types::derived::COption_u32Z::None } else { crate::c_types::derived::COption_u32Z::Some( { incoming_cltv_expiry_nonref.unwrap() }) };
				PendingHTLCRouting::Forward {
					onion_packet: crate::lightning::ln::msgs::OnionPacket { inner: ObjOps::heap_alloc(onion_packet_nonref), is_owned: true },
					short_channel_id: short_channel_id_nonref,
					blinded: local_blinded_nonref,
					incoming_cltv_expiry: local_incoming_cltv_expiry_nonref,
				}
			},
			nativePendingHTLCRouting::Receive {ref payment_data, ref payment_metadata, ref payment_context, ref incoming_cltv_expiry, ref phantom_shared_secret, ref custom_tlvs, ref requires_blinded_error, } => {
				let mut payment_data_nonref = Clone::clone(payment_data);
				let mut payment_metadata_nonref = Clone::clone(payment_metadata);
				let mut local_payment_metadata_nonref = if payment_metadata_nonref.is_none() { crate::c_types::derived::COption_CVec_u8ZZ::None } else { crate::c_types::derived::COption_CVec_u8ZZ::Some( { let mut local_payment_metadata_nonref_0 = Vec::new(); for mut item in payment_metadata_nonref.unwrap().drain(..) { local_payment_metadata_nonref_0.push( { item }); }; local_payment_metadata_nonref_0.into() }) };
				let mut payment_context_nonref = Clone::clone(payment_context);
				let mut local_payment_context_nonref = if payment_context_nonref.is_none() { crate::c_types::derived::COption_PaymentContextZ::None } else { crate::c_types::derived::COption_PaymentContextZ::Some( { crate::lightning::blinded_path::payment::PaymentContext::native_into(payment_context_nonref.unwrap()) }) };
				let mut incoming_cltv_expiry_nonref = Clone::clone(incoming_cltv_expiry);
				let mut phantom_shared_secret_nonref = Clone::clone(phantom_shared_secret);
				let mut local_phantom_shared_secret_nonref = if phantom_shared_secret_nonref.is_none() { crate::c_types::ThirtyTwoBytes { data: [0; 32] } } else {  { crate::c_types::ThirtyTwoBytes { data: (phantom_shared_secret_nonref.unwrap()) } } };
				let mut custom_tlvs_nonref = Clone::clone(custom_tlvs);
				let mut local_custom_tlvs_nonref = Vec::new(); for mut item in custom_tlvs_nonref.drain(..) { local_custom_tlvs_nonref.push( { let (mut orig_custom_tlvs_nonref_0_0, mut orig_custom_tlvs_nonref_0_1) = item; let mut local_orig_custom_tlvs_nonref_0_1 = Vec::new(); for mut item in orig_custom_tlvs_nonref_0_1.drain(..) { local_orig_custom_tlvs_nonref_0_1.push( { item }); }; let mut local_custom_tlvs_nonref_0 = (orig_custom_tlvs_nonref_0_0, local_orig_custom_tlvs_nonref_0_1.into()).into(); local_custom_tlvs_nonref_0 }); };
				let mut requires_blinded_error_nonref = Clone::clone(requires_blinded_error);
				PendingHTLCRouting::Receive {
					payment_data: crate::lightning::ln::msgs::FinalOnionHopData { inner: ObjOps::heap_alloc(payment_data_nonref), is_owned: true },
					payment_metadata: local_payment_metadata_nonref,
					payment_context: local_payment_context_nonref,
					incoming_cltv_expiry: incoming_cltv_expiry_nonref,
					phantom_shared_secret: local_phantom_shared_secret_nonref,
					custom_tlvs: local_custom_tlvs_nonref.into(),
					requires_blinded_error: requires_blinded_error_nonref,
				}
			},
			nativePendingHTLCRouting::ReceiveKeysend {ref payment_data, ref payment_preimage, ref payment_metadata, ref incoming_cltv_expiry, ref custom_tlvs, ref requires_blinded_error, ref has_recipient_created_payment_secret, } => {
				let mut payment_data_nonref = Clone::clone(payment_data);
				let mut local_payment_data_nonref = crate::lightning::ln::msgs::FinalOnionHopData { inner: if payment_data_nonref.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((payment_data_nonref.unwrap())) } }, is_owned: true };
				let mut payment_preimage_nonref = Clone::clone(payment_preimage);
				let mut payment_metadata_nonref = Clone::clone(payment_metadata);
				let mut local_payment_metadata_nonref = if payment_metadata_nonref.is_none() { crate::c_types::derived::COption_CVec_u8ZZ::None } else { crate::c_types::derived::COption_CVec_u8ZZ::Some( { let mut local_payment_metadata_nonref_0 = Vec::new(); for mut item in payment_metadata_nonref.unwrap().drain(..) { local_payment_metadata_nonref_0.push( { item }); }; local_payment_metadata_nonref_0.into() }) };
				let mut incoming_cltv_expiry_nonref = Clone::clone(incoming_cltv_expiry);
				let mut custom_tlvs_nonref = Clone::clone(custom_tlvs);
				let mut local_custom_tlvs_nonref = Vec::new(); for mut item in custom_tlvs_nonref.drain(..) { local_custom_tlvs_nonref.push( { let (mut orig_custom_tlvs_nonref_0_0, mut orig_custom_tlvs_nonref_0_1) = item; let mut local_orig_custom_tlvs_nonref_0_1 = Vec::new(); for mut item in orig_custom_tlvs_nonref_0_1.drain(..) { local_orig_custom_tlvs_nonref_0_1.push( { item }); }; let mut local_custom_tlvs_nonref_0 = (orig_custom_tlvs_nonref_0_0, local_orig_custom_tlvs_nonref_0_1.into()).into(); local_custom_tlvs_nonref_0 }); };
				let mut requires_blinded_error_nonref = Clone::clone(requires_blinded_error);
				let mut has_recipient_created_payment_secret_nonref = Clone::clone(has_recipient_created_payment_secret);
				PendingHTLCRouting::ReceiveKeysend {
					payment_data: local_payment_data_nonref,
					payment_preimage: crate::c_types::ThirtyTwoBytes { data: payment_preimage_nonref.0 },
					payment_metadata: local_payment_metadata_nonref,
					incoming_cltv_expiry: incoming_cltv_expiry_nonref,
					custom_tlvs: local_custom_tlvs_nonref.into(),
					requires_blinded_error: requires_blinded_error_nonref,
					has_recipient_created_payment_secret: has_recipient_created_payment_secret_nonref,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn native_into(native: nativePendingHTLCRouting) -> Self {
		match native {
			nativePendingHTLCRouting::Forward {mut onion_packet, mut short_channel_id, mut blinded, mut incoming_cltv_expiry, } => {
				let mut local_blinded = crate::lightning::ln::channelmanager::BlindedForward { inner: if blinded.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((blinded.unwrap())) } }, is_owned: true };
				let mut local_incoming_cltv_expiry = if incoming_cltv_expiry.is_none() { crate::c_types::derived::COption_u32Z::None } else { crate::c_types::derived::COption_u32Z::Some( { incoming_cltv_expiry.unwrap() }) };
				PendingHTLCRouting::Forward {
					onion_packet: crate::lightning::ln::msgs::OnionPacket { inner: ObjOps::heap_alloc(onion_packet), is_owned: true },
					short_channel_id: short_channel_id,
					blinded: local_blinded,
					incoming_cltv_expiry: local_incoming_cltv_expiry,
				}
			},
			nativePendingHTLCRouting::Receive {mut payment_data, mut payment_metadata, mut payment_context, mut incoming_cltv_expiry, mut phantom_shared_secret, mut custom_tlvs, mut requires_blinded_error, } => {
				let mut local_payment_metadata = if payment_metadata.is_none() { crate::c_types::derived::COption_CVec_u8ZZ::None } else { crate::c_types::derived::COption_CVec_u8ZZ::Some( { let mut local_payment_metadata_0 = Vec::new(); for mut item in payment_metadata.unwrap().drain(..) { local_payment_metadata_0.push( { item }); }; local_payment_metadata_0.into() }) };
				let mut local_payment_context = if payment_context.is_none() { crate::c_types::derived::COption_PaymentContextZ::None } else { crate::c_types::derived::COption_PaymentContextZ::Some( { crate::lightning::blinded_path::payment::PaymentContext::native_into(payment_context.unwrap()) }) };
				let mut local_phantom_shared_secret = if phantom_shared_secret.is_none() { crate::c_types::ThirtyTwoBytes { data: [0; 32] } } else {  { crate::c_types::ThirtyTwoBytes { data: (phantom_shared_secret.unwrap()) } } };
				let mut local_custom_tlvs = Vec::new(); for mut item in custom_tlvs.drain(..) { local_custom_tlvs.push( { let (mut orig_custom_tlvs_0_0, mut orig_custom_tlvs_0_1) = item; let mut local_orig_custom_tlvs_0_1 = Vec::new(); for mut item in orig_custom_tlvs_0_1.drain(..) { local_orig_custom_tlvs_0_1.push( { item }); }; let mut local_custom_tlvs_0 = (orig_custom_tlvs_0_0, local_orig_custom_tlvs_0_1.into()).into(); local_custom_tlvs_0 }); };
				PendingHTLCRouting::Receive {
					payment_data: crate::lightning::ln::msgs::FinalOnionHopData { inner: ObjOps::heap_alloc(payment_data), is_owned: true },
					payment_metadata: local_payment_metadata,
					payment_context: local_payment_context,
					incoming_cltv_expiry: incoming_cltv_expiry,
					phantom_shared_secret: local_phantom_shared_secret,
					custom_tlvs: local_custom_tlvs.into(),
					requires_blinded_error: requires_blinded_error,
				}
			},
			nativePendingHTLCRouting::ReceiveKeysend {mut payment_data, mut payment_preimage, mut payment_metadata, mut incoming_cltv_expiry, mut custom_tlvs, mut requires_blinded_error, mut has_recipient_created_payment_secret, } => {
				let mut local_payment_data = crate::lightning::ln::msgs::FinalOnionHopData { inner: if payment_data.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((payment_data.unwrap())) } }, is_owned: true };
				let mut local_payment_metadata = if payment_metadata.is_none() { crate::c_types::derived::COption_CVec_u8ZZ::None } else { crate::c_types::derived::COption_CVec_u8ZZ::Some( { let mut local_payment_metadata_0 = Vec::new(); for mut item in payment_metadata.unwrap().drain(..) { local_payment_metadata_0.push( { item }); }; local_payment_metadata_0.into() }) };
				let mut local_custom_tlvs = Vec::new(); for mut item in custom_tlvs.drain(..) { local_custom_tlvs.push( { let (mut orig_custom_tlvs_0_0, mut orig_custom_tlvs_0_1) = item; let mut local_orig_custom_tlvs_0_1 = Vec::new(); for mut item in orig_custom_tlvs_0_1.drain(..) { local_orig_custom_tlvs_0_1.push( { item }); }; let mut local_custom_tlvs_0 = (orig_custom_tlvs_0_0, local_orig_custom_tlvs_0_1.into()).into(); local_custom_tlvs_0 }); };
				PendingHTLCRouting::ReceiveKeysend {
					payment_data: local_payment_data,
					payment_preimage: crate::c_types::ThirtyTwoBytes { data: payment_preimage.0 },
					payment_metadata: local_payment_metadata,
					incoming_cltv_expiry: incoming_cltv_expiry,
					custom_tlvs: local_custom_tlvs.into(),
					requires_blinded_error: requires_blinded_error,
					has_recipient_created_payment_secret: has_recipient_created_payment_secret,
				}
			},
		}
	}
}
/// Frees any resources used by the PendingHTLCRouting
#[no_mangle]
pub extern "C" fn PendingHTLCRouting_free(this_ptr: PendingHTLCRouting) { }
/// Creates a copy of the PendingHTLCRouting
#[no_mangle]
pub extern "C" fn PendingHTLCRouting_clone(orig: &PendingHTLCRouting) -> PendingHTLCRouting {
	orig.clone()
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PendingHTLCRouting_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const PendingHTLCRouting)).clone() })) as *mut c_void
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PendingHTLCRouting_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut PendingHTLCRouting) };
}
#[no_mangle]
/// Utility method to constructs a new Forward-variant PendingHTLCRouting
pub extern "C" fn PendingHTLCRouting_forward(onion_packet: crate::lightning::ln::msgs::OnionPacket, short_channel_id: u64, blinded: crate::lightning::ln::channelmanager::BlindedForward, incoming_cltv_expiry: crate::c_types::derived::COption_u32Z) -> PendingHTLCRouting {
	PendingHTLCRouting::Forward {
		onion_packet,
		short_channel_id,
		blinded,
		incoming_cltv_expiry,
	}
}
#[no_mangle]
/// Utility method to constructs a new Receive-variant PendingHTLCRouting
pub extern "C" fn PendingHTLCRouting_receive(payment_data: crate::lightning::ln::msgs::FinalOnionHopData, payment_metadata: crate::c_types::derived::COption_CVec_u8ZZ, payment_context: crate::c_types::derived::COption_PaymentContextZ, incoming_cltv_expiry: u32, phantom_shared_secret: crate::c_types::ThirtyTwoBytes, custom_tlvs: crate::c_types::derived::CVec_C2Tuple_u64CVec_u8ZZZ, requires_blinded_error: bool) -> PendingHTLCRouting {
	PendingHTLCRouting::Receive {
		payment_data,
		payment_metadata,
		payment_context,
		incoming_cltv_expiry,
		phantom_shared_secret,
		custom_tlvs,
		requires_blinded_error,
	}
}
#[no_mangle]
/// Utility method to constructs a new ReceiveKeysend-variant PendingHTLCRouting
pub extern "C" fn PendingHTLCRouting_receive_keysend(payment_data: crate::lightning::ln::msgs::FinalOnionHopData, payment_preimage: crate::c_types::ThirtyTwoBytes, payment_metadata: crate::c_types::derived::COption_CVec_u8ZZ, incoming_cltv_expiry: u32, custom_tlvs: crate::c_types::derived::CVec_C2Tuple_u64CVec_u8ZZZ, requires_blinded_error: bool, has_recipient_created_payment_secret: bool) -> PendingHTLCRouting {
	PendingHTLCRouting::ReceiveKeysend {
		payment_data,
		payment_preimage,
		payment_metadata,
		incoming_cltv_expiry,
		custom_tlvs,
		requires_blinded_error,
		has_recipient_created_payment_secret,
	}
}

use lightning::ln::channelmanager::BlindedForward as nativeBlindedForwardImport;
pub(crate) type nativeBlindedForward = nativeBlindedForwardImport;

/// Information used to forward or fail this HTLC that is being forwarded within a blinded path.
#[must_use]
#[repr(C)]
pub struct BlindedForward {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeBlindedForward,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for BlindedForward {
	type Target = nativeBlindedForward;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for BlindedForward { }
unsafe impl core::marker::Sync for BlindedForward { }
impl Drop for BlindedForward {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeBlindedForward>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the BlindedForward, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn BlindedForward_free(this_obj: BlindedForward) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn BlindedForward_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeBlindedForward) };
}
#[allow(unused)]
impl BlindedForward {
	pub(crate) fn get_native_ref(&self) -> &'static nativeBlindedForward {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeBlindedForward {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeBlindedForward {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// The `blinding_point` that was set in the inbound [`msgs::UpdateAddHTLC`], or in the inbound
/// onion payload if we're the introduction node. Useful for calculating the next hop's
/// [`msgs::UpdateAddHTLC::blinding_point`].
#[no_mangle]
pub extern "C" fn BlindedForward_get_inbound_blinding_point(this_ptr: &BlindedForward) -> crate::c_types::PublicKey {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().inbound_blinding_point;
	crate::c_types::PublicKey::from_rust(&inner_val)
}
/// The `blinding_point` that was set in the inbound [`msgs::UpdateAddHTLC`], or in the inbound
/// onion payload if we're the introduction node. Useful for calculating the next hop's
/// [`msgs::UpdateAddHTLC::blinding_point`].
#[no_mangle]
pub extern "C" fn BlindedForward_set_inbound_blinding_point(this_ptr: &mut BlindedForward, mut val: crate::c_types::PublicKey) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.inbound_blinding_point = val.into_rust();
}
/// If needed, this determines how this HTLC should be failed backwards, based on whether we are
/// the introduction node.
#[no_mangle]
pub extern "C" fn BlindedForward_get_failure(this_ptr: &BlindedForward) -> crate::lightning::ln::channelmanager::BlindedFailure {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().failure;
	crate::lightning::ln::channelmanager::BlindedFailure::from_native(inner_val)
}
/// If needed, this determines how this HTLC should be failed backwards, based on whether we are
/// the introduction node.
#[no_mangle]
pub extern "C" fn BlindedForward_set_failure(this_ptr: &mut BlindedForward, mut val: crate::lightning::ln::channelmanager::BlindedFailure) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.failure = val.into_native();
}
/// Overrides the next hop's [`msgs::UpdateAddHTLC::blinding_point`]. Set if this HTLC is being
/// forwarded within a [`BlindedPaymentPath`] that was concatenated to another blinded path that
/// starts at the next hop.
///
/// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
#[no_mangle]
pub extern "C" fn BlindedForward_get_next_blinding_override(this_ptr: &BlindedForward) -> crate::c_types::PublicKey {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().next_blinding_override;
	let mut local_inner_val = if inner_val.is_none() { crate::c_types::PublicKey::null() } else {  { crate::c_types::PublicKey::from_rust(&(inner_val.unwrap())) } };
	local_inner_val
}
/// Overrides the next hop's [`msgs::UpdateAddHTLC::blinding_point`]. Set if this HTLC is being
/// forwarded within a [`BlindedPaymentPath`] that was concatenated to another blinded path that
/// starts at the next hop.
///
/// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
#[no_mangle]
pub extern "C" fn BlindedForward_set_next_blinding_override(this_ptr: &mut BlindedForward, mut val: crate::c_types::PublicKey) {
	let mut local_val = if val.is_null() { None } else { Some( { val.into_rust() }) };
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.next_blinding_override = local_val;
}
/// Constructs a new BlindedForward given each field
///
/// Note that next_blinding_override_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
#[must_use]
#[no_mangle]
pub extern "C" fn BlindedForward_new(mut inbound_blinding_point_arg: crate::c_types::PublicKey, mut failure_arg: crate::lightning::ln::channelmanager::BlindedFailure, mut next_blinding_override_arg: crate::c_types::PublicKey) -> BlindedForward {
	let mut local_next_blinding_override_arg = if next_blinding_override_arg.is_null() { None } else { Some( { next_blinding_override_arg.into_rust() }) };
	BlindedForward { inner: ObjOps::heap_alloc(nativeBlindedForward {
		inbound_blinding_point: inbound_blinding_point_arg.into_rust(),
		failure: failure_arg.into_native(),
		next_blinding_override: local_next_blinding_override_arg,
	}), is_owned: true }
}
impl Clone for BlindedForward {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativeBlindedForward>::is_null(self.inner) { core::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn BlindedForward_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const nativeBlindedForward)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the BlindedForward
pub extern "C" fn BlindedForward_clone(orig: &BlindedForward) -> BlindedForward {
	orig.clone()
}
/// Get a string which allows debug introspection of a BlindedForward object
pub extern "C" fn BlindedForward_debug_str_void(o: *const c_void) -> Str {
	alloc::format!("{:?}", unsafe { o as *const crate::lightning::ln::channelmanager::BlindedForward }).into()}
/// Generates a non-cryptographic 64-bit hash of the BlindedForward.
#[no_mangle]
pub extern "C" fn BlindedForward_hash(o: &BlindedForward) -> u64 {
	if o.inner.is_null() { return 0; }
	// Note that we'd love to use alloc::collections::hash_map::DefaultHasher but it's not in core
	#[allow(deprecated)]
	let mut hasher = core::hash::SipHasher::new();
	core::hash::Hash::hash(o.get_native_ref(), &mut hasher);
	core::hash::Hasher::finish(&hasher)
}
/// Checks if two BlindedForwards contain equal inner contents.
/// This ignores pointers and is_owned flags and looks at the values in fields.
/// Two objects with NULL inner values will be considered "equal" here.
#[no_mangle]
pub extern "C" fn BlindedForward_eq(a: &BlindedForward, b: &BlindedForward) -> bool {
	if a.inner == b.inner { return true; }
	if a.inner.is_null() || b.inner.is_null() { return false; }
	if a.get_native_ref() == b.get_native_ref() { true } else { false }
}

use lightning::ln::channelmanager::PendingHTLCInfo as nativePendingHTLCInfoImport;
pub(crate) type nativePendingHTLCInfo = nativePendingHTLCInfoImport;

/// Information about an incoming HTLC, including the [`PendingHTLCRouting`] describing where it
/// should go next.
#[must_use]
#[repr(C)]
pub struct PendingHTLCInfo {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativePendingHTLCInfo,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for PendingHTLCInfo {
	type Target = nativePendingHTLCInfo;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for PendingHTLCInfo { }
unsafe impl core::marker::Sync for PendingHTLCInfo { }
impl Drop for PendingHTLCInfo {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativePendingHTLCInfo>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the PendingHTLCInfo, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_free(this_obj: PendingHTLCInfo) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PendingHTLCInfo_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativePendingHTLCInfo) };
}
#[allow(unused)]
impl PendingHTLCInfo {
	pub(crate) fn get_native_ref(&self) -> &'static nativePendingHTLCInfo {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativePendingHTLCInfo {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativePendingHTLCInfo {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// Further routing details based on whether the HTLC is being forwarded or received.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_get_routing(this_ptr: &PendingHTLCInfo) -> crate::lightning::ln::channelmanager::PendingHTLCRouting {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().routing;
	crate::lightning::ln::channelmanager::PendingHTLCRouting::from_native(inner_val)
}
/// Further routing details based on whether the HTLC is being forwarded or received.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_set_routing(this_ptr: &mut PendingHTLCInfo, mut val: crate::lightning::ln::channelmanager::PendingHTLCRouting) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.routing = val.into_native();
}
/// The onion shared secret we build with the sender used to decrypt the onion.
///
/// This is later used to encrypt failure packets in the event that the HTLC is failed.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_get_incoming_shared_secret(this_ptr: &PendingHTLCInfo) -> *const [u8; 32] {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().incoming_shared_secret;
	inner_val
}
/// The onion shared secret we build with the sender used to decrypt the onion.
///
/// This is later used to encrypt failure packets in the event that the HTLC is failed.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_set_incoming_shared_secret(this_ptr: &mut PendingHTLCInfo, mut val: crate::c_types::ThirtyTwoBytes) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.incoming_shared_secret = val.data;
}
/// Hash of the payment preimage, to lock the payment until the receiver releases the preimage.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_get_payment_hash(this_ptr: &PendingHTLCInfo) -> *const [u8; 32] {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().payment_hash;
	&inner_val.0
}
/// Hash of the payment preimage, to lock the payment until the receiver releases the preimage.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_set_payment_hash(this_ptr: &mut PendingHTLCInfo, mut val: crate::c_types::ThirtyTwoBytes) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.payment_hash = ::lightning::types::payment::PaymentHash(val.data);
}
/// Amount received in the incoming HTLC.
///
/// This field was added in LDK 0.0.113 and will be `None` for objects written by prior
/// versions.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_get_incoming_amt_msat(this_ptr: &PendingHTLCInfo) -> crate::c_types::derived::COption_u64Z {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().incoming_amt_msat;
	let mut local_inner_val = if inner_val.is_none() { crate::c_types::derived::COption_u64Z::None } else { crate::c_types::derived::COption_u64Z::Some( { inner_val.unwrap() }) };
	local_inner_val
}
/// Amount received in the incoming HTLC.
///
/// This field was added in LDK 0.0.113 and will be `None` for objects written by prior
/// versions.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_set_incoming_amt_msat(this_ptr: &mut PendingHTLCInfo, mut val: crate::c_types::derived::COption_u64Z) {
	let mut local_val = if val.is_some() { Some( { val.take() }) } else { None };
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.incoming_amt_msat = local_val;
}
/// The amount the sender indicated should be forwarded on to the next hop or amount the sender
/// intended for us to receive for received payments.
///
/// If the received amount is less than this for received payments, an intermediary hop has
/// attempted to steal some of our funds and we should fail the HTLC (the sender should retry
/// it along another path).
///
/// Because nodes can take less than their required fees, and because senders may wish to
/// improve their own privacy, this amount may be less than [`Self::incoming_amt_msat`] for
/// received payments. In such cases, recipients must handle this HTLC as if it had received
/// [`Self::outgoing_amt_msat`].
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_get_outgoing_amt_msat(this_ptr: &PendingHTLCInfo) -> u64 {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().outgoing_amt_msat;
	*inner_val
}
/// The amount the sender indicated should be forwarded on to the next hop or amount the sender
/// intended for us to receive for received payments.
///
/// If the received amount is less than this for received payments, an intermediary hop has
/// attempted to steal some of our funds and we should fail the HTLC (the sender should retry
/// it along another path).
///
/// Because nodes can take less than their required fees, and because senders may wish to
/// improve their own privacy, this amount may be less than [`Self::incoming_amt_msat`] for
/// received payments. In such cases, recipients must handle this HTLC as if it had received
/// [`Self::outgoing_amt_msat`].
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_set_outgoing_amt_msat(this_ptr: &mut PendingHTLCInfo, mut val: u64) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.outgoing_amt_msat = val;
}
/// The CLTV the sender has indicated we should set on the forwarded HTLC (or has indicated
/// should have been set on the received HTLC for received payments).
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_get_outgoing_cltv_value(this_ptr: &PendingHTLCInfo) -> u32 {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().outgoing_cltv_value;
	*inner_val
}
/// The CLTV the sender has indicated we should set on the forwarded HTLC (or has indicated
/// should have been set on the received HTLC for received payments).
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_set_outgoing_cltv_value(this_ptr: &mut PendingHTLCInfo, mut val: u32) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.outgoing_cltv_value = val;
}
/// The fee taken for this HTLC in addition to the standard protocol HTLC fees.
///
/// If this is a payment for forwarding, this is the fee we are taking before forwarding the
/// HTLC.
///
/// If this is a received payment, this is the fee that our counterparty took.
///
/// This is used to allow LSPs to take fees as a part of payments, without the sender having to
/// shoulder them.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_get_skimmed_fee_msat(this_ptr: &PendingHTLCInfo) -> crate::c_types::derived::COption_u64Z {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().skimmed_fee_msat;
	let mut local_inner_val = if inner_val.is_none() { crate::c_types::derived::COption_u64Z::None } else { crate::c_types::derived::COption_u64Z::Some( { inner_val.unwrap() }) };
	local_inner_val
}
/// The fee taken for this HTLC in addition to the standard protocol HTLC fees.
///
/// If this is a payment for forwarding, this is the fee we are taking before forwarding the
/// HTLC.
///
/// If this is a received payment, this is the fee that our counterparty took.
///
/// This is used to allow LSPs to take fees as a part of payments, without the sender having to
/// shoulder them.
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_set_skimmed_fee_msat(this_ptr: &mut PendingHTLCInfo, mut val: crate::c_types::derived::COption_u64Z) {
	let mut local_val = if val.is_some() { Some( { val.take() }) } else { None };
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.skimmed_fee_msat = local_val;
}
/// Constructs a new PendingHTLCInfo given each field
#[must_use]
#[no_mangle]
pub extern "C" fn PendingHTLCInfo_new(mut routing_arg: crate::lightning::ln::channelmanager::PendingHTLCRouting, mut incoming_shared_secret_arg: crate::c_types::ThirtyTwoBytes, mut payment_hash_arg: crate::c_types::ThirtyTwoBytes, mut incoming_amt_msat_arg: crate::c_types::derived::COption_u64Z, mut outgoing_amt_msat_arg: u64, mut outgoing_cltv_value_arg: u32, mut skimmed_fee_msat_arg: crate::c_types::derived::COption_u64Z) -> PendingHTLCInfo {
	let mut local_incoming_amt_msat_arg = if incoming_amt_msat_arg.is_some() { Some( { incoming_amt_msat_arg.take() }) } else { None };
	let mut local_skimmed_fee_msat_arg = if skimmed_fee_msat_arg.is_some() { Some( { skimmed_fee_msat_arg.take() }) } else { None };
	PendingHTLCInfo { inner: ObjOps::heap_alloc(nativePendingHTLCInfo {
		routing: routing_arg.into_native(),
		incoming_shared_secret: incoming_shared_secret_arg.data,
		payment_hash: ::lightning::types::payment::PaymentHash(payment_hash_arg.data),
		incoming_amt_msat: local_incoming_amt_msat_arg,
		outgoing_amt_msat: outgoing_amt_msat_arg,
		outgoing_cltv_value: outgoing_cltv_value_arg,
		skimmed_fee_msat: local_skimmed_fee_msat_arg,
	}), is_owned: true }
}
impl Clone for PendingHTLCInfo {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativePendingHTLCInfo>::is_null(self.inner) { core::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PendingHTLCInfo_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const nativePendingHTLCInfo)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the PendingHTLCInfo
pub extern "C" fn PendingHTLCInfo_clone(orig: &PendingHTLCInfo) -> PendingHTLCInfo {
	orig.clone()
}
/// Whether this blinded HTLC is being failed backwards by the introduction node or a blinded node,
/// which determines the failure message that should be used.
#[derive(Clone)]
#[must_use]
#[repr(C)]
pub enum BlindedFailure {
	/// This HTLC is being failed backwards by the introduction node, and thus should be failed with
	/// [`msgs::UpdateFailHTLC`] and error code `0x8000|0x4000|24`.
	FromIntroductionNode,
	/// This HTLC is being failed backwards by a blinded node within the path, and thus should be
	/// failed with [`msgs::UpdateFailMalformedHTLC`] and error code `0x8000|0x4000|24`.
	FromBlindedNode,
}
use lightning::ln::channelmanager::BlindedFailure as BlindedFailureImport;
pub(crate) type nativeBlindedFailure = BlindedFailureImport;

impl BlindedFailure {
	#[allow(unused)]
	pub(crate) fn to_native(&self) -> nativeBlindedFailure {
		match self {
			BlindedFailure::FromIntroductionNode => nativeBlindedFailure::FromIntroductionNode,
			BlindedFailure::FromBlindedNode => nativeBlindedFailure::FromBlindedNode,
		}
	}
	#[allow(unused)]
	pub(crate) fn into_native(self) -> nativeBlindedFailure {
		match self {
			BlindedFailure::FromIntroductionNode => nativeBlindedFailure::FromIntroductionNode,
			BlindedFailure::FromBlindedNode => nativeBlindedFailure::FromBlindedNode,
		}
	}
	#[allow(unused)]
	pub(crate) fn from_native(native: &BlindedFailureImport) -> Self {
		let native = unsafe { &*(native as *const _ as *const c_void as *const nativeBlindedFailure) };
		match native {
			nativeBlindedFailure::FromIntroductionNode => BlindedFailure::FromIntroductionNode,
			nativeBlindedFailure::FromBlindedNode => BlindedFailure::FromBlindedNode,
		}
	}
	#[allow(unused)]
	pub(crate) fn native_into(native: nativeBlindedFailure) -> Self {
		match native {
			nativeBlindedFailure::FromIntroductionNode => BlindedFailure::FromIntroductionNode,
			nativeBlindedFailure::FromBlindedNode => BlindedFailure::FromBlindedNode,
		}
	}
}
/// Creates a copy of the BlindedFailure
#[no_mangle]
pub extern "C" fn BlindedFailure_clone(orig: &BlindedFailure) -> BlindedFailure {
	orig.clone()
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn BlindedFailure_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const BlindedFailure)).clone() })) as *mut c_void
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn BlindedFailure_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut BlindedFailure) };
}
#[no_mangle]
/// Utility method to constructs a new FromIntroductionNode-variant BlindedFailure
pub extern "C" fn BlindedFailure_from_introduction_node() -> BlindedFailure {
	BlindedFailure::FromIntroductionNode}
#[no_mangle]
/// Utility method to constructs a new FromBlindedNode-variant BlindedFailure
pub extern "C" fn BlindedFailure_from_blinded_node() -> BlindedFailure {
	BlindedFailure::FromBlindedNode}
/// Get a string which allows debug introspection of a BlindedFailure object
pub extern "C" fn BlindedFailure_debug_str_void(o: *const c_void) -> Str {
	alloc::format!("{:?}", unsafe { o as *const crate::lightning::ln::channelmanager::BlindedFailure }).into()}
/// Generates a non-cryptographic 64-bit hash of the BlindedFailure.
#[no_mangle]
pub extern "C" fn BlindedFailure_hash(o: &BlindedFailure) -> u64 {
	// Note that we'd love to use alloc::collections::hash_map::DefaultHasher but it's not in core
	#[allow(deprecated)]
	let mut hasher = core::hash::SipHasher::new();
	core::hash::Hash::hash(&o.to_native(), &mut hasher);
	core::hash::Hasher::finish(&hasher)
}
/// Checks if two BlindedFailures contain equal inner contents.
/// This ignores pointers and is_owned flags and looks at the values in fields.
#[no_mangle]
pub extern "C" fn BlindedFailure_eq(a: &BlindedFailure, b: &BlindedFailure) -> bool {
	if &a.to_native() == &b.to_native() { true } else { false }
}
/// A trait defining behavior for creating and verifing the HMAC for authenticating a given data.
#[repr(C)]
pub struct Verification {
	/// An opaque pointer which is passed to your function implementations as an argument.
	/// This has no meaning in the LDK, and can be NULL or any other value.
	pub this_arg: *mut c_void,
	/// Constructs an HMAC to include in [`OffersContext`] for the data along with the given
	/// [`Nonce`].
	pub hmac_for_offer_payment: extern "C" fn (this_arg: *const c_void, nonce: crate::lightning::offers::nonce::Nonce, expanded_key: &crate::lightning::ln::inbound_payment::ExpandedKey) -> crate::c_types::ThirtyTwoBytes,
	/// Authenticates the data using an HMAC and a [`Nonce`] taken from an [`OffersContext`].
	pub verify_for_offer_payment: extern "C" fn (this_arg: *const c_void, hmac: crate::c_types::ThirtyTwoBytes, nonce: crate::lightning::offers::nonce::Nonce, expanded_key: &crate::lightning::ln::inbound_payment::ExpandedKey) -> crate::c_types::derived::CResult_NoneNoneZ,
	/// Frees any resources associated with this object given its this_arg pointer.
	/// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
	pub free: Option<extern "C" fn(this_arg: *mut c_void)>,
}
unsafe impl Send for Verification {}
unsafe impl Sync for Verification {}
#[allow(unused)]
pub(crate) fn Verification_clone_fields(orig: &Verification) -> Verification {
	Verification {
		this_arg: orig.this_arg,
		hmac_for_offer_payment: Clone::clone(&orig.hmac_for_offer_payment),
		verify_for_offer_payment: Clone::clone(&orig.verify_for_offer_payment),
		free: Clone::clone(&orig.free),
	}
}

use lightning::ln::channelmanager::Verification as rustVerification;
impl rustVerification for Verification {
	fn hmac_for_offer_payment(&self, mut nonce: lightning::offers::nonce::Nonce, mut expanded_key: &lightning::ln::inbound_payment::ExpandedKey) -> [u8; 32] {
		let mut ret = (self.hmac_for_offer_payment)(self.this_arg, crate::lightning::offers::nonce::Nonce { inner: ObjOps::heap_alloc(nonce), is_owned: true }, &crate::lightning::ln::inbound_payment::ExpandedKey { inner: unsafe { ObjOps::nonnull_ptr_to_inner((expanded_key as *const lightning::ln::inbound_payment::ExpandedKey<>) as *mut _) }, is_owned: false });
		ret.data
	}
	fn verify_for_offer_payment(&self, mut hmac: [u8; 32], mut nonce: lightning::offers::nonce::Nonce, mut expanded_key: &lightning::ln::inbound_payment::ExpandedKey) -> Result<(), ()> {
		let mut ret = (self.verify_for_offer_payment)(self.this_arg, crate::c_types::ThirtyTwoBytes { data: hmac }, crate::lightning::offers::nonce::Nonce { inner: ObjOps::heap_alloc(nonce), is_owned: true }, &crate::lightning::ln::inbound_payment::ExpandedKey { inner: unsafe { ObjOps::nonnull_ptr_to_inner((expanded_key as *const lightning::ln::inbound_payment::ExpandedKey<>) as *mut _) }, is_owned: false });
		let mut local_ret = match ret.result_ok { true => Ok( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) })*/ }), false => Err( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.err)) })*/ })};
		local_ret
	}
}

pub struct VerificationRef(Verification);
impl rustVerification for VerificationRef {
	fn hmac_for_offer_payment(&self, mut nonce: lightning::offers::nonce::Nonce, mut expanded_key: &lightning::ln::inbound_payment::ExpandedKey) -> [u8; 32] {
		let mut ret = (self.0.hmac_for_offer_payment)(self.0.this_arg, crate::lightning::offers::nonce::Nonce { inner: ObjOps::heap_alloc(nonce), is_owned: true }, &crate::lightning::ln::inbound_payment::ExpandedKey { inner: unsafe { ObjOps::nonnull_ptr_to_inner((expanded_key as *const lightning::ln::inbound_payment::ExpandedKey<>) as *mut _) }, is_owned: false });
		ret.data
	}
	fn verify_for_offer_payment(&self, mut hmac: [u8; 32], mut nonce: lightning::offers::nonce::Nonce, mut expanded_key: &lightning::ln::inbound_payment::ExpandedKey) -> Result<(), ()> {
		let mut ret = (self.0.verify_for_offer_payment)(self.0.this_arg, crate::c_types::ThirtyTwoBytes { data: hmac }, crate::lightning::offers::nonce::Nonce { inner: ObjOps::heap_alloc(nonce), is_owned: true }, &crate::lightning::ln::inbound_payment::ExpandedKey { inner: unsafe { ObjOps::nonnull_ptr_to_inner((expanded_key as *const lightning::ln::inbound_payment::ExpandedKey<>) as *mut _) }, is_owned: false });
		let mut local_ret = match ret.result_ok { true => Ok( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) })*/ }), false => Err( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.err)) })*/ })};
		local_ret
	}
}

// We're essentially a pointer already, or at least a set of pointers, so allow us to be used
// directly as a Deref trait in higher-level structs:
impl core::ops::Deref for Verification {
	type Target = VerificationRef;
	fn deref(&self) -> &Self::Target {
		unsafe { &*(self as *const _ as *const VerificationRef) }
	}
}
impl core::ops::DerefMut for Verification {
	fn deref_mut(&mut self) -> &mut VerificationRef {
		unsafe { &mut *(self as *mut _ as *mut VerificationRef) }
	}
}
/// Calls the free function if one is set
#[no_mangle]
pub extern "C" fn Verification_free(this_ptr: Verification) { }
impl Drop for Verification {
	fn drop(&mut self) {
		if let Some(f) = self.free {
			f(self.this_arg);
		}
	}
}
impl From<nativeUnauthenticatedReceiveTlvs> for crate::lightning::ln::channelmanager::Verification {
	fn from(obj: nativeUnauthenticatedReceiveTlvs) -> Self {
		let rust_obj = crate::lightning::blinded_path::payment::UnauthenticatedReceiveTlvs { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = UnauthenticatedReceiveTlvs_as_Verification(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(UnauthenticatedReceiveTlvs_free_void);
		ret
	}
}
/// Constructs a new Verification which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned Verification must be freed before this_arg is
#[no_mangle]
pub extern "C" fn UnauthenticatedReceiveTlvs_as_Verification(this_arg: &UnauthenticatedReceiveTlvs) -> crate::lightning::ln::channelmanager::Verification {
	crate::lightning::ln::channelmanager::Verification {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		hmac_for_offer_payment: UnauthenticatedReceiveTlvs_Verification_hmac_for_offer_payment,
		verify_for_offer_payment: UnauthenticatedReceiveTlvs_Verification_verify_for_offer_payment,
	}
}

#[must_use]
extern "C" fn UnauthenticatedReceiveTlvs_Verification_hmac_for_offer_payment(this_arg: *const c_void, mut nonce: crate::lightning::offers::nonce::Nonce, expanded_key: &crate::lightning::ln::inbound_payment::ExpandedKey) -> crate::c_types::ThirtyTwoBytes {
	let mut ret = <nativeUnauthenticatedReceiveTlvs as lightning::ln::channelmanager::Verification>::hmac_for_offer_payment(unsafe { &mut *(this_arg as *mut nativeUnauthenticatedReceiveTlvs) }, *unsafe { Box::from_raw(nonce.take_inner()) }, expanded_key.get_native_ref());
	crate::c_types::ThirtyTwoBytes { data: ret }
}
#[must_use]
extern "C" fn UnauthenticatedReceiveTlvs_Verification_verify_for_offer_payment(this_arg: *const c_void, mut hmac: crate::c_types::ThirtyTwoBytes, mut nonce: crate::lightning::offers::nonce::Nonce, expanded_key: &crate::lightning::ln::inbound_payment::ExpandedKey) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut ret = <nativeUnauthenticatedReceiveTlvs as lightning::ln::channelmanager::Verification>::verify_for_offer_payment(unsafe { &mut *(this_arg as *mut nativeUnauthenticatedReceiveTlvs) }, hmac.data, *unsafe { Box::from_raw(nonce.take_inner()) }, expanded_key.get_native_ref());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}

/// This enum is used to specify which error data to send to peers when failing back an HTLC
/// using [`ChannelManager::fail_htlc_backwards_with_reason`].
///
/// For more info on failure codes, see <https://github.com/lightning/bolts/blob/master/04-onion-routing.md#failure-messages>.
#[derive(Clone)]
#[must_use]
#[repr(C)]
pub enum FailureCode {
	/// We had a temporary error processing the payment. Useful if no other error codes fit
	/// and you want to indicate that the payer may want to retry.
	TemporaryNodeFailure,
	/// We have a required feature which was not in this onion. For example, you may require
	/// some additional metadata that was not provided with this payment.
	RequiredNodeFeatureMissing,
	/// You may wish to use this when a `payment_preimage` is unknown, or the CLTV expiry of
	/// the HTLC is too close to the current block height for safe handling.
	/// Using this failure code in [`ChannelManager::fail_htlc_backwards_with_reason`] is
	/// equivalent to calling [`ChannelManager::fail_htlc_backwards`].
	IncorrectOrUnknownPaymentDetails,
	/// We failed to process the payload after the onion was decrypted. You may wish to
	/// use this when receiving custom HTLC TLVs with even type numbers that you don't recognize.
	///
	/// If available, the tuple data may include the type number and byte offset in the
	/// decrypted byte stream where the failure occurred.
	InvalidOnionPayload(
		crate::c_types::derived::COption_C2Tuple_u64u16ZZ),
}
use lightning::ln::channelmanager::FailureCode as FailureCodeImport;
pub(crate) type nativeFailureCode = FailureCodeImport;

impl FailureCode {
	#[allow(unused)]
	pub(crate) fn to_native(&self) -> nativeFailureCode {
		match self {
			FailureCode::TemporaryNodeFailure => nativeFailureCode::TemporaryNodeFailure,
			FailureCode::RequiredNodeFeatureMissing => nativeFailureCode::RequiredNodeFeatureMissing,
			FailureCode::IncorrectOrUnknownPaymentDetails => nativeFailureCode::IncorrectOrUnknownPaymentDetails,
			FailureCode::InvalidOnionPayload (ref a, ) => {
				let mut a_nonref = Clone::clone(a);
				let mut local_a_nonref = if a_nonref.is_some() { Some( { let (mut orig_a_nonref_0_0, mut orig_a_nonref_0_1) = a_nonref.take().to_rust(); let mut local_a_nonref_0 = (orig_a_nonref_0_0, orig_a_nonref_0_1); local_a_nonref_0 }) } else { None };
				nativeFailureCode::InvalidOnionPayload (
					local_a_nonref,
				)
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn into_native(self) -> nativeFailureCode {
		match self {
			FailureCode::TemporaryNodeFailure => nativeFailureCode::TemporaryNodeFailure,
			FailureCode::RequiredNodeFeatureMissing => nativeFailureCode::RequiredNodeFeatureMissing,
			FailureCode::IncorrectOrUnknownPaymentDetails => nativeFailureCode::IncorrectOrUnknownPaymentDetails,
			FailureCode::InvalidOnionPayload (mut a, ) => {
				let mut local_a = if a.is_some() { Some( { let (mut orig_a_0_0, mut orig_a_0_1) = a.take().to_rust(); let mut local_a_0 = (orig_a_0_0, orig_a_0_1); local_a_0 }) } else { None };
				nativeFailureCode::InvalidOnionPayload (
					local_a,
				)
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn from_native(native: &FailureCodeImport) -> Self {
		let native = unsafe { &*(native as *const _ as *const c_void as *const nativeFailureCode) };
		match native {
			nativeFailureCode::TemporaryNodeFailure => FailureCode::TemporaryNodeFailure,
			nativeFailureCode::RequiredNodeFeatureMissing => FailureCode::RequiredNodeFeatureMissing,
			nativeFailureCode::IncorrectOrUnknownPaymentDetails => FailureCode::IncorrectOrUnknownPaymentDetails,
			nativeFailureCode::InvalidOnionPayload (ref a, ) => {
				let mut a_nonref = Clone::clone(a);
				let mut local_a_nonref = if a_nonref.is_none() { crate::c_types::derived::COption_C2Tuple_u64u16ZZ::None } else { crate::c_types::derived::COption_C2Tuple_u64u16ZZ::Some( { let (mut orig_a_nonref_0_0, mut orig_a_nonref_0_1) = (a_nonref.unwrap()); let mut local_a_nonref_0 = (orig_a_nonref_0_0, orig_a_nonref_0_1).into(); local_a_nonref_0 }) };
				FailureCode::InvalidOnionPayload (
					local_a_nonref,
				)
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn native_into(native: nativeFailureCode) -> Self {
		match native {
			nativeFailureCode::TemporaryNodeFailure => FailureCode::TemporaryNodeFailure,
			nativeFailureCode::RequiredNodeFeatureMissing => FailureCode::RequiredNodeFeatureMissing,
			nativeFailureCode::IncorrectOrUnknownPaymentDetails => FailureCode::IncorrectOrUnknownPaymentDetails,
			nativeFailureCode::InvalidOnionPayload (mut a, ) => {
				let mut local_a = if a.is_none() { crate::c_types::derived::COption_C2Tuple_u64u16ZZ::None } else { crate::c_types::derived::COption_C2Tuple_u64u16ZZ::Some( { let (mut orig_a_0_0, mut orig_a_0_1) = (a.unwrap()); let mut local_a_0 = (orig_a_0_0, orig_a_0_1).into(); local_a_0 }) };
				FailureCode::InvalidOnionPayload (
					local_a,
				)
			},
		}
	}
}
/// Frees any resources used by the FailureCode
#[no_mangle]
pub extern "C" fn FailureCode_free(this_ptr: FailureCode) { }
/// Creates a copy of the FailureCode
#[no_mangle]
pub extern "C" fn FailureCode_clone(orig: &FailureCode) -> FailureCode {
	orig.clone()
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn FailureCode_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const FailureCode)).clone() })) as *mut c_void
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn FailureCode_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut FailureCode) };
}
#[no_mangle]
/// Utility method to constructs a new TemporaryNodeFailure-variant FailureCode
pub extern "C" fn FailureCode_temporary_node_failure() -> FailureCode {
	FailureCode::TemporaryNodeFailure}
#[no_mangle]
/// Utility method to constructs a new RequiredNodeFeatureMissing-variant FailureCode
pub extern "C" fn FailureCode_required_node_feature_missing() -> FailureCode {
	FailureCode::RequiredNodeFeatureMissing}
#[no_mangle]
/// Utility method to constructs a new IncorrectOrUnknownPaymentDetails-variant FailureCode
pub extern "C" fn FailureCode_incorrect_or_unknown_payment_details() -> FailureCode {
	FailureCode::IncorrectOrUnknownPaymentDetails}
#[no_mangle]
/// Utility method to constructs a new InvalidOnionPayload-variant FailureCode
pub extern "C" fn FailureCode_invalid_onion_payload(a: crate::c_types::derived::COption_C2Tuple_u64u16ZZ) -> FailureCode {
	FailureCode::InvalidOnionPayload(a, )
}

use lightning::ln::channelmanager::ChannelManager as nativeChannelManagerImport;
pub(crate) type nativeChannelManager = nativeChannelManagerImport<crate::lightning::chain::Watch, crate::lightning::chain::chaininterface::BroadcasterInterface, crate::lightning::sign::EntropySource, crate::lightning::sign::NodeSigner, crate::lightning::sign::SignerProvider, crate::lightning::chain::chaininterface::FeeEstimator, crate::lightning::routing::router::Router, crate::lightning::onion_message::messenger::MessageRouter, crate::lightning::util::logger::Logger, >;

/// A lightning node's channel state machine and payment management logic, which facilitates
/// sending, forwarding, and receiving payments through lightning channels.
///
/// [`ChannelManager`] is parameterized by a number of components to achieve this.
/// - [`chain::Watch`] (typically [`ChainMonitor`]) for on-chain monitoring and enforcement of each
///   channel
/// - [`BroadcasterInterface`] for broadcasting transactions related to opening, funding, and
///   closing channels
/// - [`EntropySource`] for providing random data needed for cryptographic operations
/// - [`NodeSigner`] for cryptographic operations scoped to the node
/// - [`SignerProvider`] for providing signers whose operations are scoped to individual channels
/// - [`FeeEstimator`] to determine transaction fee rates needed to have a transaction mined in a
///   timely manner
/// - [`Router`] for finding payment paths when initiating and retrying payments
/// - [`MessageRouter`] for finding message paths when initiating and retrying onion messages
/// - [`Logger`] for logging operational information of varying degrees
///
/// Additionally, it implements the following traits:
/// - [`ChannelMessageHandler`] to handle off-chain channel activity from peers
/// - [`MessageSendEventsProvider`] to similarly send such messages to peers
/// - [`OffersMessageHandler`] for BOLT 12 message handling and sending
/// - [`EventsProvider`] to generate user-actionable [`Event`]s
/// - [`chain::Listen`] and [`chain::Confirm`] for notification of on-chain activity
///
/// Thus, [`ChannelManager`] is typically used to parameterize a [`MessageHandler`] and an
/// [`OnionMessenger`]. The latter is required to support BOLT 12 functionality.
///
/// # `ChannelManager` vs `ChannelMonitor`
///
/// It's important to distinguish between the *off-chain* management and *on-chain* enforcement of
/// lightning channels. [`ChannelManager`] exchanges messages with peers to manage the off-chain
/// state of each channel. During this process, it generates a [`ChannelMonitor`] for each channel
/// and a [`ChannelMonitorUpdate`] for each relevant change, notifying its parameterized
/// [`chain::Watch`] of them.
///
/// An implementation of [`chain::Watch`], such as [`ChainMonitor`], is responsible for aggregating
/// these [`ChannelMonitor`]s and applying any [`ChannelMonitorUpdate`]s to them. It then monitors
/// for any pertinent on-chain activity, enforcing claims as needed.
///
/// This division of off-chain management and on-chain enforcement allows for interesting node
/// setups. For instance, on-chain enforcement could be moved to a separate host or have added
/// redundancy, possibly as a watchtower. See [`chain::Watch`] for the relevant interface.
///
/// # Initialization
///
/// Use [`ChannelManager::new`] with the most recent [`BlockHash`] when creating a fresh instance.
/// Otherwise, if restarting, construct [`ChannelManagerReadArgs`] with the necessary parameters and
/// references to any deserialized [`ChannelMonitor`]s that were previously persisted. Use this to
/// deserialize the [`ChannelManager`] and feed it any new chain data since it was last online, as
/// detailed in the [`ChannelManagerReadArgs`] documentation.
///
/// ```
/// use bitcoin::BlockHash;
/// use bitcoin::network::Network;
/// use lightning::chain::BestBlock;
/// # use lightning::chain::channelmonitor::ChannelMonitor;
/// use lightning::ln::channelmanager::{ChainParameters, ChannelManager, ChannelManagerReadArgs};
/// # use lightning::routing::gossip::NetworkGraph;
/// use lightning::util::config::UserConfig;
/// use lightning::util::ser::ReadableArgs;
///
/// # fn read_channel_monitors() -> Vec<ChannelMonitor<lightning::sign::InMemorySigner>> { vec![] }
/// # fn example<
/// #     'a,
/// #     L: lightning::util::logger::Logger,
/// #     ES: lightning::sign::EntropySource,
/// #     S: for <'b> lightning::routing::scoring::LockableScore<'b, ScoreLookUp = SL>,
/// #     SL: lightning::routing::scoring::ScoreLookUp<ScoreParams = SP>,
/// #     SP: Sized,
/// #     R: lightning::io::Read,
/// # >(
/// #     fee_estimator: &dyn lightning::chain::chaininterface::FeeEstimator,
/// #     chain_monitor: &dyn lightning::chain::Watch<lightning::sign::InMemorySigner>,
/// #     tx_broadcaster: &dyn lightning::chain::chaininterface::BroadcasterInterface,
/// #     router: &lightning::routing::router::DefaultRouter<&NetworkGraph<&'a L>, &'a L, &ES, &S>,
/// #     message_router: &lightning::onion_message::messenger::DefaultMessageRouter<&NetworkGraph<&'a L>, &'a L, &ES>,
/// #     logger: &L,
/// #     entropy_source: &ES,
/// #     node_signer: &dyn lightning::sign::NodeSigner,
/// #     signer_provider: &lightning::sign::DynSignerProvider,
/// #     best_block: lightning::chain::BestBlock,
/// #     current_timestamp: u32,
/// #     mut reader: R,
/// # ) -> Result<(), lightning::ln::msgs::DecodeError> {
/// // Fresh start with no channels
/// let params = ChainParameters {
///     network: Network::Bitcoin,
///     best_block,
/// };
/// let default_config = UserConfig::default();
/// let channel_manager = ChannelManager::new(
///     fee_estimator, chain_monitor, tx_broadcaster, router, message_router, logger,
///     entropy_source, node_signer, signer_provider, default_config, params, current_timestamp,
/// );
///
/// // Restart from deserialized data
/// let mut channel_monitors = read_channel_monitors();
/// let args = ChannelManagerReadArgs::new(
///     entropy_source, node_signer, signer_provider, fee_estimator, chain_monitor, tx_broadcaster,
///     router, message_router, logger, default_config, channel_monitors.iter().collect(),
/// );
/// let (block_hash, channel_manager) =
///     <(BlockHash, ChannelManager<_, _, _, _, _, _, _, _, _>)>::read(&mut reader, args)?;
///
/// // Update the ChannelManager and ChannelMonitors with the latest chain data
/// // ...
///
/// // Move the monitors to the ChannelManager's chain::Watch parameter
/// for monitor in channel_monitors {
///     chain_monitor.watch_channel(monitor.get_funding_txo().0, monitor);
/// }
/// # Ok(())
/// # }
/// ```
///
/// # Operation
///
/// The following is required for [`ChannelManager`] to function properly:
/// - Handle messages from peers using its [`ChannelMessageHandler`] implementation (typically
///   called by [`PeerManager::read_event`] when processing network I/O)
/// - Send messages to peers obtained via its [`MessageSendEventsProvider`] implementation
///   (typically initiated when [`PeerManager::process_events`] is called)
/// - Feed on-chain activity using either its [`chain::Listen`] or [`chain::Confirm`] implementation
///   as documented by those traits
/// - Perform any periodic channel and payment checks by calling [`timer_tick_occurred`] roughly
///   every minute
/// - Persist to disk whenever [`get_and_clear_needs_persistence`] returns `true` using a
///   [`Persister`] such as a [`KVStore`] implementation
/// - Handle [`Event`]s obtained via its [`EventsProvider`] implementation
///
/// The [`Future`] returned by [`get_event_or_persistence_needed_future`] is useful in determining
/// when the last two requirements need to be checked.
///
/// The [`lightning-block-sync`] and [`lightning-transaction-sync`] crates provide utilities that
/// simplify feeding in on-chain activity using the [`chain::Listen`] and [`chain::Confirm`] traits,
/// respectively. The remaining requirements can be met using the [`lightning-background-processor`]
/// crate. For languages other than Rust, the availability of similar utilities may vary.
///
/// # Channels
///
/// [`ChannelManager`]'s primary function involves managing a channel state. Without channels,
/// payments can't be sent. Use [`list_channels`] or [`list_usable_channels`] for a snapshot of the
/// currently open channels.
///
/// ```
/// # use lightning::ln::channelmanager::AChannelManager;
/// #
/// # fn example<T: AChannelManager>(channel_manager: T) {
/// # let channel_manager = channel_manager.get_cm();
/// let channels = channel_manager.list_usable_channels();
/// for details in channels {
///     println!(\"{:?}\", details);
/// }
/// # }
/// ```
///
/// Each channel is identified using a [`ChannelId`], which will change throughout the channel's
/// life cycle. Additionally, channels are assigned a `user_channel_id`, which is given in
/// [`Event`]s associated with the channel and serves as a fixed identifier but is otherwise unused
/// by [`ChannelManager`].
///
/// ## Opening Channels
///
/// To an open a channel with a peer, call [`create_channel`]. This will initiate the process of
/// opening an outbound channel, which requires self-funding when handling
/// [`Event::FundingGenerationReady`].
///
/// ```
/// # use bitcoin::{ScriptBuf, Transaction};
/// # use bitcoin::secp256k1::PublicKey;
/// # use lightning::ln::channelmanager::AChannelManager;
/// # use lightning::events::{Event, EventsProvider};
/// #
/// # trait Wallet {
/// #     fn create_funding_transaction(
/// #         &self, _amount_sats: u64, _output_script: ScriptBuf
/// #     ) -> Transaction;
/// # }
/// #
/// # fn example<T: AChannelManager, W: Wallet>(channel_manager: T, wallet: W, peer_id: PublicKey) {
/// # let channel_manager = channel_manager.get_cm();
/// let value_sats = 1_000_000;
/// let push_msats = 10_000_000;
/// match channel_manager.create_channel(peer_id, value_sats, push_msats, 42, None, None) {
///     Ok(channel_id) => println!(\"Opening channel {}\", channel_id),
///     Err(e) => println!(\"Error opening channel: {:?}\", e),
/// }
///
/// // On the event processing thread once the peer has responded
/// channel_manager.process_pending_events(&|event| {
///     match event {
///         Event::FundingGenerationReady {
///             temporary_channel_id, counterparty_node_id, channel_value_satoshis, output_script,
///             user_channel_id, ..
///         } => {
///             assert_eq!(user_channel_id, 42);
///             let funding_transaction = wallet.create_funding_transaction(
///                 channel_value_satoshis, output_script
///             );
///             match channel_manager.funding_transaction_generated(
///                 temporary_channel_id, counterparty_node_id, funding_transaction
///             ) {
///                 Ok(()) => println!(\"Funding channel {}\", temporary_channel_id),
///                 Err(e) => println!(\"Error funding channel {}: {:?}\", temporary_channel_id, e),
///             }
///         },
///         Event::ChannelPending { channel_id, user_channel_id, former_temporary_channel_id, .. } => {
///             assert_eq!(user_channel_id, 42);
///             println!(
///                 \"Channel {} now {} pending (funding transaction has been broadcasted)\", channel_id,
///                 former_temporary_channel_id.unwrap()
///             );
///         },
///         Event::ChannelReady { channel_id, user_channel_id, .. } => {
///             assert_eq!(user_channel_id, 42);
///             println!(\"Channel {} ready\", channel_id);
///         },
///         // ...
///     #     _ => {},
///     }
///     Ok(())
/// });
/// # }
/// ```
///
/// ## Accepting Channels
///
/// Inbound channels are initiated by peers and are automatically accepted unless [`ChannelManager`]
/// has [`UserConfig::manually_accept_inbound_channels`] set. In that case, the channel may be
/// either accepted or rejected when handling [`Event::OpenChannelRequest`].
///
/// ```
/// # use bitcoin::secp256k1::PublicKey;
/// # use lightning::ln::channelmanager::AChannelManager;
/// # use lightning::events::{Event, EventsProvider};
/// #
/// # fn is_trusted(counterparty_node_id: PublicKey) -> bool {
/// #     // ...
/// #     unimplemented!()
/// # }
/// #
/// # fn example<T: AChannelManager>(channel_manager: T) {
/// # let channel_manager = channel_manager.get_cm();
/// # let error_message = \"Channel force-closed\";
/// channel_manager.process_pending_events(&|event| {
///     match event {
///         Event::OpenChannelRequest { temporary_channel_id, counterparty_node_id, ..  } => {
///             if !is_trusted(counterparty_node_id) {
///                 match channel_manager.force_close_without_broadcasting_txn(
///                     &temporary_channel_id, &counterparty_node_id, error_message.to_string()
///                 ) {
///                     Ok(()) => println!(\"Rejecting channel {}\", temporary_channel_id),
///                     Err(e) => println!(\"Error rejecting channel {}: {:?}\", temporary_channel_id, e),
///                 }
///                 return Ok(());
///             }
///
///             let user_channel_id = 43;
///             match channel_manager.accept_inbound_channel(
///                 &temporary_channel_id, &counterparty_node_id, user_channel_id
///             ) {
///                 Ok(()) => println!(\"Accepting channel {}\", temporary_channel_id),
///                 Err(e) => println!(\"Error accepting channel {}: {:?}\", temporary_channel_id, e),
///             }
///         },
///         // ...
///     #     _ => {},
///     }
///     Ok(())
/// });
/// # }
/// ```
///
/// ## Closing Channels
///
/// There are two ways to close a channel: either cooperatively using [`close_channel`] or
/// unilaterally using [`force_close_broadcasting_latest_txn`]. The former is ideal as it makes for
/// lower fees and immediate access to funds. However, the latter may be necessary if the
/// counterparty isn't behaving properly or has gone offline. [`Event::ChannelClosed`] is generated
/// once the channel has been closed successfully.
///
/// ```
/// # use bitcoin::secp256k1::PublicKey;
/// # use lightning::ln::types::ChannelId;
/// # use lightning::ln::channelmanager::AChannelManager;
/// # use lightning::events::{Event, EventsProvider};
/// #
/// # fn example<T: AChannelManager>(
/// #     channel_manager: T, channel_id: ChannelId, counterparty_node_id: PublicKey
/// # ) {
/// # let channel_manager = channel_manager.get_cm();
/// match channel_manager.close_channel(&channel_id, &counterparty_node_id) {
///     Ok(()) => println!(\"Closing channel {}\", channel_id),
///     Err(e) => println!(\"Error closing channel {}: {:?}\", channel_id, e),
/// }
///
/// // On the event processing thread
/// channel_manager.process_pending_events(&|event| {
///     match event {
///         Event::ChannelClosed { channel_id, user_channel_id, ..  } => {
///             assert_eq!(user_channel_id, 42);
///             println!(\"Channel {} closed\", channel_id);
///         },
///         // ...
///     #     _ => {},
///     }
///     Ok(())
/// });
/// # }
/// ```
///
/// # Payments
///
/// [`ChannelManager`] is responsible for sending, forwarding, and receiving payments through its
/// channels. A payment is typically initiated from a [BOLT 11] invoice or a [BOLT 12] offer, though
/// spontaneous (i.e., keysend) payments are also possible. Incoming payments don't require
/// maintaining any additional state as [`ChannelManager`] can reconstruct the [`PaymentPreimage`]
/// from the [`PaymentSecret`]. Sending payments, however, require tracking in order to retry failed
/// HTLCs.
///
/// After a payment is initiated, it will appear in [`list_recent_payments`] until a short time
/// after either an [`Event::PaymentSent`] or [`Event::PaymentFailed`] is handled. Failed HTLCs
/// for a payment will be retried according to the payment's [`Retry`] strategy or until
/// [`abandon_payment`] is called.
///
/// ## BOLT 11 Invoices
///
/// The [`lightning-invoice`] crate is useful for creating BOLT 11 invoices. However, in order to
/// construct a [`Bolt11Invoice`] that is compatible with [`ChannelManager`], use
/// [`create_bolt11_invoice`]. This method serves as a convenience for building invoices with the
/// [`PaymentHash`] and [`PaymentSecret`] returned from [`create_inbound_payment`]. To provide your
/// own [`PaymentHash`], override the appropriate [`Bolt11InvoiceParameters`], which is equivalent
/// to using [`create_inbound_payment_for_hash`].
///
/// [`ChannelManager`] generates an [`Event::PaymentClaimable`] once the full payment has been
/// received. Call [`claim_funds`] to release the [`PaymentPreimage`], which in turn will result in
/// an [`Event::PaymentClaimed`].
///
/// ```
/// # use lightning::events::{Event, EventsProvider, PaymentPurpose};
/// # use lightning::ln::channelmanager::{AChannelManager, Bolt11InvoiceParameters};
/// #
/// # fn example<T: AChannelManager>(channel_manager: T) {
/// # let channel_manager = channel_manager.get_cm();
/// let params = Bolt11InvoiceParameters {
///     amount_msats: Some(10_000_000),
///     invoice_expiry_delta_secs: Some(3600),
///     ..Default::default()
/// };
/// let invoice = match channel_manager.create_bolt11_invoice(params) {
///     Ok(invoice) => {
///         println!(\"Creating invoice with payment hash {}\", invoice.payment_hash());
///         invoice
///     },
///     Err(e) => panic!(\"Error creating invoice: {}\", e),
/// };
///
/// // On the event processing thread
/// channel_manager.process_pending_events(&|event| {
///     match event {
///         Event::PaymentClaimable { payment_hash, purpose, .. } => match purpose {
///             PaymentPurpose::Bolt11InvoicePayment { payment_preimage: Some(payment_preimage), .. } => {
///                 assert_eq!(payment_hash.0, invoice.payment_hash().as_ref());
///                 println!(\"Claiming payment {}\", payment_hash);
///                 channel_manager.claim_funds(payment_preimage);
///             },
///             PaymentPurpose::Bolt11InvoicePayment { payment_preimage: None, .. } => {
///                 println!(\"Unknown payment hash: {}\", payment_hash);
///             },
///             PaymentPurpose::SpontaneousPayment(payment_preimage) => {
///                 assert_ne!(payment_hash.0, invoice.payment_hash().as_ref());
///                 println!(\"Claiming spontaneous payment {}\", payment_hash);
///                 channel_manager.claim_funds(payment_preimage);
///             },
///             // ...
/// #           _ => {},
///         },
///         Event::PaymentClaimed { payment_hash, amount_msat, .. } => {
///             assert_eq!(payment_hash.0, invoice.payment_hash().as_ref());
///             println!(\"Claimed {} msats\", amount_msat);
///         },
///         // ...
/// #       _ => {},
///     }
///     Ok(())
/// });
/// # }
/// ```
///
/// For paying an invoice, see the [`bolt11_payment`] module with convenience functions for use with
/// [`send_payment`].
///
/// ```
/// # use lightning::events::{Event, EventsProvider};
/// # use lightning::types::payment::PaymentHash;
/// # use lightning::ln::channelmanager::{AChannelManager, PaymentId, RecentPaymentDetails};
/// # use lightning::ln::outbound_payment::{RecipientOnionFields, Retry};
/// # use lightning::routing::router::RouteParameters;
/// #
/// # fn example<T: AChannelManager>(
/// #     channel_manager: T, payment_hash: PaymentHash, recipient_onion: RecipientOnionFields,
/// #     route_params: RouteParameters, retry: Retry
/// # ) {
/// # let channel_manager = channel_manager.get_cm();
/// // let (payment_hash, recipient_onion, route_params) =
/// //     payment::payment_parameters_from_invoice(&invoice);
/// let payment_id = PaymentId([42; 32]);
/// match channel_manager.send_payment(
///     payment_hash, recipient_onion, payment_id, route_params, retry
/// ) {
///     Ok(()) => println!(\"Sending payment with hash {}\", payment_hash),
///     Err(e) => println!(\"Failed sending payment with hash {}: {:?}\", payment_hash, e),
/// }
///
/// let expected_payment_id = payment_id;
/// let expected_payment_hash = payment_hash;
/// assert!(
///     channel_manager.list_recent_payments().iter().find(|details| matches!(
///         details,
///         RecentPaymentDetails::Pending {
///             payment_id: expected_payment_id,
///             payment_hash: expected_payment_hash,
///             ..
///         }
///     )).is_some()
/// );
///
/// // On the event processing thread
/// channel_manager.process_pending_events(&|event| {
///     match event {
///         Event::PaymentSent { payment_hash, .. } => println!(\"Paid {}\", payment_hash),
///         Event::PaymentFailed { payment_hash: Some(payment_hash), .. } =>
///             println!(\"Failed paying {}\", payment_hash),
///         // ...
///     #     _ => {},
///     }
///     Ok(())
/// });
/// # }
/// ```
///
/// ## BOLT 12 Offers
///
/// The [`offers`] module is useful for creating BOLT 12 offers. An [`Offer`] is a precursor to a
/// [`Bolt12Invoice`], which must first be requested by the payer. The interchange of these messages
/// as defined in the specification is handled by [`ChannelManager`] and its implementation of
/// [`OffersMessageHandler`]. However, this only works with an [`Offer`] created using a builder
/// returned by [`create_offer_builder`]. With this approach, BOLT 12 offers and invoices are
/// stateless just as BOLT 11 invoices are.
///
/// ```
/// # use lightning::events::{Event, EventsProvider, PaymentPurpose};
/// # use lightning::ln::channelmanager::AChannelManager;
/// # use lightning::offers::parse::Bolt12SemanticError;
/// #
/// # fn example<T: AChannelManager>(channel_manager: T) -> Result<(), Bolt12SemanticError> {
/// # let channel_manager = channel_manager.get_cm();
/// # let absolute_expiry = None;
/// let offer = channel_manager
///     .create_offer_builder(absolute_expiry)?
/// # ;
/// # // Needed for compiling for c_bindings
/// # let builder: lightning::offers::offer::OfferBuilder<_, _> = offer.into();
/// # let offer = builder
///     .description(\"coffee\".to_string())
///     .amount_msats(10_000_000)
///     .build()?;
/// let bech32_offer = offer.to_string();
///
/// // On the event processing thread
/// channel_manager.process_pending_events(&|event| {
///     match event {
///         Event::PaymentClaimable { payment_hash, purpose, .. } => match purpose {
///             PaymentPurpose::Bolt12OfferPayment { payment_preimage: Some(payment_preimage), .. } => {
///                 println!(\"Claiming payment {}\", payment_hash);
///                 channel_manager.claim_funds(payment_preimage);
///             },
///             PaymentPurpose::Bolt12OfferPayment { payment_preimage: None, .. } => {
///                 println!(\"Unknown payment hash: {}\", payment_hash);
///             }
/// #           _ => {},
///         },
///         Event::PaymentClaimed { payment_hash, amount_msat, .. } => {
///             println!(\"Claimed {} msats\", amount_msat);
///         },
///         // ...
///     #     _ => {},
///     }
///     Ok(())
/// });
/// # Ok(())
/// # }
/// ```
///
/// Use [`pay_for_offer`] to initiated payment, which sends an [`InvoiceRequest`] for an [`Offer`]
/// and pays the [`Bolt12Invoice`] response.
///
/// ```
/// # use lightning::events::{Event, EventsProvider};
/// # use lightning::ln::channelmanager::{AChannelManager, PaymentId, RecentPaymentDetails};
/// # use lightning::ln::outbound_payment::Retry;
/// # use lightning::offers::offer::Offer;
/// #
/// # fn example<T: AChannelManager>(
/// #     channel_manager: T, offer: &Offer, quantity: Option<u64>, amount_msats: Option<u64>,
/// #     payer_note: Option<String>, retry: Retry, max_total_routing_fee_msat: Option<u64>
/// # ) {
/// # let channel_manager = channel_manager.get_cm();
/// let payment_id = PaymentId([42; 32]);
/// match channel_manager.pay_for_offer(
///     offer, quantity, amount_msats, payer_note, payment_id, retry, max_total_routing_fee_msat
/// ) {
///     Ok(()) => println!(\"Requesting invoice for offer\"),
///     Err(e) => println!(\"Unable to request invoice for offer: {:?}\", e),
/// }
///
/// // First the payment will be waiting on an invoice
/// let expected_payment_id = payment_id;
/// assert!(
///     channel_manager.list_recent_payments().iter().find(|details| matches!(
///         details,
///         RecentPaymentDetails::AwaitingInvoice { payment_id: expected_payment_id }
///     )).is_some()
/// );
///
/// // Once the invoice is received, a payment will be sent
/// assert!(
///     channel_manager.list_recent_payments().iter().find(|details| matches!(
///         details,
///         RecentPaymentDetails::Pending { payment_id: expected_payment_id, ..  }
///     )).is_some()
/// );
///
/// // On the event processing thread
/// channel_manager.process_pending_events(&|event| {
///     match event {
///         Event::PaymentSent { payment_id: Some(payment_id), .. } => println!(\"Paid {}\", payment_id),
///         Event::PaymentFailed { payment_id, .. } => println!(\"Failed paying {}\", payment_id),
///         // ...
///     #     _ => {},
///     }
///     Ok(())
/// });
/// # }
/// ```
///
/// ## BOLT 12 Refunds
///
/// A [`Refund`] is a request for an invoice to be paid. Like *paying* for an [`Offer`], *creating*
/// a [`Refund`] involves maintaining state since it represents a future outbound payment.
/// Therefore, use [`create_refund_builder`] when creating one, otherwise [`ChannelManager`] will
/// refuse to pay any corresponding [`Bolt12Invoice`] that it receives.
///
/// ```
/// # use core::time::Duration;
/// # use lightning::events::{Event, EventsProvider};
/// # use lightning::ln::channelmanager::{AChannelManager, PaymentId, RecentPaymentDetails};
/// # use lightning::ln::outbound_payment::Retry;
/// # use lightning::offers::parse::Bolt12SemanticError;
/// #
/// # fn example<T: AChannelManager>(
/// #     channel_manager: T, amount_msats: u64, absolute_expiry: Duration, retry: Retry,
/// #     max_total_routing_fee_msat: Option<u64>
/// # ) -> Result<(), Bolt12SemanticError> {
/// # let channel_manager = channel_manager.get_cm();
/// let payment_id = PaymentId([42; 32]);
/// let refund = channel_manager
///     .create_refund_builder(
///         amount_msats, absolute_expiry, payment_id, retry, max_total_routing_fee_msat
///     )?
/// # ;
/// # // Needed for compiling for c_bindings
/// # let builder: lightning::offers::refund::RefundBuilder<_> = refund.into();
/// # let refund = builder
///     .description(\"coffee\".to_string())
///     .payer_note(\"refund for order 1234\".to_string())
///     .build()?;
/// let bech32_refund = refund.to_string();
///
/// // First the payment will be waiting on an invoice
/// let expected_payment_id = payment_id;
/// assert!(
///     channel_manager.list_recent_payments().iter().find(|details| matches!(
///         details,
///         RecentPaymentDetails::AwaitingInvoice { payment_id: expected_payment_id }
///     )).is_some()
/// );
///
/// // Once the invoice is received, a payment will be sent
/// assert!(
///     channel_manager.list_recent_payments().iter().find(|details| matches!(
///         details,
///         RecentPaymentDetails::Pending { payment_id: expected_payment_id, ..  }
///     )).is_some()
/// );
///
/// // On the event processing thread
/// channel_manager.process_pending_events(&|event| {
///     match event {
///         Event::PaymentSent { payment_id: Some(payment_id), .. } => println!(\"Paid {}\", payment_id),
///         Event::PaymentFailed { payment_id, .. } => println!(\"Failed paying {}\", payment_id),
///         // ...
///     #     _ => {},
///     }
///     Ok(())
/// });
/// # Ok(())
/// # }
/// ```
///
/// Use [`request_refund_payment`] to send a [`Bolt12Invoice`] for receiving the refund. Similar to
/// *creating* an [`Offer`], this is stateless as it represents an inbound payment.
///
/// ```
/// # use lightning::events::{Event, EventsProvider, PaymentPurpose};
/// # use lightning::ln::channelmanager::AChannelManager;
/// # use lightning::offers::refund::Refund;
/// #
/// # fn example<T: AChannelManager>(channel_manager: T, refund: &Refund) {
/// # let channel_manager = channel_manager.get_cm();
/// let known_payment_hash = match channel_manager.request_refund_payment(refund) {
///     Ok(invoice) => {
///         let payment_hash = invoice.payment_hash();
///         println!(\"Requesting refund payment {}\", payment_hash);
///         payment_hash
///     },
///     Err(e) => panic!(\"Unable to request payment for refund: {:?}\", e),
/// };
///
/// // On the event processing thread
/// channel_manager.process_pending_events(&|event| {
///     match event {
///         Event::PaymentClaimable { payment_hash, purpose, .. } => match purpose {
///             PaymentPurpose::Bolt12RefundPayment { payment_preimage: Some(payment_preimage), .. } => {
///                 assert_eq!(payment_hash, known_payment_hash);
///                 println!(\"Claiming payment {}\", payment_hash);
///                 channel_manager.claim_funds(payment_preimage);
///             },
///             PaymentPurpose::Bolt12RefundPayment { payment_preimage: None, .. } => {
///                 println!(\"Unknown payment hash: {}\", payment_hash);
///             },
///             // ...
/// #           _ => {},
///     },
///     Event::PaymentClaimed { payment_hash, amount_msat, .. } => {
///         assert_eq!(payment_hash, known_payment_hash);
///         println!(\"Claimed {} msats\", amount_msat);
///     },
///     // ...
/// #     _ => {},
///     }
///     Ok(())
/// });
/// # }
/// ```
///
/// # Persistence
///
/// Implements [`Writeable`] to write out all channel state to disk. Implies [`peer_disconnected`] for
/// all peers during write/read (though does not modify this instance, only the instance being
/// serialized). This will result in any channels which have not yet exchanged [`funding_created`] (i.e.,
/// called [`funding_transaction_generated`] for outbound channels) being closed.
///
/// Note that you can be a bit lazier about writing out `ChannelManager` than you can be with
/// [`ChannelMonitor`]. With [`ChannelMonitor`] you MUST durably write each
/// [`ChannelMonitorUpdate`] before returning from
/// [`chain::Watch::watch_channel`]/[`update_channel`] or before completing async writes. With
/// `ChannelManager`s, writing updates happens out-of-band (and will prevent any other
/// `ChannelManager` operations from occurring during the serialization process). If the
/// deserialized version is out-of-date compared to the [`ChannelMonitor`] passed by reference to
/// [`read`], those channels will be force-closed based on the `ChannelMonitor` state and no funds
/// will be lost (modulo on-chain transaction fees).
///
/// Note that the deserializer is only implemented for `(`[`BlockHash`]`, `[`ChannelManager`]`)`, which
/// tells you the last block hash which was connected. You should get the best block tip before using the manager.
/// See [`chain::Listen`] and [`chain::Confirm`] for more details.
///
/// # `ChannelUpdate` Messages
///
/// Note that `ChannelManager` is responsible for tracking liveness of its channels and generating
/// [`ChannelUpdate`] messages informing peers that the channel is temporarily disabled. To avoid
/// spam due to quick disconnection/reconnection, updates are not sent until the channel has been
/// offline for a full minute. In order to track this, you must call
/// [`timer_tick_occurred`] roughly once per minute, though it doesn't have to be perfect.
///
/// # DoS Mitigation
///
/// To avoid trivial DoS issues, `ChannelManager` limits the number of inbound connections and
/// inbound channels without confirmed funding transactions. This may result in nodes which we do
/// not have a channel with being unable to connect to us or open new channels with us if we have
/// many peers with unfunded channels.
///
/// Because it is an indication of trust, inbound channels which we've accepted as 0conf are
/// exempted from the count of unfunded channels. Similarly, outbound channels and connections are
/// never limited. Please ensure you limit the count of such channels yourself.
///
/// # Type Aliases
///
/// Rather than using a plain `ChannelManager`, it is preferable to use either a [`SimpleArcChannelManager`]
/// a [`SimpleRefChannelManager`], for conciseness. See their documentation for more details, but
/// essentially you should default to using a [`SimpleRefChannelManager`], and use a
/// [`SimpleArcChannelManager`] when you require a `ChannelManager` with a static lifetime, such as when
/// you're using lightning-net-tokio.
///
/// [`ChainMonitor`]: crate::chain::chainmonitor::ChainMonitor
/// [`MessageHandler`]: crate::ln::peer_handler::MessageHandler
/// [`OnionMessenger`]: crate::onion_message::messenger::OnionMessenger
/// [`PeerManager::read_event`]: crate::ln::peer_handler::PeerManager::read_event
/// [`PeerManager::process_events`]: crate::ln::peer_handler::PeerManager::process_events
/// [`timer_tick_occurred`]: Self::timer_tick_occurred
/// [`get_and_clear_needs_persistence`]: Self::get_and_clear_needs_persistence
/// [`Persister`]: crate::util::persist::Persister
/// [`KVStore`]: crate::util::persist::KVStore
/// [`get_event_or_persistence_needed_future`]: Self::get_event_or_persistence_needed_future
/// [`lightning-block-sync`]: https://docs.rs/lightning_block_sync/latest/lightning_block_sync
/// [`lightning-transaction-sync`]: https://docs.rs/lightning_transaction_sync/latest/lightning_transaction_sync
/// [`lightning-background-processor`]: https://docs.rs/lightning_background_processor/lightning_background_processor
/// [`list_channels`]: Self::list_channels
/// [`list_usable_channels`]: Self::list_usable_channels
/// [`create_channel`]: Self::create_channel
/// [`close_channel`]: Self::force_close_broadcasting_latest_txn
/// [`force_close_broadcasting_latest_txn`]: Self::force_close_broadcasting_latest_txn
/// [BOLT 11]: https://github.com/lightning/bolts/blob/master/11-payment-encoding.md
/// [BOLT 12]: https://github.com/rustyrussell/lightning-rfc/blob/guilt/offers/12-offer-encoding.md
/// [`list_recent_payments`]: Self::list_recent_payments
/// [`abandon_payment`]: Self::abandon_payment
/// [`lightning-invoice`]: https://docs.rs/lightning_invoice/latest/lightning_invoice
/// [`create_bolt11_invoice`]: Self::create_bolt11_invoice
/// [`create_inbound_payment`]: Self::create_inbound_payment
/// [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
/// [`bolt11_payment`]: crate::ln::bolt11_payment
/// [`claim_funds`]: Self::claim_funds
/// [`send_payment`]: Self::send_payment
/// [`offers`]: crate::offers
/// [`create_offer_builder`]: Self::create_offer_builder
/// [`pay_for_offer`]: Self::pay_for_offer
/// [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
/// [`create_refund_builder`]: Self::create_refund_builder
/// [`request_refund_payment`]: Self::request_refund_payment
/// [`peer_disconnected`]: msgs::ChannelMessageHandler::peer_disconnected
/// [`funding_created`]: msgs::FundingCreated
/// [`funding_transaction_generated`]: Self::funding_transaction_generated
/// [`BlockHash`]: bitcoin::hash_types::BlockHash
/// [`update_channel`]: chain::Watch::update_channel
/// [`ChannelUpdate`]: msgs::ChannelUpdate
/// [`read`]: ReadableArgs::read
#[must_use]
#[repr(C)]
pub struct ChannelManager {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeChannelManager,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for ChannelManager {
	type Target = nativeChannelManager;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for ChannelManager { }
unsafe impl core::marker::Sync for ChannelManager { }
impl Drop for ChannelManager {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeChannelManager>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the ChannelManager, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn ChannelManager_free(this_obj: ChannelManager) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChannelManager_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeChannelManager) };
}
#[allow(unused)]
impl ChannelManager {
	pub(crate) fn get_native_ref(&self) -> &'static nativeChannelManager {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeChannelManager {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeChannelManager {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}

use lightning::ln::channelmanager::ChainParameters as nativeChainParametersImport;
pub(crate) type nativeChainParameters = nativeChainParametersImport;

/// Chain-related parameters used to construct a new `ChannelManager`.
///
/// Typically, the block-specific parameters are derived from the best block hash for the network,
/// as a newly constructed `ChannelManager` will not have created any channels yet. These parameters
/// are not needed when deserializing a previously constructed `ChannelManager`.
#[must_use]
#[repr(C)]
pub struct ChainParameters {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeChainParameters,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for ChainParameters {
	type Target = nativeChainParameters;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for ChainParameters { }
unsafe impl core::marker::Sync for ChainParameters { }
impl Drop for ChainParameters {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeChainParameters>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the ChainParameters, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn ChainParameters_free(this_obj: ChainParameters) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChainParameters_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeChainParameters) };
}
#[allow(unused)]
impl ChainParameters {
	pub(crate) fn get_native_ref(&self) -> &'static nativeChainParameters {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeChainParameters {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeChainParameters {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// The network for determining the `chain_hash` in Lightning messages.
#[no_mangle]
pub extern "C" fn ChainParameters_get_network(this_ptr: &ChainParameters) -> crate::bitcoin::network::Network {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().network;
	crate::bitcoin::network::Network::from_bitcoin(inner_val)
}
/// The network for determining the `chain_hash` in Lightning messages.
#[no_mangle]
pub extern "C" fn ChainParameters_set_network(this_ptr: &mut ChainParameters, mut val: crate::bitcoin::network::Network) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.network = val.into_bitcoin();
}
/// The hash and height of the latest block successfully connected.
///
/// Used to track on-chain channel funding outputs and send payments with reliable timelocks.
#[no_mangle]
pub extern "C" fn ChainParameters_get_best_block(this_ptr: &ChainParameters) -> crate::lightning::chain::BestBlock {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().best_block;
	crate::lightning::chain::BestBlock { inner: unsafe { ObjOps::nonnull_ptr_to_inner((inner_val as *const lightning::chain::BestBlock<>) as *mut _) }, is_owned: false }
}
/// The hash and height of the latest block successfully connected.
///
/// Used to track on-chain channel funding outputs and send payments with reliable timelocks.
#[no_mangle]
pub extern "C" fn ChainParameters_set_best_block(this_ptr: &mut ChainParameters, mut val: crate::lightning::chain::BestBlock) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.best_block = *unsafe { Box::from_raw(val.take_inner()) };
}
/// Constructs a new ChainParameters given each field
#[must_use]
#[no_mangle]
pub extern "C" fn ChainParameters_new(mut network_arg: crate::bitcoin::network::Network, mut best_block_arg: crate::lightning::chain::BestBlock) -> ChainParameters {
	ChainParameters { inner: ObjOps::heap_alloc(nativeChainParameters {
		network: network_arg.into_bitcoin(),
		best_block: *unsafe { Box::from_raw(best_block_arg.take_inner()) },
	}), is_owned: true }
}
impl Clone for ChainParameters {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativeChainParameters>::is_null(self.inner) { core::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChainParameters_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const nativeChainParameters)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the ChainParameters
pub extern "C" fn ChainParameters_clone(orig: &ChainParameters) -> ChainParameters {
	orig.clone()
}
/// The amount of time in blocks we require our counterparty wait to claim their money (ie time
/// between when we, or our watchtower, must check for them having broadcast a theft transaction).
///
/// This can be increased (but not decreased) through [`ChannelHandshakeConfig::our_to_self_delay`]
///
/// [`ChannelHandshakeConfig::our_to_self_delay`]: crate::util::config::ChannelHandshakeConfig::our_to_self_delay

#[no_mangle]
pub static BREAKDOWN_TIMEOUT: u16 = lightning::ln::channelmanager::BREAKDOWN_TIMEOUT;
/// The minimum number of blocks between an inbound HTLC's CLTV and the corresponding outbound
/// HTLC's CLTV. The current default represents roughly seven hours of blocks at six blocks/hour.
///
/// This can be increased (but not decreased) through [`ChannelConfig::cltv_expiry_delta`]
///
/// [`ChannelConfig::cltv_expiry_delta`]: crate::util::config::ChannelConfig::cltv_expiry_delta

#[no_mangle]
pub static MIN_CLTV_EXPIRY_DELTA: u16 = lightning::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA;
/// Minimum CLTV difference between the current block height and received inbound payments.
/// Invoices generated for payment to us must set their `min_final_cltv_expiry_delta` field to at least
/// this value.

#[no_mangle]
pub static MIN_FINAL_CLTV_EXPIRY_DELTA: u16 = lightning::ln::channelmanager::MIN_FINAL_CLTV_EXPIRY_DELTA;
/// Used by [`ChannelManager::list_recent_payments`] to express the status of recent payments.
/// These include payments that have yet to find a successful path, or have unresolved HTLCs.
#[derive(Clone)]
#[must_use]
#[repr(C)]
pub enum RecentPaymentDetails {
	/// When an invoice was requested and thus a payment has not yet been sent.
	AwaitingInvoice {
		/// A user-provided identifier in [`ChannelManager::pay_for_offer`] used to uniquely identify a
		/// payment and ensure idempotency in LDK.
		payment_id: crate::c_types::ThirtyTwoBytes,
	},
	/// When a payment is still being sent and awaiting successful delivery.
	Pending {
		/// A user-provided identifier in [`send_payment`] or [`pay_for_offer`] used to uniquely
		/// identify a payment and ensure idempotency in LDK.
		///
		/// [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
		/// [`pay_for_offer`]: crate::ln::channelmanager::ChannelManager::pay_for_offer
		payment_id: crate::c_types::ThirtyTwoBytes,
		/// Hash of the payment that is currently being sent but has yet to be fulfilled or
		/// abandoned.
		payment_hash: crate::c_types::ThirtyTwoBytes,
		/// Total amount (in msat, excluding fees) across all paths for this payment,
		/// not just the amount currently inflight.
		total_msat: u64,
	},
	/// When a pending payment is fulfilled, we continue tracking it until all pending HTLCs have
	/// been resolved. Upon receiving [`Event::PaymentSent`], we delay for a few minutes before the
	/// payment is removed from tracking.
	Fulfilled {
		/// A user-provided identifier in [`send_payment`] or [`pay_for_offer`] used to uniquely
		/// identify a payment and ensure idempotency in LDK.
		///
		/// [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
		/// [`pay_for_offer`]: crate::ln::channelmanager::ChannelManager::pay_for_offer
		payment_id: crate::c_types::ThirtyTwoBytes,
		/// Hash of the payment that was claimed. `None` for serializations of [`ChannelManager`]
		/// made before LDK version 0.0.104.
		payment_hash: crate::c_types::derived::COption_ThirtyTwoBytesZ,
	},
	/// After a payment's retries are exhausted per the provided [`Retry`], or it is explicitly
	/// abandoned via [`ChannelManager::abandon_payment`], it is marked as abandoned until all
	/// pending HTLCs for this payment resolve and an [`Event::PaymentFailed`] is generated.
	Abandoned {
		/// A user-provided identifier in [`send_payment`] or [`pay_for_offer`] used to uniquely
		/// identify a payment and ensure idempotency in LDK.
		///
		/// [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
		/// [`pay_for_offer`]: crate::ln::channelmanager::ChannelManager::pay_for_offer
		payment_id: crate::c_types::ThirtyTwoBytes,
		/// Hash of the payment that we have given up trying to send.
		payment_hash: crate::c_types::ThirtyTwoBytes,
	},
}
use lightning::ln::channelmanager::RecentPaymentDetails as RecentPaymentDetailsImport;
pub(crate) type nativeRecentPaymentDetails = RecentPaymentDetailsImport;

impl RecentPaymentDetails {
	#[allow(unused)]
	pub(crate) fn to_native(&self) -> nativeRecentPaymentDetails {
		match self {
			RecentPaymentDetails::AwaitingInvoice {ref payment_id, } => {
				let mut payment_id_nonref = Clone::clone(payment_id);
				nativeRecentPaymentDetails::AwaitingInvoice {
					payment_id: ::lightning::ln::channelmanager::PaymentId(payment_id_nonref.data),
				}
			},
			RecentPaymentDetails::Pending {ref payment_id, ref payment_hash, ref total_msat, } => {
				let mut payment_id_nonref = Clone::clone(payment_id);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				let mut total_msat_nonref = Clone::clone(total_msat);
				nativeRecentPaymentDetails::Pending {
					payment_id: ::lightning::ln::channelmanager::PaymentId(payment_id_nonref.data),
					payment_hash: ::lightning::types::payment::PaymentHash(payment_hash_nonref.data),
					total_msat: total_msat_nonref,
				}
			},
			RecentPaymentDetails::Fulfilled {ref payment_id, ref payment_hash, } => {
				let mut payment_id_nonref = Clone::clone(payment_id);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				let mut local_payment_hash_nonref = { /*payment_hash_nonref*/ let payment_hash_nonref_opt = payment_hash_nonref; if payment_hash_nonref_opt.is_none() { None } else { Some({ { ::lightning::types::payment::PaymentHash({ payment_hash_nonref_opt.take() }.data) }})} };
				nativeRecentPaymentDetails::Fulfilled {
					payment_id: ::lightning::ln::channelmanager::PaymentId(payment_id_nonref.data),
					payment_hash: local_payment_hash_nonref,
				}
			},
			RecentPaymentDetails::Abandoned {ref payment_id, ref payment_hash, } => {
				let mut payment_id_nonref = Clone::clone(payment_id);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				nativeRecentPaymentDetails::Abandoned {
					payment_id: ::lightning::ln::channelmanager::PaymentId(payment_id_nonref.data),
					payment_hash: ::lightning::types::payment::PaymentHash(payment_hash_nonref.data),
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn into_native(self) -> nativeRecentPaymentDetails {
		match self {
			RecentPaymentDetails::AwaitingInvoice {mut payment_id, } => {
				nativeRecentPaymentDetails::AwaitingInvoice {
					payment_id: ::lightning::ln::channelmanager::PaymentId(payment_id.data),
				}
			},
			RecentPaymentDetails::Pending {mut payment_id, mut payment_hash, mut total_msat, } => {
				nativeRecentPaymentDetails::Pending {
					payment_id: ::lightning::ln::channelmanager::PaymentId(payment_id.data),
					payment_hash: ::lightning::types::payment::PaymentHash(payment_hash.data),
					total_msat: total_msat,
				}
			},
			RecentPaymentDetails::Fulfilled {mut payment_id, mut payment_hash, } => {
				let mut local_payment_hash = { /*payment_hash*/ let payment_hash_opt = payment_hash; if payment_hash_opt.is_none() { None } else { Some({ { ::lightning::types::payment::PaymentHash({ payment_hash_opt.take() }.data) }})} };
				nativeRecentPaymentDetails::Fulfilled {
					payment_id: ::lightning::ln::channelmanager::PaymentId(payment_id.data),
					payment_hash: local_payment_hash,
				}
			},
			RecentPaymentDetails::Abandoned {mut payment_id, mut payment_hash, } => {
				nativeRecentPaymentDetails::Abandoned {
					payment_id: ::lightning::ln::channelmanager::PaymentId(payment_id.data),
					payment_hash: ::lightning::types::payment::PaymentHash(payment_hash.data),
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn from_native(native: &RecentPaymentDetailsImport) -> Self {
		let native = unsafe { &*(native as *const _ as *const c_void as *const nativeRecentPaymentDetails) };
		match native {
			nativeRecentPaymentDetails::AwaitingInvoice {ref payment_id, } => {
				let mut payment_id_nonref = Clone::clone(payment_id);
				RecentPaymentDetails::AwaitingInvoice {
					payment_id: crate::c_types::ThirtyTwoBytes { data: payment_id_nonref.0 },
				}
			},
			nativeRecentPaymentDetails::Pending {ref payment_id, ref payment_hash, ref total_msat, } => {
				let mut payment_id_nonref = Clone::clone(payment_id);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				let mut total_msat_nonref = Clone::clone(total_msat);
				RecentPaymentDetails::Pending {
					payment_id: crate::c_types::ThirtyTwoBytes { data: payment_id_nonref.0 },
					payment_hash: crate::c_types::ThirtyTwoBytes { data: payment_hash_nonref.0 },
					total_msat: total_msat_nonref,
				}
			},
			nativeRecentPaymentDetails::Fulfilled {ref payment_id, ref payment_hash, } => {
				let mut payment_id_nonref = Clone::clone(payment_id);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				let mut local_payment_hash_nonref = if payment_hash_nonref.is_none() { crate::c_types::derived::COption_ThirtyTwoBytesZ::None } else { crate::c_types::derived::COption_ThirtyTwoBytesZ::Some( { crate::c_types::ThirtyTwoBytes { data: payment_hash_nonref.unwrap().0 } }) };
				RecentPaymentDetails::Fulfilled {
					payment_id: crate::c_types::ThirtyTwoBytes { data: payment_id_nonref.0 },
					payment_hash: local_payment_hash_nonref,
				}
			},
			nativeRecentPaymentDetails::Abandoned {ref payment_id, ref payment_hash, } => {
				let mut payment_id_nonref = Clone::clone(payment_id);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				RecentPaymentDetails::Abandoned {
					payment_id: crate::c_types::ThirtyTwoBytes { data: payment_id_nonref.0 },
					payment_hash: crate::c_types::ThirtyTwoBytes { data: payment_hash_nonref.0 },
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn native_into(native: nativeRecentPaymentDetails) -> Self {
		match native {
			nativeRecentPaymentDetails::AwaitingInvoice {mut payment_id, } => {
				RecentPaymentDetails::AwaitingInvoice {
					payment_id: crate::c_types::ThirtyTwoBytes { data: payment_id.0 },
				}
			},
			nativeRecentPaymentDetails::Pending {mut payment_id, mut payment_hash, mut total_msat, } => {
				RecentPaymentDetails::Pending {
					payment_id: crate::c_types::ThirtyTwoBytes { data: payment_id.0 },
					payment_hash: crate::c_types::ThirtyTwoBytes { data: payment_hash.0 },
					total_msat: total_msat,
				}
			},
			nativeRecentPaymentDetails::Fulfilled {mut payment_id, mut payment_hash, } => {
				let mut local_payment_hash = if payment_hash.is_none() { crate::c_types::derived::COption_ThirtyTwoBytesZ::None } else { crate::c_types::derived::COption_ThirtyTwoBytesZ::Some( { crate::c_types::ThirtyTwoBytes { data: payment_hash.unwrap().0 } }) };
				RecentPaymentDetails::Fulfilled {
					payment_id: crate::c_types::ThirtyTwoBytes { data: payment_id.0 },
					payment_hash: local_payment_hash,
				}
			},
			nativeRecentPaymentDetails::Abandoned {mut payment_id, mut payment_hash, } => {
				RecentPaymentDetails::Abandoned {
					payment_id: crate::c_types::ThirtyTwoBytes { data: payment_id.0 },
					payment_hash: crate::c_types::ThirtyTwoBytes { data: payment_hash.0 },
				}
			},
		}
	}
}
/// Frees any resources used by the RecentPaymentDetails
#[no_mangle]
pub extern "C" fn RecentPaymentDetails_free(this_ptr: RecentPaymentDetails) { }
/// Creates a copy of the RecentPaymentDetails
#[no_mangle]
pub extern "C" fn RecentPaymentDetails_clone(orig: &RecentPaymentDetails) -> RecentPaymentDetails {
	orig.clone()
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn RecentPaymentDetails_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const RecentPaymentDetails)).clone() })) as *mut c_void
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn RecentPaymentDetails_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut RecentPaymentDetails) };
}
#[no_mangle]
/// Utility method to constructs a new AwaitingInvoice-variant RecentPaymentDetails
pub extern "C" fn RecentPaymentDetails_awaiting_invoice(payment_id: crate::c_types::ThirtyTwoBytes) -> RecentPaymentDetails {
	RecentPaymentDetails::AwaitingInvoice {
		payment_id,
	}
}
#[no_mangle]
/// Utility method to constructs a new Pending-variant RecentPaymentDetails
pub extern "C" fn RecentPaymentDetails_pending(payment_id: crate::c_types::ThirtyTwoBytes, payment_hash: crate::c_types::ThirtyTwoBytes, total_msat: u64) -> RecentPaymentDetails {
	RecentPaymentDetails::Pending {
		payment_id,
		payment_hash,
		total_msat,
	}
}
#[no_mangle]
/// Utility method to constructs a new Fulfilled-variant RecentPaymentDetails
pub extern "C" fn RecentPaymentDetails_fulfilled(payment_id: crate::c_types::ThirtyTwoBytes, payment_hash: crate::c_types::derived::COption_ThirtyTwoBytesZ) -> RecentPaymentDetails {
	RecentPaymentDetails::Fulfilled {
		payment_id,
		payment_hash,
	}
}
#[no_mangle]
/// Utility method to constructs a new Abandoned-variant RecentPaymentDetails
pub extern "C" fn RecentPaymentDetails_abandoned(payment_id: crate::c_types::ThirtyTwoBytes, payment_hash: crate::c_types::ThirtyTwoBytes) -> RecentPaymentDetails {
	RecentPaymentDetails::Abandoned {
		payment_id,
		payment_hash,
	}
}
/// Get a string which allows debug introspection of a RecentPaymentDetails object
pub extern "C" fn RecentPaymentDetails_debug_str_void(o: *const c_void) -> Str {
	alloc::format!("{:?}", unsafe { o as *const crate::lightning::ln::channelmanager::RecentPaymentDetails }).into()}

use lightning::ln::channelmanager::PhantomRouteHints as nativePhantomRouteHintsImport;
pub(crate) type nativePhantomRouteHints = nativePhantomRouteHintsImport;

/// Route hints used in constructing invoices for [phantom node payents].
///
/// [phantom node payments]: crate::sign::PhantomKeysManager
#[must_use]
#[repr(C)]
pub struct PhantomRouteHints {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativePhantomRouteHints,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for PhantomRouteHints {
	type Target = nativePhantomRouteHints;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for PhantomRouteHints { }
unsafe impl core::marker::Sync for PhantomRouteHints { }
impl Drop for PhantomRouteHints {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativePhantomRouteHints>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the PhantomRouteHints, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn PhantomRouteHints_free(this_obj: PhantomRouteHints) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PhantomRouteHints_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativePhantomRouteHints) };
}
#[allow(unused)]
impl PhantomRouteHints {
	pub(crate) fn get_native_ref(&self) -> &'static nativePhantomRouteHints {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativePhantomRouteHints {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativePhantomRouteHints {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// The list of channels to be included in the invoice route hints.
#[no_mangle]
pub extern "C" fn PhantomRouteHints_get_channels(this_ptr: &PhantomRouteHints) -> crate::c_types::derived::CVec_ChannelDetailsZ {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().channels;
	let mut local_inner_val = Vec::new(); for item in inner_val.iter() { local_inner_val.push( { crate::lightning::ln::channel_state::ChannelDetails { inner: unsafe { ObjOps::nonnull_ptr_to_inner((item as *const lightning::ln::channel_state::ChannelDetails<>) as *mut _) }, is_owned: false } }); };
	local_inner_val.into()
}
/// The list of channels to be included in the invoice route hints.
#[no_mangle]
pub extern "C" fn PhantomRouteHints_set_channels(this_ptr: &mut PhantomRouteHints, mut val: crate::c_types::derived::CVec_ChannelDetailsZ) {
	let mut local_val = Vec::new(); for mut item in val.into_rust().drain(..) { local_val.push( { *unsafe { Box::from_raw(item.take_inner()) } }); };
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.channels = local_val;
}
/// A fake scid used for representing the phantom node's fake channel in generating the invoice
/// route hints.
#[no_mangle]
pub extern "C" fn PhantomRouteHints_get_phantom_scid(this_ptr: &PhantomRouteHints) -> u64 {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().phantom_scid;
	*inner_val
}
/// A fake scid used for representing the phantom node's fake channel in generating the invoice
/// route hints.
#[no_mangle]
pub extern "C" fn PhantomRouteHints_set_phantom_scid(this_ptr: &mut PhantomRouteHints, mut val: u64) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.phantom_scid = val;
}
/// The pubkey of the real backing node that would ultimately receive the payment.
#[no_mangle]
pub extern "C" fn PhantomRouteHints_get_real_node_pubkey(this_ptr: &PhantomRouteHints) -> crate::c_types::PublicKey {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().real_node_pubkey;
	crate::c_types::PublicKey::from_rust(&inner_val)
}
/// The pubkey of the real backing node that would ultimately receive the payment.
#[no_mangle]
pub extern "C" fn PhantomRouteHints_set_real_node_pubkey(this_ptr: &mut PhantomRouteHints, mut val: crate::c_types::PublicKey) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.real_node_pubkey = val.into_rust();
}
/// Constructs a new PhantomRouteHints given each field
#[must_use]
#[no_mangle]
pub extern "C" fn PhantomRouteHints_new(mut channels_arg: crate::c_types::derived::CVec_ChannelDetailsZ, mut phantom_scid_arg: u64, mut real_node_pubkey_arg: crate::c_types::PublicKey) -> PhantomRouteHints {
	let mut local_channels_arg = Vec::new(); for mut item in channels_arg.into_rust().drain(..) { local_channels_arg.push( { *unsafe { Box::from_raw(item.take_inner()) } }); };
	PhantomRouteHints { inner: ObjOps::heap_alloc(nativePhantomRouteHints {
		channels: local_channels_arg,
		phantom_scid: phantom_scid_arg,
		real_node_pubkey: real_node_pubkey_arg.into_rust(),
	}), is_owned: true }
}
impl Clone for PhantomRouteHints {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativePhantomRouteHints>::is_null(self.inner) { core::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PhantomRouteHints_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const nativePhantomRouteHints)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the PhantomRouteHints
pub extern "C" fn PhantomRouteHints_clone(orig: &PhantomRouteHints) -> PhantomRouteHints {
	orig.clone()
}
/// Constructs a new `ChannelManager` to hold several channels and route between them.
///
/// The current time or latest block header time can be provided as the `current_timestamp`.
///
/// This is the main \"logic hub\" for all channel-related actions, and implements
/// [`ChannelMessageHandler`].
///
/// Non-proportional fees are fixed according to our risk using the provided fee estimator.
///
/// Users need to notify the new `ChannelManager` when a new block is connected or
/// disconnected using its [`block_connected`] and [`block_disconnected`] methods, starting
/// from after [`params.best_block.block_hash`]. See [`chain::Listen`] and [`chain::Confirm`] for
/// more details.
///
/// [`block_connected`]: chain::Listen::block_connected
/// [`block_disconnected`]: chain::Listen::block_disconnected
/// [`params.best_block.block_hash`]: chain::BestBlock::block_hash
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_new(mut fee_est: crate::lightning::chain::chaininterface::FeeEstimator, mut chain_monitor: crate::lightning::chain::Watch, mut tx_broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut router: crate::lightning::routing::router::Router, mut message_router: crate::lightning::onion_message::messenger::MessageRouter, mut logger: crate::lightning::util::logger::Logger, mut entropy_source: crate::lightning::sign::EntropySource, mut node_signer: crate::lightning::sign::NodeSigner, mut signer_provider: crate::lightning::sign::SignerProvider, mut config: crate::lightning::util::config::UserConfig, mut params: crate::lightning::ln::channelmanager::ChainParameters, mut current_timestamp: u32) -> crate::lightning::ln::channelmanager::ChannelManager {
	let mut ret = lightning::ln::channelmanager::ChannelManager::new(fee_est, chain_monitor, tx_broadcaster, router, message_router, logger, entropy_source, node_signer, signer_provider, *unsafe { Box::from_raw(config.take_inner()) }, *unsafe { Box::from_raw(params.take_inner()) }, current_timestamp);
	crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Gets the current configuration applied to all new channels.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_get_current_default_configuration(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::lightning::util::config::UserConfig {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_current_default_configuration();
	crate::lightning::util::config::UserConfig { inner: unsafe { ObjOps::nonnull_ptr_to_inner((ret as *const lightning::util::config::UserConfig<>) as *mut _) }, is_owned: false }
}

/// Creates a new outbound channel to the given remote node and with the given value.
///
/// `user_channel_id` will be provided back as in
/// [`Event::FundingGenerationReady::user_channel_id`] to allow tracking of which events
/// correspond with which `create_channel` call. Note that the `user_channel_id` defaults to a
/// randomized value for inbound channels. `user_channel_id` has no meaning inside of LDK, it
/// is simply copied to events and otherwise ignored.
///
/// Raises [`APIError::APIMisuseError`] when `channel_value_satoshis` > 2**24 or `push_msat` is
/// greater than `channel_value_satoshis * 1k` or `channel_value_satoshis < 1000`.
///
/// Raises [`APIError::ChannelUnavailable`] if the channel cannot be opened due to failing to
/// generate a shutdown scriptpubkey or destination script set by
/// [`SignerProvider::get_shutdown_scriptpubkey`] or [`SignerProvider::get_destination_script`].
///
/// Note that we do not check if you are currently connected to the given peer. If no
/// connection is available, the outbound `open_channel` message may fail to send, resulting in
/// the channel eventually being silently forgotten (dropped on reload).
///
/// If `temporary_channel_id` is specified, it will be used as the temporary channel ID of the
/// channel. Otherwise, a random one will be generated for you.
///
/// Returns the new Channel's temporary `channel_id`. This ID will appear as
/// [`Event::FundingGenerationReady::temporary_channel_id`] and in
/// [`ChannelDetails::channel_id`] until after
/// [`ChannelManager::funding_transaction_generated`] is called, swapping the Channel's ID for
/// one derived from the funding transaction's TXID. If the counterparty rejects the channel
/// immediately, this temporary ID will appear in [`Event::ChannelClosed::channel_id`].
///
/// [`Event::FundingGenerationReady::user_channel_id`]: events::Event::FundingGenerationReady::user_channel_id
/// [`Event::FundingGenerationReady::temporary_channel_id`]: events::Event::FundingGenerationReady::temporary_channel_id
/// [`Event::ChannelClosed::channel_id`]: events::Event::ChannelClosed::channel_id
///
/// Note that temporary_channel_id (or a relevant inner pointer) may be NULL or all-0s to represent None
/// Note that override_config (or a relevant inner pointer) may be NULL or all-0s to represent None
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_create_channel(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut their_network_key: crate::c_types::PublicKey, mut channel_value_satoshis: u64, mut push_msat: u64, mut user_channel_id: crate::c_types::U128, mut temporary_channel_id: crate::lightning::ln::types::ChannelId, mut override_config: crate::lightning::util::config::UserConfig) -> crate::c_types::derived::CResult_ChannelIdAPIErrorZ {
	let mut local_temporary_channel_id = if temporary_channel_id.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(temporary_channel_id.take_inner()) } }) };
	let mut local_override_config = if override_config.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(override_config.take_inner()) } }) };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.create_channel(their_network_key.into_rust(), channel_value_satoshis, push_msat, user_channel_id.into(), local_temporary_channel_id, local_override_config);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::ln::types::ChannelId { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Gets the list of open channels, in random order. See [`ChannelDetails`] field documentation for
/// more information.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_list_channels(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::c_types::derived::CVec_ChannelDetailsZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.list_channels();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::ln::channel_state::ChannelDetails { inner: ObjOps::heap_alloc(item), is_owned: true } }); };
	local_ret.into()
}

/// Gets the list of usable channels, in random order. Useful as an argument to
/// [`Router::find_route`] to ensure non-announced channels are used.
///
/// These are guaranteed to have their [`ChannelDetails::is_usable`] value set to true, see the
/// documentation for [`ChannelDetails::is_usable`] for more info on exactly what the criteria
/// are.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_list_usable_channels(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::c_types::derived::CVec_ChannelDetailsZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.list_usable_channels();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::ln::channel_state::ChannelDetails { inner: ObjOps::heap_alloc(item), is_owned: true } }); };
	local_ret.into()
}

/// Gets the list of channels we have with a given counterparty, in random order.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_list_channels_with_counterparty(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut counterparty_node_id: crate::c_types::PublicKey) -> crate::c_types::derived::CVec_ChannelDetailsZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.list_channels_with_counterparty(&counterparty_node_id.into_rust());
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::ln::channel_state::ChannelDetails { inner: ObjOps::heap_alloc(item), is_owned: true } }); };
	local_ret.into()
}

/// Returns in an undefined order recent payments that -- if not fulfilled -- have yet to find a
/// successful path, or have unresolved HTLCs.
///
/// This can be useful for payments that may have been prepared, but ultimately not sent, as a
/// result of a crash. If such a payment exists, is not listed here, and an
/// [`Event::PaymentSent`] has not been received, you may consider resending the payment.
///
/// [`Event::PaymentSent`]: events::Event::PaymentSent
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_list_recent_payments(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::c_types::derived::CVec_RecentPaymentDetailsZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.list_recent_payments();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::ln::channelmanager::RecentPaymentDetails::native_into(item) }); };
	local_ret.into()
}

/// Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
/// will be accepted on the given channel, and after additional timeout/the closing of all
/// pending HTLCs, the channel will be closed on chain.
///
///  * If we are the channel initiator, we will pay between our [`ChannelCloseMinimum`] and
///    [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`NonAnchorChannelFee`]
///    fee estimate.
///  * If our counterparty is the channel initiator, we will require a channel closing
///    transaction feerate of at least our [`ChannelCloseMinimum`] feerate or the feerate which
///    would appear on a force-closure transaction, whichever is lower. We will allow our
///    counterparty to pay as much fee as they'd like, however.
///
/// May generate a [`SendShutdown`] message event on success, which should be relayed.
///
/// Raises [`APIError::ChannelUnavailable`] if the channel cannot be closed due to failing to
/// generate a shutdown scriptpubkey or destination script set by
/// [`SignerProvider::get_shutdown_scriptpubkey`]. A force-closure may be needed to close the
/// channel.
///
/// [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
/// [`ChannelCloseMinimum`]: crate::chain::chaininterface::ConfirmationTarget::ChannelCloseMinimum
/// [`NonAnchorChannelFee`]: crate::chain::chaininterface::ConfirmationTarget::NonAnchorChannelFee
/// [`SendShutdown`]: crate::events::MessageSendEvent::SendShutdown
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_close_channel(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, channel_id: &crate::lightning::ln::types::ChannelId, mut counterparty_node_id: crate::c_types::PublicKey) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.close_channel(channel_id.get_native_ref(), &counterparty_node_id.into_rust());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
/// will be accepted on the given channel, and after additional timeout/the closing of all
/// pending HTLCs, the channel will be closed on chain.
///
/// `target_feerate_sat_per_1000_weight` has different meanings depending on if we initiated
/// the channel being closed or not:
///  * If we are the channel initiator, we will pay at least this feerate on the closing
///    transaction. The upper-bound is set by
///    [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`NonAnchorChannelFee`]
///    fee estimate (or `target_feerate_sat_per_1000_weight`, if it is greater).
///  * If our counterparty is the channel initiator, we will refuse to accept a channel closure
///    transaction feerate below `target_feerate_sat_per_1000_weight` (or the feerate which
///    will appear on a force-closure transaction, whichever is lower).
///
/// The `shutdown_script` provided  will be used as the `scriptPubKey` for the closing transaction.
/// Will fail if a shutdown script has already been set for this channel by
/// ['ChannelHandshakeConfig::commit_upfront_shutdown_pubkey`]. The given shutdown script must
/// also be compatible with our and the counterparty's features.
///
/// May generate a [`SendShutdown`] message event on success, which should be relayed.
///
/// Raises [`APIError::ChannelUnavailable`] if the channel cannot be closed due to failing to
/// generate a shutdown scriptpubkey or destination script set by
/// [`SignerProvider::get_shutdown_scriptpubkey`]. A force-closure may be needed to close the
/// channel.
///
/// [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
/// [`NonAnchorChannelFee`]: crate::chain::chaininterface::ConfirmationTarget::NonAnchorChannelFee
/// [`SendShutdown`]: crate::events::MessageSendEvent::SendShutdown
///
/// Note that shutdown_script (or a relevant inner pointer) may be NULL or all-0s to represent None
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_close_channel_with_feerate_and_script(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, channel_id: &crate::lightning::ln::types::ChannelId, mut counterparty_node_id: crate::c_types::PublicKey, mut target_feerate_sats_per_1000_weight: crate::c_types::derived::COption_u32Z, mut shutdown_script: crate::lightning::ln::script::ShutdownScript) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut local_target_feerate_sats_per_1000_weight = if target_feerate_sats_per_1000_weight.is_some() { Some( { target_feerate_sats_per_1000_weight.take() }) } else { None };
	let mut local_shutdown_script = if shutdown_script.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(shutdown_script.take_inner()) } }) };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.close_channel_with_feerate_and_script(channel_id.get_native_ref(), &counterparty_node_id.into_rust(), local_target_feerate_sats_per_1000_weight, local_shutdown_script);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Force closes a channel, immediately broadcasting the latest local transaction(s),
/// rejecting new HTLCs.
///
/// The provided `error_message` is sent to connected peers for closing
/// channels and should be a human-readable description of what went wrong.
///
/// Fails if `channel_id` is unknown to the manager, or if the `counterparty_node_id`
/// isn't the counterparty of the corresponding channel.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_force_close_broadcasting_latest_txn(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, channel_id: &crate::lightning::ln::types::ChannelId, mut counterparty_node_id: crate::c_types::PublicKey, mut error_message: crate::c_types::Str) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.force_close_broadcasting_latest_txn(channel_id.get_native_ref(), &counterparty_node_id.into_rust(), error_message.into_string());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Force closes a channel, rejecting new HTLCs on the given channel but skips broadcasting
/// the latest local transaction(s).
///
/// The provided `error_message` is sent to connected peers for closing channels and should
/// be a human-readable description of what went wrong.
///
/// Fails if `channel_id` is unknown to the manager, or if the
/// `counterparty_node_id` isn't the counterparty of the corresponding channel.
/// You can always broadcast the latest local transaction(s) via
/// [`ChannelMonitor::broadcast_latest_holder_commitment_txn`].
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_force_close_without_broadcasting_txn(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, channel_id: &crate::lightning::ln::types::ChannelId, mut counterparty_node_id: crate::c_types::PublicKey, mut error_message: crate::c_types::Str) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.force_close_without_broadcasting_txn(channel_id.get_native_ref(), &counterparty_node_id.into_rust(), error_message.into_string());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Force close all channels, immediately broadcasting the latest local commitment transaction
/// for each to the chain and rejecting new HTLCs on each.
///
/// The provided `error_message` is sent to connected peers for closing channels and should
/// be a human-readable description of what went wrong.
#[no_mangle]
pub extern "C" fn ChannelManager_force_close_all_channels_broadcasting_latest_txn(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut error_message: crate::c_types::Str) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.force_close_all_channels_broadcasting_latest_txn(error_message.into_string())
}

/// Force close all channels rejecting new HTLCs on each but without broadcasting the latest
/// local transaction(s).
///
/// The provided `error_message` is sent to connected peers for closing channels and
/// should be a human-readable description of what went wrong.
#[no_mangle]
pub extern "C" fn ChannelManager_force_close_all_channels_without_broadcasting_txn(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut error_message: crate::c_types::Str) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.force_close_all_channels_without_broadcasting_txn(error_message.into_string())
}

/// Sends a payment along a given route. See [`Self::send_payment`] for more info.
///
/// LDK will not automatically retry this payment, though it may be manually re-sent after an
/// [`Event::PaymentFailed`] is generated.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_send_payment_with_route(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut route: crate::lightning::routing::router::Route, mut payment_hash: crate::c_types::ThirtyTwoBytes, mut recipient_onion: crate::lightning::ln::outbound_payment::RecipientOnionFields, mut payment_id: crate::c_types::ThirtyTwoBytes) -> crate::c_types::derived::CResult_NoneRetryableSendFailureZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.send_payment_with_route(*unsafe { Box::from_raw(route.take_inner()) }, ::lightning::types::payment::PaymentHash(payment_hash.data), *unsafe { Box::from_raw(recipient_onion.take_inner()) }, ::lightning::ln::channelmanager::PaymentId(payment_id.data));
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::outbound_payment::RetryableSendFailure::native_into(e) }).into() };
	local_ret
}

/// Sends a payment to the route found using the provided [`RouteParameters`], retrying failed
/// payment paths based on the provided `Retry`.
///
/// May generate [`UpdateHTLCs`] message(s) event on success, which should be relayed (e.g. via
/// [`PeerManager::process_events`]).
///
/// # Avoiding Duplicate Payments
///
/// If a pending payment is currently in-flight with the same [`PaymentId`] provided, this
/// method will error with [`RetryableSendFailure::DuplicatePayment`]. Note, however, that once a
/// payment is no longer pending (either via [`ChannelManager::abandon_payment`], or handling of
/// an [`Event::PaymentSent`] or [`Event::PaymentFailed`]) LDK will not stop you from sending a
/// second payment with the same [`PaymentId`].
///
/// Thus, in order to ensure duplicate payments are not sent, you should implement your own
/// tracking of payments, including state to indicate once a payment has completed. Because you
/// should also ensure that [`PaymentHash`]es are not re-used, for simplicity, you should
/// consider using the [`PaymentHash`] as the key for tracking payments. In that case, the
/// [`PaymentId`] should be a copy of the [`PaymentHash`] bytes.
///
/// Additionally, in the scenario where we begin the process of sending a payment, but crash
/// before `send_payment` returns (or prior to [`ChannelMonitorUpdate`] persistence if you're
/// using [`ChannelMonitorUpdateStatus::InProgress`]), the payment may be lost on restart. See
/// [`ChannelManager::list_recent_payments`] for more information.
///
/// Routes are automatically found using the [`Router] provided on startup. To fix a route for a
/// particular payment, use [`Self::send_payment_with_route`] or match the [`PaymentId`] passed to
/// [`Router::find_route_with_id`].
///
/// [`Event::PaymentSent`]: events::Event::PaymentSent
/// [`Event::PaymentFailed`]: events::Event::PaymentFailed
/// [`UpdateHTLCs`]: events::MessageSendEvent::UpdateHTLCs
/// [`PeerManager::process_events`]: crate::ln::peer_handler::PeerManager::process_events
/// [`ChannelMonitorUpdateStatus::InProgress`]: crate::chain::ChannelMonitorUpdateStatus::InProgress
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_send_payment(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut payment_hash: crate::c_types::ThirtyTwoBytes, mut recipient_onion: crate::lightning::ln::outbound_payment::RecipientOnionFields, mut payment_id: crate::c_types::ThirtyTwoBytes, mut route_params: crate::lightning::routing::router::RouteParameters, mut retry_strategy: crate::lightning::ln::outbound_payment::Retry) -> crate::c_types::derived::CResult_NoneRetryableSendFailureZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.send_payment(::lightning::types::payment::PaymentHash(payment_hash.data), *unsafe { Box::from_raw(recipient_onion.take_inner()) }, ::lightning::ln::channelmanager::PaymentId(payment_id.data), *unsafe { Box::from_raw(route_params.take_inner()) }, retry_strategy.into_native());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::outbound_payment::RetryableSendFailure::native_into(e) }).into() };
	local_ret
}

/// Pays the [`Bolt12Invoice`] associated with the `payment_id` encoded in its `payer_metadata`.
///
/// The invoice's `payer_metadata` is used to authenticate that the invoice was indeed requested
/// before attempting a payment. [`Bolt12PaymentError::UnexpectedInvoice`] is returned if this
/// fails or if the encoded `payment_id` is not recognized. The latter may happen once the
/// payment is no longer tracked because the payment was attempted after:
/// - an invoice for the `payment_id` was already paid,
/// - one full [timer tick] has elapsed since initially requesting the invoice when paying an
///   offer, or
/// - the refund corresponding to the invoice has already expired.
///
/// To retry the payment, request another invoice using a new `payment_id`.
///
/// Attempting to pay the same invoice twice while the first payment is still pending will
/// result in a [`Bolt12PaymentError::DuplicateInvoice`].
///
/// Otherwise, either [`Event::PaymentSent`] or [`Event::PaymentFailed`] are used to indicate
/// whether or not the payment was successful.
///
/// [timer tick]: Self::timer_tick_occurred
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_send_payment_for_bolt12_invoice(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, invoice: &crate::lightning::offers::invoice::Bolt12Invoice, mut context: crate::c_types::derived::COption_OffersContextZ) -> crate::c_types::derived::CResult_NoneBolt12PaymentErrorZ {
	let mut local_context = { /*context*/ let context_opt = context; if context_opt.is_none() { None } else { Some({ { { context_opt.take() }.into_native() }})} };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.send_payment_for_bolt12_invoice(invoice.get_native_ref(), local_context);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::outbound_payment::Bolt12PaymentError::native_into(e) }).into() };
	local_ret
}

/// Signals that no further attempts for the given payment should occur. Useful if you have a
/// pending outbound payment with retries remaining, but wish to stop retrying the payment before
/// retries are exhausted.
///
/// # Event Generation
///
/// If no [`Event::PaymentFailed`] event had been generated before, one will be generated as soon
/// as there are no remaining pending HTLCs for this payment.
///
/// Note that calling this method does *not* prevent a payment from succeeding. You must still
/// wait until you receive either a [`Event::PaymentFailed`] or [`Event::PaymentSent`] event to
/// determine the ultimate status of a payment.
///
/// # Requested Invoices
///
/// In the case of paying a [`Bolt12Invoice`] via [`ChannelManager::pay_for_offer`], abandoning
/// the payment prior to receiving the invoice will result in an [`Event::PaymentFailed`] and
/// prevent any attempts at paying it once received.
///
/// # Restart Behavior
///
/// If an [`Event::PaymentFailed`] is generated and we restart without first persisting the
/// [`ChannelManager`], another [`Event::PaymentFailed`] may be generated.
///
/// [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
#[no_mangle]
pub extern "C" fn ChannelManager_abandon_payment(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut payment_id: crate::c_types::ThirtyTwoBytes) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.abandon_payment(::lightning::ln::channelmanager::PaymentId(payment_id.data))
}

/// Send a spontaneous payment, which is a payment that does not require the recipient to have
/// generated an invoice. Optionally, you may specify the preimage. If you do choose to specify
/// the preimage, it must be a cryptographically secure random value that no intermediate node
/// would be able to guess -- otherwise, an intermediate node may claim the payment and it will
/// never reach the recipient.
///
/// Similar to regular payments, you MUST NOT reuse a `payment_preimage` value. See
/// [`send_payment`] for more information about the risks of duplicate preimage usage.
///
/// See [`send_payment`] documentation for more details on the idempotency guarantees provided by
/// the [`PaymentId`] key.
///
/// See [`PaymentParameters::for_keysend`] for help in constructing `route_params` for spontaneous
/// payments.
///
/// [`send_payment`]: Self::send_payment
/// [`PaymentParameters::for_keysend`]: crate::routing::router::PaymentParameters::for_keysend
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_send_spontaneous_payment(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut payment_preimage: crate::c_types::derived::COption_ThirtyTwoBytesZ, mut recipient_onion: crate::lightning::ln::outbound_payment::RecipientOnionFields, mut payment_id: crate::c_types::ThirtyTwoBytes, mut route_params: crate::lightning::routing::router::RouteParameters, mut retry_strategy: crate::lightning::ln::outbound_payment::Retry) -> crate::c_types::derived::CResult_ThirtyTwoBytesRetryableSendFailureZ {
	let mut local_payment_preimage = { /*payment_preimage*/ let payment_preimage_opt = payment_preimage; if payment_preimage_opt.is_none() { None } else { Some({ { ::lightning::types::payment::PaymentPreimage({ payment_preimage_opt.take() }.data) }})} };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.send_spontaneous_payment(local_payment_preimage, *unsafe { Box::from_raw(recipient_onion.take_inner()) }, ::lightning::ln::channelmanager::PaymentId(payment_id.data), *unsafe { Box::from_raw(route_params.take_inner()) }, retry_strategy.into_native());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::c_types::ThirtyTwoBytes { data: o.0 } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::outbound_payment::RetryableSendFailure::native_into(e) }).into() };
	local_ret
}

/// Send a payment that is probing the given route for liquidity. We calculate the
/// [`PaymentHash`] of probes based on a static secret and a random [`PaymentId`], which allows
/// us to easily discern them from real payments.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_send_probe(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut path: crate::lightning::routing::router::Path) -> crate::c_types::derived::CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.send_probe(*unsafe { Box::from_raw(path.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let (mut orig_ret_0_0, mut orig_ret_0_1) = o; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: orig_ret_0_0.0 }, crate::c_types::ThirtyTwoBytes { data: orig_ret_0_1.0 }).into(); local_ret_0 }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::outbound_payment::ProbeSendFailure::native_into(e) }).into() };
	local_ret
}

/// Sends payment probes over all paths of a route that would be used to pay the given
/// amount to the given `node_id`.
///
/// See [`ChannelManager::send_preflight_probes`] for more information.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_send_spontaneous_preflight_probes(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut node_id: crate::c_types::PublicKey, mut amount_msat: u64, mut final_cltv_expiry_delta: u32, mut liquidity_limit_multiplier: crate::c_types::derived::COption_u64Z) -> crate::c_types::derived::CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	let mut local_liquidity_limit_multiplier = if liquidity_limit_multiplier.is_some() { Some( { liquidity_limit_multiplier.take() }) } else { None };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.send_spontaneous_preflight_probes(node_id.into_rust(), amount_msat, final_cltv_expiry_delta, local_liquidity_limit_multiplier);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let mut local_ret_0 = Vec::new(); for mut item in o.drain(..) { local_ret_0.push( { let (mut orig_ret_0_0_0, mut orig_ret_0_0_1) = item; let mut local_ret_0_0 = (crate::c_types::ThirtyTwoBytes { data: orig_ret_0_0_0.0 }, crate::c_types::ThirtyTwoBytes { data: orig_ret_0_0_1.0 }).into(); local_ret_0_0 }); }; local_ret_0.into() }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::outbound_payment::ProbeSendFailure::native_into(e) }).into() };
	local_ret
}

/// Sends payment probes over all paths of a route that would be used to pay a route found
/// according to the given [`RouteParameters`].
///
/// This may be used to send \"pre-flight\" probes, i.e., to train our scorer before conducting
/// the actual payment. Note this is only useful if there likely is sufficient time for the
/// probe to settle before sending out the actual payment, e.g., when waiting for user
/// confirmation in a wallet UI.
///
/// Otherwise, there is a chance the probe could take up some liquidity needed to complete the
/// actual payment. Users should therefore be cautious and might avoid sending probes if
/// liquidity is scarce and/or they don't expect the probe to return before they send the
/// payment. To mitigate this issue, channels with available liquidity less than the required
/// amount times the given `liquidity_limit_multiplier` won't be used to send pre-flight
/// probes. If `None` is given as `liquidity_limit_multiplier`, it defaults to `3`.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_send_preflight_probes(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut route_params: crate::lightning::routing::router::RouteParameters, mut liquidity_limit_multiplier: crate::c_types::derived::COption_u64Z) -> crate::c_types::derived::CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	let mut local_liquidity_limit_multiplier = if liquidity_limit_multiplier.is_some() { Some( { liquidity_limit_multiplier.take() }) } else { None };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.send_preflight_probes(*unsafe { Box::from_raw(route_params.take_inner()) }, local_liquidity_limit_multiplier);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let mut local_ret_0 = Vec::new(); for mut item in o.drain(..) { local_ret_0.push( { let (mut orig_ret_0_0_0, mut orig_ret_0_0_1) = item; let mut local_ret_0_0 = (crate::c_types::ThirtyTwoBytes { data: orig_ret_0_0_0.0 }, crate::c_types::ThirtyTwoBytes { data: orig_ret_0_0_1.0 }).into(); local_ret_0_0 }); }; local_ret_0.into() }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::outbound_payment::ProbeSendFailure::native_into(e) }).into() };
	local_ret
}

/// Call this upon creation of a funding transaction for the given channel.
///
/// Returns an [`APIError::APIMisuseError`] if the funding_transaction spent non-SegWit outputs
/// or if no output was found which matches the parameters in [`Event::FundingGenerationReady`].
///
/// Returns [`APIError::APIMisuseError`] if the funding transaction is not final for propagation
/// across the p2p network.
///
/// Returns [`APIError::ChannelUnavailable`] if a funding transaction has already been provided
/// for the channel or if the channel has been closed as indicated by [`Event::ChannelClosed`].
///
/// May panic if the output found in the funding transaction is duplicative with some other
/// channel (note that this should be trivially prevented by using unique funding transaction
/// keys per-channel).
///
/// Do NOT broadcast the funding transaction yourself. When we have safely received our
/// counterparty's signature the funding transaction will automatically be broadcast via the
/// [`BroadcasterInterface`] provided when this `ChannelManager` was constructed.
///
/// Note that this includes RBF or similar transaction replacement strategies - lightning does
/// not currently support replacing a funding transaction on an existing channel. Instead,
/// create a new channel with a conflicting funding transaction.
///
/// Note to keep the miner incentives aligned in moving the blockchain forward, we recommend
/// the wallet software generating the funding transaction to apply anti-fee sniping as
/// implemented by Bitcoin Core wallet. See <https://bitcoinops.org/en/topics/fee-sniping/>
/// for more details.
///
/// [`Event::FundingGenerationReady`]: crate::events::Event::FundingGenerationReady
/// [`Event::ChannelClosed`]: crate::events::Event::ChannelClosed
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_funding_transaction_generated(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut temporary_channel_id: crate::lightning::ln::types::ChannelId, mut counterparty_node_id: crate::c_types::PublicKey, mut funding_transaction: crate::c_types::Transaction) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.funding_transaction_generated(*unsafe { Box::from_raw(temporary_channel_id.take_inner()) }, counterparty_node_id.into_rust(), funding_transaction.into_bitcoin());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// **Unsafe**: This method does not validate the spent output. It is the caller's
/// responsibility to ensure the spent outputs are SegWit, as well as making sure the funding
/// transaction has a final absolute locktime, i.e., its locktime is lower than the next block height.
///
/// For a safer method, please refer to [`ChannelManager::funding_transaction_generated`].
///
/// Call this in response to a [`Event::FundingGenerationReady`] event.
///
/// Note that if this method is called successfully, the funding transaction won't be
/// broadcasted and you are expected to broadcast it manually when receiving the
/// [`Event::FundingTxBroadcastSafe`] event.
///
/// Returns [`APIError::ChannelUnavailable`] if a funding transaction has already been provided
/// for the channel or if the channel has been closed as indicated by [`Event::ChannelClosed`].
///
/// May panic if the funding output is duplicative with some other channel (note that this
/// should be trivially prevented by using unique funding transaction keys per-channel).
///
/// Note to keep the miner incentives aligned in moving the blockchain forward, we recommend
/// the wallet software generating the funding transaction to apply anti-fee sniping as
/// implemented by Bitcoin Core wallet. See <https://bitcoinops.org/en/topics/fee-sniping/> for
/// more details.
///
/// [`Event::FundingGenerationReady`]: crate::events::Event::FundingGenerationReady
/// [`Event::FundingTxBroadcastSafe`]: crate::events::Event::FundingTxBroadcastSafe
/// [`Event::ChannelClosed`]: crate::events::Event::ChannelClosed
/// [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_unsafe_manual_funding_transaction_generated(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut temporary_channel_id: crate::lightning::ln::types::ChannelId, mut counterparty_node_id: crate::c_types::PublicKey, mut funding: crate::lightning::chain::transaction::OutPoint) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.unsafe_manual_funding_transaction_generated(*unsafe { Box::from_raw(temporary_channel_id.take_inner()) }, counterparty_node_id.into_rust(), *unsafe { Box::from_raw(funding.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Call this upon creation of a batch funding transaction for the given channels.
///
/// Return values are identical to [`Self::funding_transaction_generated`], respective to
/// each individual channel and transaction output.
///
/// Do NOT broadcast the funding transaction yourself. This batch funding transaction
/// will only be broadcast when we have safely received and persisted the counterparty's
/// signature for each channel.
///
/// If there is an error, all channels in the batch are to be considered closed.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_batch_funding_transaction_generated(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut temporary_channels: crate::c_types::derived::CVec_C2Tuple_ChannelIdPublicKeyZZ, mut funding_transaction: crate::c_types::Transaction) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut local_temporary_channels = Vec::new(); for mut item in temporary_channels.into_rust().drain(..) { local_temporary_channels.push( { let (mut orig_temporary_channels_0_0, mut orig_temporary_channels_0_1) = item.to_rust(); let mut local_temporary_channels_0 = (*unsafe { Box::from_raw(orig_temporary_channels_0_0.take_inner()) }, orig_temporary_channels_0_1.into_rust()); local_temporary_channels_0 }); };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.batch_funding_transaction_generated(&local_temporary_channels.iter().map(|(a, b)| (a, b)).collect::<Vec<_>>()[..], funding_transaction.into_bitcoin());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Atomically applies partial updates to the [`ChannelConfig`] of the given channels.
///
/// Once the updates are applied, each eligible channel (advertised with a known short channel
/// ID and a change in [`forwarding_fee_proportional_millionths`], [`forwarding_fee_base_msat`],
/// or [`cltv_expiry_delta`]) has a [`BroadcastChannelUpdate`] event message generated
/// containing the new [`ChannelUpdate`] message which should be broadcast to the network.
///
/// Returns [`ChannelUnavailable`] when a channel is not found or an incorrect
/// `counterparty_node_id` is provided.
///
/// Returns [`APIMisuseError`] when a [`cltv_expiry_delta`] update is to be applied with a value
/// below [`MIN_CLTV_EXPIRY_DELTA`].
///
/// If an error is returned, none of the updates should be considered applied.
///
/// [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
/// [`forwarding_fee_base_msat`]: ChannelConfig::forwarding_fee_base_msat
/// [`cltv_expiry_delta`]: ChannelConfig::cltv_expiry_delta
/// [`BroadcastChannelUpdate`]: events::MessageSendEvent::BroadcastChannelUpdate
/// [`ChannelUpdate`]: msgs::ChannelUpdate
/// [`ChannelUnavailable`]: APIError::ChannelUnavailable
/// [`APIMisuseError`]: APIError::APIMisuseError
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_update_partial_channel_config(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut counterparty_node_id: crate::c_types::PublicKey, mut channel_ids: crate::c_types::derived::CVec_ChannelIdZ, config_update: &crate::lightning::util::config::ChannelConfigUpdate) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut local_channel_ids = Vec::new(); for mut item in channel_ids.into_rust().drain(..) { local_channel_ids.push( { *unsafe { Box::from_raw(item.take_inner()) } }); };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.update_partial_channel_config(&counterparty_node_id.into_rust(), local_channel_ids, config_update.get_native_ref());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Atomically updates the [`ChannelConfig`] for the given channels.
///
/// Once the updates are applied, each eligible channel (advertised with a known short channel
/// ID and a change in [`forwarding_fee_proportional_millionths`], [`forwarding_fee_base_msat`],
/// or [`cltv_expiry_delta`]) has a [`BroadcastChannelUpdate`] event message generated
/// containing the new [`ChannelUpdate`] message which should be broadcast to the network.
///
/// Returns [`ChannelUnavailable`] when a channel is not found or an incorrect
/// `counterparty_node_id` is provided.
///
/// Returns [`APIMisuseError`] when a [`cltv_expiry_delta`] update is to be applied with a value
/// below [`MIN_CLTV_EXPIRY_DELTA`].
///
/// If an error is returned, none of the updates should be considered applied.
///
/// [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
/// [`forwarding_fee_base_msat`]: ChannelConfig::forwarding_fee_base_msat
/// [`cltv_expiry_delta`]: ChannelConfig::cltv_expiry_delta
/// [`BroadcastChannelUpdate`]: events::MessageSendEvent::BroadcastChannelUpdate
/// [`ChannelUpdate`]: msgs::ChannelUpdate
/// [`ChannelUnavailable`]: APIError::ChannelUnavailable
/// [`APIMisuseError`]: APIError::APIMisuseError
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_update_channel_config(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut counterparty_node_id: crate::c_types::PublicKey, mut channel_ids: crate::c_types::derived::CVec_ChannelIdZ, config: &crate::lightning::util::config::ChannelConfig) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut local_channel_ids = Vec::new(); for mut item in channel_ids.into_rust().drain(..) { local_channel_ids.push( { *unsafe { Box::from_raw(item.take_inner()) } }); };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.update_channel_config(&counterparty_node_id.into_rust(), local_channel_ids, config.get_native_ref());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Attempts to forward an intercepted HTLC over the provided channel id and with the provided
/// amount to forward. Should only be called in response to an [`HTLCIntercepted`] event.
///
/// Intercepted HTLCs can be useful for Lightning Service Providers (LSPs) to open a just-in-time
/// channel to a receiving node if the node lacks sufficient inbound liquidity.
///
/// To make use of intercepted HTLCs, set [`UserConfig::accept_intercept_htlcs`] and use
/// [`ChannelManager::get_intercept_scid`] to generate short channel id(s) to put in the
/// receiver's invoice route hints. These route hints will signal to LDK to generate an
/// [`HTLCIntercepted`] event when it receives the forwarded HTLC, and this method or
/// [`ChannelManager::fail_intercepted_htlc`] MUST be called in response to the event.
///
/// Note that LDK does not enforce fee requirements in `amt_to_forward_msat`, and will not stop
/// you from forwarding more than you received. See
/// [`HTLCIntercepted::expected_outbound_amount_msat`] for more on forwarding a different amount
/// than expected.
///
/// Errors if the event was not handled in time, in which case the HTLC was automatically failed
/// backwards.
///
/// [`UserConfig::accept_intercept_htlcs`]: crate::util::config::UserConfig::accept_intercept_htlcs
/// [`HTLCIntercepted`]: events::Event::HTLCIntercepted
/// [`HTLCIntercepted::expected_outbound_amount_msat`]: events::Event::HTLCIntercepted::expected_outbound_amount_msat
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_forward_intercepted_htlc(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut intercept_id: crate::c_types::ThirtyTwoBytes, next_hop_channel_id: &crate::lightning::ln::types::ChannelId, mut next_node_id: crate::c_types::PublicKey, mut amt_to_forward_msat: u64) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.forward_intercepted_htlc(::lightning::ln::channelmanager::InterceptId(intercept_id.data), next_hop_channel_id.get_native_ref(), next_node_id.into_rust(), amt_to_forward_msat);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Fails the intercepted HTLC indicated by intercept_id. Should only be called in response to
/// an [`HTLCIntercepted`] event. See [`ChannelManager::forward_intercepted_htlc`].
///
/// Errors if the event was not handled in time, in which case the HTLC was automatically failed
/// backwards.
///
/// [`HTLCIntercepted`]: events::Event::HTLCIntercepted
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_fail_intercepted_htlc(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut intercept_id: crate::c_types::ThirtyTwoBytes) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.fail_intercepted_htlc(::lightning::ln::channelmanager::InterceptId(intercept_id.data));
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Processes HTLCs which are pending waiting on random forward delay.
///
/// Should only really ever be called in response to a PendingHTLCsForwardable event.
/// Will likely generate further events.
#[no_mangle]
pub extern "C" fn ChannelManager_process_pending_htlc_forwards(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.process_pending_htlc_forwards()
}

/// Performs actions which should happen on startup and roughly once per minute thereafter.
///
/// This currently includes:
///  * Increasing or decreasing the on-chain feerate estimates for our outbound channels,
///  * Broadcasting [`ChannelUpdate`] messages if we've been disconnected from our peer for more
///    than a minute, informing the network that they should no longer attempt to route over
///    the channel.
///  * Expiring a channel's previous [`ChannelConfig`] if necessary to only allow forwarding HTLCs
///    with the current [`ChannelConfig`].
///  * Removing peers which have disconnected but and no longer have any channels.
///  * Force-closing and removing channels which have not completed establishment in a timely manner.
///  * Forgetting about stale outbound payments, either those that have already been fulfilled
///    or those awaiting an invoice that hasn't been delivered in the necessary amount of time.
///    The latter is determined using the system clock in `std` and the highest seen block time
///    minus two hours in non-`std`.
///
/// Note that this may cause reentrancy through [`chain::Watch::update_channel`] calls or feerate
/// estimate fetches.
///
/// [`ChannelUpdate`]: msgs::ChannelUpdate
/// [`ChannelConfig`]: crate::util::config::ChannelConfig
#[no_mangle]
pub extern "C" fn ChannelManager_timer_tick_occurred(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.timer_tick_occurred()
}

/// Indicates that the preimage for payment_hash is unknown or the received amount is incorrect
/// after a PaymentClaimable event, failing the HTLC back to its origin and freeing resources
/// along the path (including in our own channel on which we received it).
///
/// Note that in some cases around unclean shutdown, it is possible the payment may have
/// already been claimed by you via [`ChannelManager::claim_funds`] prior to you seeing (a
/// second copy of) the [`events::Event::PaymentClaimable`] event. Alternatively, the payment
/// may have already been failed automatically by LDK if it was nearing its expiration time.
///
/// While LDK will never claim a payment automatically on your behalf (i.e. without you calling
/// [`ChannelManager::claim_funds`]), you should still monitor for
/// [`events::Event::PaymentClaimed`] events even for payments you intend to fail, especially on
/// startup during which time claims that were in-progress at shutdown may be replayed.
#[no_mangle]
pub extern "C" fn ChannelManager_fail_htlc_backwards(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, payment_hash: *const [u8; 32]) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.fail_htlc_backwards(&::lightning::types::payment::PaymentHash(unsafe { *payment_hash }))
}

/// This is a variant of [`ChannelManager::fail_htlc_backwards`] that allows you to specify the
/// reason for the failure.
///
/// See [`FailureCode`] for valid failure codes.
#[no_mangle]
pub extern "C" fn ChannelManager_fail_htlc_backwards_with_reason(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, payment_hash: *const [u8; 32], mut failure_code: crate::lightning::ln::channelmanager::FailureCode) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.fail_htlc_backwards_with_reason(&::lightning::types::payment::PaymentHash(unsafe { *payment_hash }), failure_code.into_native())
}

/// Provides a payment preimage in response to [`Event::PaymentClaimable`], generating any
/// [`MessageSendEvent`]s needed to claim the payment.
///
/// This method is guaranteed to ensure the payment has been claimed but only if the current
/// height is strictly below [`Event::PaymentClaimable::claim_deadline`]. To avoid race
/// conditions, you should wait for an [`Event::PaymentClaimed`] before considering the payment
/// successful. It will generally be available in the next [`process_pending_events`] call.
///
/// Note that if you did not set an `amount_msat` when calling [`create_inbound_payment`] or
/// [`create_inbound_payment_for_hash`] you must check that the amount in the `PaymentClaimable`
/// event matches your expectation. If you fail to do so and call this method, you may provide
/// the sender \"proof-of-payment\" when they did not fulfill the full expected payment.
///
/// This function will fail the payment if it has custom TLVs with even type numbers, as we
/// will assume they are unknown. If you intend to accept even custom TLVs, you should use
/// [`claim_funds_with_known_custom_tlvs`].
///
/// [`Event::PaymentClaimable`]: crate::events::Event::PaymentClaimable
/// [`Event::PaymentClaimable::claim_deadline`]: crate::events::Event::PaymentClaimable::claim_deadline
/// [`Event::PaymentClaimed`]: crate::events::Event::PaymentClaimed
/// [`process_pending_events`]: EventsProvider::process_pending_events
/// [`create_inbound_payment`]: Self::create_inbound_payment
/// [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
/// [`claim_funds_with_known_custom_tlvs`]: Self::claim_funds_with_known_custom_tlvs
#[no_mangle]
pub extern "C" fn ChannelManager_claim_funds(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut payment_preimage: crate::c_types::ThirtyTwoBytes) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.claim_funds(::lightning::types::payment::PaymentPreimage(payment_preimage.data))
}

/// This is a variant of [`claim_funds`] that allows accepting a payment with custom TLVs with
/// even type numbers.
///
/// # Note
///
/// You MUST check you've understood all even TLVs before using this to
/// claim, otherwise you may unintentionally agree to some protocol you do not understand.
///
/// [`claim_funds`]: Self::claim_funds
#[no_mangle]
pub extern "C" fn ChannelManager_claim_funds_with_known_custom_tlvs(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut payment_preimage: crate::c_types::ThirtyTwoBytes) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.claim_funds_with_known_custom_tlvs(::lightning::types::payment::PaymentPreimage(payment_preimage.data))
}

/// Gets the node_id held by this ChannelManager
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_get_our_node_id(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::c_types::PublicKey {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_our_node_id();
	crate::c_types::PublicKey::from_rust(&ret)
}

/// Accepts a request to open a channel after a [`Event::OpenChannelRequest`].
///
/// The `temporary_channel_id` parameter indicates which inbound channel should be accepted,
/// and the `counterparty_node_id` parameter is the id of the peer which has requested to open
/// the channel.
///
/// The `user_channel_id` parameter will be provided back in
/// [`Event::ChannelClosed::user_channel_id`] to allow tracking of which events correspond
/// with which `accept_inbound_channel`/`accept_inbound_channel_from_trusted_peer_0conf` call.
///
/// Note that this method will return an error and reject the channel, if it requires support
/// for zero confirmations. Instead, `accept_inbound_channel_from_trusted_peer_0conf` must be
/// used to accept such channels.
///
/// NOTE: LDK makes no attempt to prevent the counterparty from using non-standard inputs which
/// will prevent the funding transaction from being relayed on the bitcoin network and hence being
/// confirmed.
///
/// [`Event::OpenChannelRequest`]: events::Event::OpenChannelRequest
/// [`Event::ChannelClosed::user_channel_id`]: events::Event::ChannelClosed::user_channel_id
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_accept_inbound_channel(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, temporary_channel_id: &crate::lightning::ln::types::ChannelId, mut counterparty_node_id: crate::c_types::PublicKey, mut user_channel_id: crate::c_types::U128) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.accept_inbound_channel(temporary_channel_id.get_native_ref(), &counterparty_node_id.into_rust(), user_channel_id.into());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Accepts a request to open a channel after a [`events::Event::OpenChannelRequest`], treating
/// it as confirmed immediately.
///
/// The `user_channel_id` parameter will be provided back in
/// [`Event::ChannelClosed::user_channel_id`] to allow tracking of which events correspond
/// with which `accept_inbound_channel`/`accept_inbound_channel_from_trusted_peer_0conf` call.
///
/// Unlike [`ChannelManager::accept_inbound_channel`], this method accepts the incoming channel
/// and (if the counterparty agrees), enables forwarding of payments immediately.
///
/// This fully trusts that the counterparty has honestly and correctly constructed the funding
/// transaction and blindly assumes that it will eventually confirm.
///
/// If it does not confirm before we decide to close the channel, or if the funding transaction
/// does not pay to the correct script the correct amount, *you will lose funds*.
///
/// [`Event::OpenChannelRequest`]: events::Event::OpenChannelRequest
/// [`Event::ChannelClosed::user_channel_id`]: events::Event::ChannelClosed::user_channel_id
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_accept_inbound_channel_from_trusted_peer_0conf(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, temporary_channel_id: &crate::lightning::ln::types::ChannelId, mut counterparty_node_id: crate::c_types::PublicKey, mut user_channel_id: crate::c_types::U128) -> crate::c_types::derived::CResult_NoneAPIErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.accept_inbound_channel_from_trusted_peer_0conf(temporary_channel_id.get_native_ref(), &counterparty_node_id.into_rust(), user_channel_id.into());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// When a call to a [`ChannelSigner`] method returns an error, this indicates that the signer
/// is (temporarily) unavailable, and the operation should be retried later.
///
/// This method allows for that retry - either checking for any signer-pending messages to be
/// attempted in every channel, or in the specifically provided channel.
///
/// [`ChannelSigner`]: crate::sign::ChannelSigner
#[no_mangle]
pub extern "C" fn ChannelManager_signer_unblocked(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut channel_opt: crate::c_types::derived::COption_C2Tuple_PublicKeyChannelIdZZ) {
	let mut local_channel_opt = if channel_opt.is_some() { Some( { let (mut orig_channel_opt_0_0, mut orig_channel_opt_0_1) = channel_opt.take().to_rust(); let mut local_channel_opt_0 = (orig_channel_opt_0_0.into_rust(), *unsafe { Box::from_raw(orig_channel_opt_0_1.take_inner()) }); local_channel_opt_0 }) } else { None };
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.signer_unblocked(local_channel_opt)
}

/// Utility for creating a BOLT11 invoice that can be verified by [`ChannelManager`] without
/// storing any additional state. It achieves this by including a [`PaymentSecret`] in the
/// invoice which it uses to verify that the invoice has not expired and the payment amount is
/// sufficient, reproducing the [`PaymentPreimage`] if applicable.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_create_bolt11_invoice(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut params: crate::lightning::ln::channelmanager::Bolt11InvoiceParameters) -> crate::c_types::derived::CResult_Bolt11InvoiceSignOrCreationErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.create_bolt11_invoice(*unsafe { Box::from_raw(params.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning_invoice::Bolt11Invoice { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning_invoice::SignOrCreationError::native_into(e) }).into() };
	local_ret
}


use lightning::ln::channelmanager::Bolt11InvoiceParameters as nativeBolt11InvoiceParametersImport;
pub(crate) type nativeBolt11InvoiceParameters = nativeBolt11InvoiceParametersImport;

/// Parameters used with [`create_bolt11_invoice`].
///
/// [`create_bolt11_invoice`]: ChannelManager::create_bolt11_invoice
#[must_use]
#[repr(C)]
pub struct Bolt11InvoiceParameters {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeBolt11InvoiceParameters,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for Bolt11InvoiceParameters {
	type Target = nativeBolt11InvoiceParameters;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for Bolt11InvoiceParameters { }
unsafe impl core::marker::Sync for Bolt11InvoiceParameters { }
impl Drop for Bolt11InvoiceParameters {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeBolt11InvoiceParameters>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the Bolt11InvoiceParameters, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_free(this_obj: Bolt11InvoiceParameters) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn Bolt11InvoiceParameters_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeBolt11InvoiceParameters) };
}
#[allow(unused)]
impl Bolt11InvoiceParameters {
	pub(crate) fn get_native_ref(&self) -> &'static nativeBolt11InvoiceParameters {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeBolt11InvoiceParameters {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeBolt11InvoiceParameters {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// The amount for the invoice, if any.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_get_amount_msats(this_ptr: &Bolt11InvoiceParameters) -> crate::c_types::derived::COption_u64Z {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().amount_msats;
	let mut local_inner_val = if inner_val.is_none() { crate::c_types::derived::COption_u64Z::None } else { crate::c_types::derived::COption_u64Z::Some( { inner_val.unwrap() }) };
	local_inner_val
}
/// The amount for the invoice, if any.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_set_amount_msats(this_ptr: &mut Bolt11InvoiceParameters, mut val: crate::c_types::derived::COption_u64Z) {
	let mut local_val = if val.is_some() { Some( { val.take() }) } else { None };
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.amount_msats = local_val;
}
/// The description for what the invoice is for, or hash of such description.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_get_description(this_ptr: &Bolt11InvoiceParameters) -> crate::lightning_invoice::Bolt11InvoiceDescription {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().description;
	crate::lightning_invoice::Bolt11InvoiceDescription::from_native(inner_val)
}
/// The description for what the invoice is for, or hash of such description.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_set_description(this_ptr: &mut Bolt11InvoiceParameters, mut val: crate::lightning_invoice::Bolt11InvoiceDescription) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.description = val.into_native();
}
/// The invoice expiration relative to its creation time. If not set, the invoice will expire in
/// [`DEFAULT_EXPIRY_TIME`] by default.
///
/// The creation time used is the duration since the Unix epoch for `std` builds. For non-`std`
/// builds, the highest block timestamp seen is used instead. In the latter case, use a long
/// enough expiry to account for the average block time.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_get_invoice_expiry_delta_secs(this_ptr: &Bolt11InvoiceParameters) -> crate::c_types::derived::COption_u32Z {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().invoice_expiry_delta_secs;
	let mut local_inner_val = if inner_val.is_none() { crate::c_types::derived::COption_u32Z::None } else { crate::c_types::derived::COption_u32Z::Some( { inner_val.unwrap() }) };
	local_inner_val
}
/// The invoice expiration relative to its creation time. If not set, the invoice will expire in
/// [`DEFAULT_EXPIRY_TIME`] by default.
///
/// The creation time used is the duration since the Unix epoch for `std` builds. For non-`std`
/// builds, the highest block timestamp seen is used instead. In the latter case, use a long
/// enough expiry to account for the average block time.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_set_invoice_expiry_delta_secs(this_ptr: &mut Bolt11InvoiceParameters, mut val: crate::c_types::derived::COption_u32Z) {
	let mut local_val = if val.is_some() { Some( { val.take() }) } else { None };
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.invoice_expiry_delta_secs = local_val;
}
/// The minimum `cltv_expiry` for the last HTLC in the route. If not set, will use
/// [`MIN_FINAL_CLTV_EXPIRY_DELTA`].
///
/// If set, must be at least [`MIN_FINAL_CLTV_EXPIRY_DELTA`], and a three-block buffer will be
/// added as well to allow for up to a few new block confirmations during routing.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_get_min_final_cltv_expiry_delta(this_ptr: &Bolt11InvoiceParameters) -> crate::c_types::derived::COption_u16Z {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().min_final_cltv_expiry_delta;
	let mut local_inner_val = if inner_val.is_none() { crate::c_types::derived::COption_u16Z::None } else { crate::c_types::derived::COption_u16Z::Some( { inner_val.unwrap() }) };
	local_inner_val
}
/// The minimum `cltv_expiry` for the last HTLC in the route. If not set, will use
/// [`MIN_FINAL_CLTV_EXPIRY_DELTA`].
///
/// If set, must be at least [`MIN_FINAL_CLTV_EXPIRY_DELTA`], and a three-block buffer will be
/// added as well to allow for up to a few new block confirmations during routing.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_set_min_final_cltv_expiry_delta(this_ptr: &mut Bolt11InvoiceParameters, mut val: crate::c_types::derived::COption_u16Z) {
	let mut local_val = if val.is_some() { Some( { val.take() }) } else { None };
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.min_final_cltv_expiry_delta = local_val;
}
/// The payment hash used in the invoice. If not set, a payment hash will be generated using a
/// preimage that can be reproduced by [`ChannelManager`] without storing any state.
///
/// Uses the payment hash if set. This may be useful if you're building an on-chain swap or
/// involving another protocol where the payment hash is also involved outside the scope of
/// lightning.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_get_payment_hash(this_ptr: &Bolt11InvoiceParameters) -> crate::c_types::derived::COption_ThirtyTwoBytesZ {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().payment_hash;
	let mut local_inner_val = if inner_val.is_none() { crate::c_types::derived::COption_ThirtyTwoBytesZ::None } else { crate::c_types::derived::COption_ThirtyTwoBytesZ::Some(/* WARNING: CLONING CONVERSION HERE! &Option<Enum> is otherwise un-expressable. */ { crate::c_types::ThirtyTwoBytes { data: (*inner_val.as_ref().unwrap()).clone().0 } }) };
	local_inner_val
}
/// The payment hash used in the invoice. If not set, a payment hash will be generated using a
/// preimage that can be reproduced by [`ChannelManager`] without storing any state.
///
/// Uses the payment hash if set. This may be useful if you're building an on-chain swap or
/// involving another protocol where the payment hash is also involved outside the scope of
/// lightning.
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_set_payment_hash(this_ptr: &mut Bolt11InvoiceParameters, mut val: crate::c_types::derived::COption_ThirtyTwoBytesZ) {
	let mut local_val = { /*val*/ let val_opt = val; if val_opt.is_none() { None } else { Some({ { ::lightning::types::payment::PaymentHash({ val_opt.take() }.data) }})} };
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.payment_hash = local_val;
}
/// Constructs a new Bolt11InvoiceParameters given each field
#[must_use]
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_new(mut amount_msats_arg: crate::c_types::derived::COption_u64Z, mut description_arg: crate::lightning_invoice::Bolt11InvoiceDescription, mut invoice_expiry_delta_secs_arg: crate::c_types::derived::COption_u32Z, mut min_final_cltv_expiry_delta_arg: crate::c_types::derived::COption_u16Z, mut payment_hash_arg: crate::c_types::derived::COption_ThirtyTwoBytesZ) -> Bolt11InvoiceParameters {
	let mut local_amount_msats_arg = if amount_msats_arg.is_some() { Some( { amount_msats_arg.take() }) } else { None };
	let mut local_invoice_expiry_delta_secs_arg = if invoice_expiry_delta_secs_arg.is_some() { Some( { invoice_expiry_delta_secs_arg.take() }) } else { None };
	let mut local_min_final_cltv_expiry_delta_arg = if min_final_cltv_expiry_delta_arg.is_some() { Some( { min_final_cltv_expiry_delta_arg.take() }) } else { None };
	let mut local_payment_hash_arg = { /*payment_hash_arg*/ let payment_hash_arg_opt = payment_hash_arg; if payment_hash_arg_opt.is_none() { None } else { Some({ { ::lightning::types::payment::PaymentHash({ payment_hash_arg_opt.take() }.data) }})} };
	Bolt11InvoiceParameters { inner: ObjOps::heap_alloc(nativeBolt11InvoiceParameters {
		amount_msats: local_amount_msats_arg,
		description: description_arg.into_native(),
		invoice_expiry_delta_secs: local_invoice_expiry_delta_secs_arg,
		min_final_cltv_expiry_delta: local_min_final_cltv_expiry_delta_arg,
		payment_hash: local_payment_hash_arg,
	}), is_owned: true }
}
/// Creates a "default" Bolt11InvoiceParameters. See struct and individual field documentaiton for details on which values are used.
#[must_use]
#[no_mangle]
pub extern "C" fn Bolt11InvoiceParameters_default() -> Bolt11InvoiceParameters {
	Bolt11InvoiceParameters { inner: ObjOps::heap_alloc(Default::default()), is_owned: true }
}
/// Creates an [`OfferBuilder`] such that the [`Offer`] it builds is recognized by the
/// [`ChannelManager`] when handling [`InvoiceRequest`] messages for the offer. The offer's
/// expiration will be `absolute_expiry` if `Some`, otherwise it will not expire.
///
/// # Privacy
///
/// Uses [`MessageRouter`] to construct a [`BlindedMessagePath`] for the offer based on the given
/// `absolute_expiry` according to [`MAX_SHORT_LIVED_RELATIVE_EXPIRY`]. See those docs for
/// privacy implications as well as those of the parameterized [`Router`], which implements
/// [`MessageRouter`].
///
/// Also, uses a derived signing pubkey in the offer for recipient privacy.
///
/// # Limitations
///
/// Requires a direct connection to the introduction node in the responding [`InvoiceRequest`]'s
/// reply path.
///
/// # Errors
///
/// Errors if the parameterized [`Router`] is unable to create a blinded path for the offer.
///
/// [`Offer`]: crate::offers::offer::Offer
/// [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_create_offer_builder(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut absolute_expiry: crate::c_types::derived::COption_u64Z) -> crate::c_types::derived::CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	let mut local_absolute_expiry = { /*absolute_expiry*/ let absolute_expiry_opt = absolute_expiry; if absolute_expiry_opt.is_none() { None } else { Some({ { core::time::Duration::from_secs({ absolute_expiry_opt.take() }) }})} };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.create_offer_builder(local_absolute_expiry);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::offers::offer::OfferWithDerivedMetadataBuilder { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::offers::parse::Bolt12SemanticError::native_into(e) }).into() };
	local_ret
}

/// Creates a [`RefundBuilder`] such that the [`Refund`] it builds is recognized by the
/// [`ChannelManager`] when handling [`Bolt12Invoice`] messages for the refund.
///
/// # Payment
///
/// The provided `payment_id` is used to ensure that only one invoice is paid for the refund.
/// See [Avoiding Duplicate Payments] for other requirements once the payment has been sent.
///
/// The builder will have the provided expiration set. Any changes to the expiration on the
/// returned builder will not be honored by [`ChannelManager`]. For non-`std`, the highest seen
/// block time minus two hours is used for the current time when determining if the refund has
/// expired.
///
/// To revoke the refund, use [`ChannelManager::abandon_payment`] prior to receiving the
/// invoice. If abandoned, or an invoice isn't received before expiration, the payment will fail
/// with an [`Event::PaymentFailed`].
///
/// If `max_total_routing_fee_msat` is not specified, The default from
/// [`RouteParameters::from_payment_params_and_value`] is applied.
///
/// # Privacy
///
/// Uses [`MessageRouter`] to construct a [`BlindedMessagePath`] for the refund based on the given
/// `absolute_expiry` according to [`MAX_SHORT_LIVED_RELATIVE_EXPIRY`]. See those docs for
/// privacy implications as well as those of the parameterized [`Router`], which implements
/// [`MessageRouter`].
///
/// Also, uses a derived payer id in the refund for payer privacy.
///
/// # Limitations
///
/// Requires a direct connection to an introduction node in the responding
/// [`Bolt12Invoice::payment_paths`].
///
/// # Errors
///
/// Errors if:
/// - a duplicate `payment_id` is provided given the caveats in the aforementioned link,
/// - `amount_msats` is invalid, or
/// - the parameterized [`Router`] is unable to create a blinded path for the refund.
///
/// [`Refund`]: crate::offers::refund::Refund
/// [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
/// [`Bolt12Invoice::payment_paths`]: crate::offers::invoice::Bolt12Invoice::payment_paths
/// [Avoiding Duplicate Payments]: #avoiding-duplicate-payments
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_create_refund_builder(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut amount_msats: u64, mut absolute_expiry: u64, mut payment_id: crate::c_types::ThirtyTwoBytes, mut retry_strategy: crate::lightning::ln::outbound_payment::Retry, mut max_total_routing_fee_msat: crate::c_types::derived::COption_u64Z) -> crate::c_types::derived::CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	let mut local_max_total_routing_fee_msat = if max_total_routing_fee_msat.is_some() { Some( { max_total_routing_fee_msat.take() }) } else { None };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.create_refund_builder(amount_msats, core::time::Duration::from_secs(absolute_expiry), ::lightning::ln::channelmanager::PaymentId(payment_id.data), retry_strategy.into_native(), local_max_total_routing_fee_msat);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::offers::refund::RefundMaybeWithDerivedMetadataBuilder { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::offers::parse::Bolt12SemanticError::native_into(e) }).into() };
	local_ret
}

/// Pays for an [`Offer`] using the given parameters by creating an [`InvoiceRequest`] and
/// enqueuing it to be sent via an onion message. [`ChannelManager`] will pay the actual
/// [`Bolt12Invoice`] once it is received.
///
/// Uses [`InvoiceRequestBuilder`] such that the [`InvoiceRequest`] it builds is recognized by
/// the [`ChannelManager`] when handling a [`Bolt12Invoice`] message in response to the request.
/// The optional parameters are used in the builder, if `Some`:
/// - `quantity` for [`InvoiceRequest::quantity`] which must be set if
///   [`Offer::expects_quantity`] is `true`.
/// - `amount_msats` if overpaying what is required for the given `quantity` is desired, and
/// - `payer_note` for [`InvoiceRequest::payer_note`].
///
/// If `max_total_routing_fee_msat` is not specified, The default from
/// [`RouteParameters::from_payment_params_and_value`] is applied.
///
/// # Payment
///
/// The provided `payment_id` is used to ensure that only one invoice is paid for the request
/// when received. See [Avoiding Duplicate Payments] for other requirements once the payment has
/// been sent.
///
/// To revoke the request, use [`ChannelManager::abandon_payment`] prior to receiving the
/// invoice. If abandoned, or an invoice isn't received in a reasonable amount of time, the
/// payment will fail with an [`Event::PaymentFailed`].
///
/// # Privacy
///
/// For payer privacy, uses a derived payer id and uses [`MessageRouter::create_blinded_paths`]
/// to construct a [`BlindedMessagePath`] for the reply path. For further privacy implications, see the
/// docs of the parameterized [`Router`], which implements [`MessageRouter`].
///
/// # Limitations
///
/// Requires a direct connection to an introduction node in [`Offer::paths`] or to
/// [`Offer::issuer_signing_pubkey`], if empty. A similar restriction applies to the responding
/// [`Bolt12Invoice::payment_paths`].
///
/// # Errors
///
/// Errors if:
/// - a duplicate `payment_id` is provided given the caveats in the aforementioned link,
/// - the provided parameters are invalid for the offer,
/// - the offer is for an unsupported chain, or
/// - the parameterized [`Router`] is unable to create a blinded reply path for the invoice
///   request.
///
/// [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
/// [`InvoiceRequest::quantity`]: crate::offers::invoice_request::InvoiceRequest::quantity
/// [`InvoiceRequest::payer_note`]: crate::offers::invoice_request::InvoiceRequest::payer_note
/// [`InvoiceRequestBuilder`]: crate::offers::invoice_request::InvoiceRequestBuilder
/// [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
/// [`Bolt12Invoice::payment_paths`]: crate::offers::invoice::Bolt12Invoice::payment_paths
/// [Avoiding Duplicate Payments]: #avoiding-duplicate-payments
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_pay_for_offer(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, offer: &crate::lightning::offers::offer::Offer, mut quantity: crate::c_types::derived::COption_u64Z, mut amount_msats: crate::c_types::derived::COption_u64Z, mut payer_note: crate::c_types::derived::COption_StrZ, mut payment_id: crate::c_types::ThirtyTwoBytes, mut retry_strategy: crate::lightning::ln::outbound_payment::Retry, mut max_total_routing_fee_msat: crate::c_types::derived::COption_u64Z) -> crate::c_types::derived::CResult_NoneBolt12SemanticErrorZ {
	let mut local_quantity = if quantity.is_some() { Some( { quantity.take() }) } else { None };
	let mut local_amount_msats = if amount_msats.is_some() { Some( { amount_msats.take() }) } else { None };
	let mut local_payer_note = { /*payer_note*/ let payer_note_opt = payer_note; if payer_note_opt.is_none() { None } else { Some({ { { payer_note_opt.take() }.into_string() }})} };
	let mut local_max_total_routing_fee_msat = if max_total_routing_fee_msat.is_some() { Some( { max_total_routing_fee_msat.take() }) } else { None };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.pay_for_offer(offer.get_native_ref(), local_quantity, local_amount_msats, local_payer_note, ::lightning::ln::channelmanager::PaymentId(payment_id.data), retry_strategy.into_native(), local_max_total_routing_fee_msat);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::offers::parse::Bolt12SemanticError::native_into(e) }).into() };
	local_ret
}

/// Creates a [`Bolt12Invoice`] for a [`Refund`] and enqueues it to be sent via an onion
/// message.
///
/// The resulting invoice uses a [`PaymentHash`] recognized by the [`ChannelManager`] and a
/// [`BlindedPaymentPath`] containing the [`PaymentSecret`] needed to reconstruct the
/// corresponding [`PaymentPreimage`]. It is returned purely for informational purposes.
///
/// # Limitations
///
/// Requires a direct connection to an introduction node in [`Refund::paths`] or to
/// [`Refund::payer_signing_pubkey`], if empty. This request is best effort; an invoice will be
/// sent to each node meeting the aforementioned criteria, but there's no guarantee that they
/// will be received and no retries will be made.
///
/// # Errors
///
/// Errors if:
/// - the refund is for an unsupported chain, or
/// - the parameterized [`Router`] is unable to create a blinded payment path or reply path for
///   the invoice.
///
/// [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_request_refund_payment(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, refund: &crate::lightning::offers::refund::Refund) -> crate::c_types::derived::CResult_Bolt12InvoiceBolt12SemanticErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.request_refund_payment(refund.get_native_ref());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::offers::invoice::Bolt12Invoice { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::offers::parse::Bolt12SemanticError::native_into(e) }).into() };
	local_ret
}

/// Pays for an [`Offer`] looked up using [BIP 353] Human Readable Names resolved by the DNS
/// resolver(s) at `dns_resolvers` which resolve names according to bLIP 32.
///
/// If the wallet supports paying on-chain schemes, you should instead use
/// [`OMNameResolver::resolve_name`] and [`OMNameResolver::handle_dnssec_proof_for_uri`] (by
/// implementing [`DNSResolverMessageHandler`]) directly to look up a URI and then delegate to
/// your normal URI handling.
///
/// If `max_total_routing_fee_msat` is not specified, the default from
/// [`RouteParameters::from_payment_params_and_value`] is applied.
///
/// # Payment
///
/// The provided `payment_id` is used to ensure that only one invoice is paid for the request
/// when received. See [Avoiding Duplicate Payments] for other requirements once the payment has
/// been sent.
///
/// To revoke the request, use [`ChannelManager::abandon_payment`] prior to receiving the
/// invoice. If abandoned, or an invoice isn't received in a reasonable amount of time, the
/// payment will fail with an [`Event::InvoiceRequestFailed`].
///
/// # Privacy
///
/// For payer privacy, uses a derived payer id and uses [`MessageRouter::create_blinded_paths`]
/// to construct a [`BlindedPath`] for the reply path. For further privacy implications, see the
/// docs of the parameterized [`Router`], which implements [`MessageRouter`].
///
/// # Limitations
///
/// Requires a direct connection to the given [`Destination`] as well as an introduction node in
/// [`Offer::paths`] or to [`Offer::signing_pubkey`], if empty. A similar restriction applies to
/// the responding [`Bolt12Invoice::payment_paths`].
///
/// # Errors
///
/// Errors if:
/// - a duplicate `payment_id` is provided given the caveats in the aforementioned link,
///
/// [`Bolt12Invoice::payment_paths`]: crate::offers::invoice::Bolt12Invoice::payment_paths
/// [Avoiding Duplicate Payments]: #avoiding-duplicate-payments
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_pay_for_offer_from_human_readable_name(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut name: crate::lightning::onion_message::dns_resolution::HumanReadableName, mut amount_msats: u64, mut payment_id: crate::c_types::ThirtyTwoBytes, mut retry_strategy: crate::lightning::ln::outbound_payment::Retry, mut max_total_routing_fee_msat: crate::c_types::derived::COption_u64Z, mut dns_resolvers: crate::c_types::derived::CVec_DestinationZ) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut local_max_total_routing_fee_msat = if max_total_routing_fee_msat.is_some() { Some( { max_total_routing_fee_msat.take() }) } else { None };
	let mut local_dns_resolvers = Vec::new(); for mut item in dns_resolvers.into_rust().drain(..) { local_dns_resolvers.push( { item.into_native() }); };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.pay_for_offer_from_human_readable_name(*unsafe { Box::from_raw(name.take_inner()) }, amount_msats, ::lightning::ln::channelmanager::PaymentId(payment_id.data), retry_strategy.into_native(), local_max_total_routing_fee_msat, local_dns_resolvers);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}

/// Gets a payment secret and payment hash for use in an invoice given to a third party wishing
/// to pay us.
///
/// This differs from [`create_inbound_payment_for_hash`] only in that it generates the
/// [`PaymentHash`] and [`PaymentPreimage`] for you.
///
/// The [`PaymentPreimage`] will ultimately be returned to you in the [`PaymentClaimable`] event, which
/// will have the [`PaymentClaimable::purpose`] return `Some` for [`PaymentPurpose::preimage`]. That
/// should then be passed directly to [`claim_funds`].
///
/// See [`create_inbound_payment_for_hash`] for detailed documentation on behavior and requirements.
///
/// Note that a malicious eavesdropper can intuit whether an inbound payment was created by
/// `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
///
/// # Note
///
/// If you register an inbound payment with this method, then serialize the `ChannelManager`, then
/// deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
///
/// Errors if `min_value_msat` is greater than total bitcoin supply.
///
/// If `min_final_cltv_expiry_delta` is set to some value, then the payment will not be receivable
/// on versions of LDK prior to 0.0.114.
///
/// [`claim_funds`]: Self::claim_funds
/// [`PaymentClaimable`]: events::Event::PaymentClaimable
/// [`PaymentClaimable::purpose`]: events::Event::PaymentClaimable::purpose
/// [`PaymentPurpose::preimage`]: events::PaymentPurpose::preimage
/// [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_create_inbound_payment(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut min_value_msat: crate::c_types::derived::COption_u64Z, mut invoice_expiry_delta_secs: u32, mut min_final_cltv_expiry_delta: crate::c_types::derived::COption_u16Z) -> crate::c_types::derived::CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	let mut local_min_value_msat = if min_value_msat.is_some() { Some( { min_value_msat.take() }) } else { None };
	let mut local_min_final_cltv_expiry_delta = if min_final_cltv_expiry_delta.is_some() { Some( { min_final_cltv_expiry_delta.take() }) } else { None };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.create_inbound_payment(local_min_value_msat, invoice_expiry_delta_secs, local_min_final_cltv_expiry_delta);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let (mut orig_ret_0_0, mut orig_ret_0_1) = o; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: orig_ret_0_0.0 }, crate::c_types::ThirtyTwoBytes { data: orig_ret_0_1.0 }).into(); local_ret_0 }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}

/// Gets a [`PaymentSecret`] for a given [`PaymentHash`], for which the payment preimage is
/// stored external to LDK.
///
/// A [`PaymentClaimable`] event will only be generated if the [`PaymentSecret`] matches a
/// payment secret fetched via this method or [`create_inbound_payment`], and which is at least
/// the `min_value_msat` provided here, if one is provided.
///
/// The [`PaymentHash`] (and corresponding [`PaymentPreimage`]) should be globally unique, though
/// note that LDK will not stop you from registering duplicate payment hashes for inbound
/// payments.
///
/// `min_value_msat` should be set if the invoice being generated contains a value. Any payment
/// received for the returned [`PaymentHash`] will be required to be at least `min_value_msat`
/// before a [`PaymentClaimable`] event will be generated, ensuring that we do not provide the
/// sender \"proof-of-payment\" unless they have paid the required amount.
///
/// `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
/// in excess of the current time. This should roughly match the expiry time set in the invoice.
/// After this many seconds, we will remove the inbound payment, resulting in any attempts to
/// pay the invoice failing. The BOLT spec suggests 3,600 secs as a default validity time for
/// invoices when no timeout is set.
///
/// Note that we use block header time to time-out pending inbound payments (with some margin
/// to compensate for the inaccuracy of block header timestamps). Thus, in practice we will
/// accept a payment and generate a [`PaymentClaimable`] event for some time after the expiry.
/// If you need exact expiry semantics, you should enforce them upon receipt of
/// [`PaymentClaimable`].
///
/// Note that invoices generated for inbound payments should have their `min_final_cltv_expiry_delta`
/// set to at least [`MIN_FINAL_CLTV_EXPIRY_DELTA`].
///
/// Note that a malicious eavesdropper can intuit whether an inbound payment was created by
/// `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
///
/// # Note
///
/// If you register an inbound payment with this method, then serialize the `ChannelManager`, then
/// deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
///
/// Errors if `min_value_msat` is greater than total bitcoin supply.
///
/// If `min_final_cltv_expiry_delta` is set to some value, then the payment will not be receivable
/// on versions of LDK prior to 0.0.114.
///
/// [`create_inbound_payment`]: Self::create_inbound_payment
/// [`PaymentClaimable`]: events::Event::PaymentClaimable
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_create_inbound_payment_for_hash(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut payment_hash: crate::c_types::ThirtyTwoBytes, mut min_value_msat: crate::c_types::derived::COption_u64Z, mut invoice_expiry_delta_secs: u32, mut min_final_cltv_expiry: crate::c_types::derived::COption_u16Z) -> crate::c_types::derived::CResult_ThirtyTwoBytesNoneZ {
	let mut local_min_value_msat = if min_value_msat.is_some() { Some( { min_value_msat.take() }) } else { None };
	let mut local_min_final_cltv_expiry = if min_final_cltv_expiry.is_some() { Some( { min_final_cltv_expiry.take() }) } else { None };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.create_inbound_payment_for_hash(::lightning::types::payment::PaymentHash(payment_hash.data), local_min_value_msat, invoice_expiry_delta_secs, local_min_final_cltv_expiry);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::c_types::ThirtyTwoBytes { data: o.0 } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}

/// Gets an LDK-generated payment preimage from a payment hash and payment secret that were
/// previously returned from [`create_inbound_payment`].
///
/// [`create_inbound_payment`]: Self::create_inbound_payment
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_get_payment_preimage(this_arg: &crate::lightning::ln::channelmanager::ChannelManager, mut payment_hash: crate::c_types::ThirtyTwoBytes, mut payment_secret: crate::c_types::ThirtyTwoBytes) -> crate::c_types::derived::CResult_ThirtyTwoBytesAPIErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_payment_preimage(::lightning::types::payment::PaymentHash(payment_hash.data), ::lightning::types::payment::PaymentSecret(payment_secret.data));
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::c_types::ThirtyTwoBytes { data: o.0 } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::util::errors::APIError::native_into(e) }).into() };
	local_ret
}

/// Gets a fake short channel id for use in receiving [phantom node payments]. These fake scids
/// are used when constructing the phantom invoice's route hints.
///
/// [phantom node payments]: crate::sign::PhantomKeysManager
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_get_phantom_scid(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> u64 {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_phantom_scid();
	ret
}

/// Gets route hints for use in receiving [phantom node payments].
///
/// [phantom node payments]: crate::sign::PhantomKeysManager
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_get_phantom_route_hints(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::lightning::ln::channelmanager::PhantomRouteHints {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_phantom_route_hints();
	crate::lightning::ln::channelmanager::PhantomRouteHints { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Gets a fake short channel id for use in receiving intercepted payments. These fake scids are
/// used when constructing the route hints for HTLCs intended to be intercepted. See
/// [`ChannelManager::forward_intercepted_htlc`].
///
/// Note that this method is not guaranteed to return unique values, you may need to call it a few
/// times to get a unique scid.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_get_intercept_scid(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> u64 {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_intercept_scid();
	ret
}

/// Gets inflight HTLC information by processing pending outbound payments that are in
/// our channels. May be used during pathfinding to account for in-use channel liquidity.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_compute_inflight_htlcs(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::lightning::routing::router::InFlightHtlcs {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.compute_inflight_htlcs();
	crate::lightning::routing::router::InFlightHtlcs { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

impl From<nativeChannelManager> for crate::lightning::events::MessageSendEventsProvider {
	fn from(obj: nativeChannelManager) -> Self {
		let rust_obj = crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ChannelManager_as_MessageSendEventsProvider(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ChannelManager_free_void);
		ret
	}
}
/// Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ChannelManager_as_MessageSendEventsProvider(this_arg: &ChannelManager) -> crate::lightning::events::MessageSendEventsProvider {
	crate::lightning::events::MessageSendEventsProvider {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		get_and_clear_pending_msg_events: ChannelManager_MessageSendEventsProvider_get_and_clear_pending_msg_events,
	}
}

#[must_use]
extern "C" fn ChannelManager_MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg: *const c_void) -> crate::c_types::derived::CVec_MessageSendEventZ {
	let mut ret = <nativeChannelManager as lightning::events::MessageSendEventsProvider>::get_and_clear_pending_msg_events(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::events::MessageSendEvent::native_into(item) }); };
	local_ret.into()
}

impl From<nativeChannelManager> for crate::lightning::events::EventsProvider {
	fn from(obj: nativeChannelManager) -> Self {
		let rust_obj = crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ChannelManager_as_EventsProvider(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ChannelManager_free_void);
		ret
	}
}
/// Constructs a new EventsProvider which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ChannelManager_as_EventsProvider(this_arg: &ChannelManager) -> crate::lightning::events::EventsProvider {
	crate::lightning::events::EventsProvider {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		process_pending_events: ChannelManager_EventsProvider_process_pending_events,
	}
}

extern "C" fn ChannelManager_EventsProvider_process_pending_events(this_arg: *const c_void, mut handler: crate::lightning::events::EventHandler) {
	<nativeChannelManager as lightning::events::EventsProvider>::process_pending_events(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, handler)
}

impl From<nativeChannelManager> for crate::lightning::chain::Listen {
	fn from(obj: nativeChannelManager) -> Self {
		let rust_obj = crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ChannelManager_as_Listen(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ChannelManager_free_void);
		ret
	}
}
/// Constructs a new Listen which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ChannelManager_as_Listen(this_arg: &ChannelManager) -> crate::lightning::chain::Listen {
	crate::lightning::chain::Listen {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		filtered_block_connected: ChannelManager_Listen_filtered_block_connected,
		block_connected: ChannelManager_Listen_block_connected,
		block_disconnected: ChannelManager_Listen_block_disconnected,
	}
}

extern "C" fn ChannelManager_Listen_filtered_block_connected(this_arg: *const c_void, header: *const [u8; 80], mut txdata: crate::c_types::derived::CVec_C2Tuple_usizeTransactionZZ, mut height: u32) {
	let mut local_txdata = Vec::new(); for mut item in txdata.into_rust().drain(..) { local_txdata.push( { let (mut orig_txdata_0_0, mut orig_txdata_0_1) = item.to_rust(); let mut local_txdata_0 = (orig_txdata_0_0, orig_txdata_0_1.into_bitcoin()); local_txdata_0 }); };
	<nativeChannelManager as lightning::chain::Listen>::filtered_block_connected(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, &::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), &local_txdata.iter().map(|(a, b)| (*a, b)).collect::<Vec<_>>()[..], height)
}
extern "C" fn ChannelManager_Listen_block_connected(this_arg: *const c_void, mut block: crate::c_types::u8slice, mut height: u32) {
	<nativeChannelManager as lightning::chain::Listen>::block_connected(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, &::bitcoin::consensus::encode::deserialize(block.to_slice()).unwrap(), height)
}
extern "C" fn ChannelManager_Listen_block_disconnected(this_arg: *const c_void, header: *const [u8; 80], mut height: u32) {
	<nativeChannelManager as lightning::chain::Listen>::block_disconnected(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, &::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), height)
}

impl From<nativeChannelManager> for crate::lightning::chain::Confirm {
	fn from(obj: nativeChannelManager) -> Self {
		let rust_obj = crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ChannelManager_as_Confirm(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ChannelManager_free_void);
		ret
	}
}
/// Constructs a new Confirm which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ChannelManager_as_Confirm(this_arg: &ChannelManager) -> crate::lightning::chain::Confirm {
	crate::lightning::chain::Confirm {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		transactions_confirmed: ChannelManager_Confirm_transactions_confirmed,
		transaction_unconfirmed: ChannelManager_Confirm_transaction_unconfirmed,
		best_block_updated: ChannelManager_Confirm_best_block_updated,
		get_relevant_txids: ChannelManager_Confirm_get_relevant_txids,
	}
}

extern "C" fn ChannelManager_Confirm_transactions_confirmed(this_arg: *const c_void, header: *const [u8; 80], mut txdata: crate::c_types::derived::CVec_C2Tuple_usizeTransactionZZ, mut height: u32) {
	let mut local_txdata = Vec::new(); for mut item in txdata.into_rust().drain(..) { local_txdata.push( { let (mut orig_txdata_0_0, mut orig_txdata_0_1) = item.to_rust(); let mut local_txdata_0 = (orig_txdata_0_0, orig_txdata_0_1.into_bitcoin()); local_txdata_0 }); };
	<nativeChannelManager as lightning::chain::Confirm>::transactions_confirmed(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, &::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), &local_txdata.iter().map(|(a, b)| (*a, b)).collect::<Vec<_>>()[..], height)
}
extern "C" fn ChannelManager_Confirm_transaction_unconfirmed(this_arg: *const c_void, txid: *const [u8; 32]) {
	<nativeChannelManager as lightning::chain::Confirm>::transaction_unconfirmed(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, &::bitcoin::hash_types::Txid::from_slice(&unsafe { &*txid }[..]).unwrap())
}
extern "C" fn ChannelManager_Confirm_best_block_updated(this_arg: *const c_void, header: *const [u8; 80], mut height: u32) {
	<nativeChannelManager as lightning::chain::Confirm>::best_block_updated(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, &::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), height)
}
#[must_use]
extern "C" fn ChannelManager_Confirm_get_relevant_txids(this_arg: *const c_void) -> crate::c_types::derived::CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	let mut ret = <nativeChannelManager as lightning::chain::Confirm>::get_relevant_txids(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1, mut orig_ret_0_2) = item; let mut local_orig_ret_0_2 = if orig_ret_0_2.is_none() { crate::c_types::derived::COption_ThirtyTwoBytesZ::None } else { crate::c_types::derived::COption_ThirtyTwoBytesZ::Some( { crate::c_types::ThirtyTwoBytes { data: *orig_ret_0_2.unwrap().as_ref() } }) }; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: *orig_ret_0_0.as_ref() }, orig_ret_0_1, local_orig_ret_0_2).into(); local_ret_0 }); };
	local_ret.into()
}

/// Gets a [`Future`] that completes when this [`ChannelManager`] may need to be persisted or
/// may have events that need processing.
///
/// In order to check if this [`ChannelManager`] needs persisting, call
/// [`Self::get_and_clear_needs_persistence`].
///
/// Note that callbacks registered on the [`Future`] MUST NOT call back into this
/// [`ChannelManager`] and should instead register actions to be taken later.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_get_event_or_persistence_needed_future(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::lightning::util::wakers::Future {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_event_or_persistence_needed_future();
	crate::lightning::util::wakers::Future { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Returns true if this [`ChannelManager`] needs to be persisted.
///
/// See [`Self::get_event_or_persistence_needed_future`] for retrieving a [`Future`] that
/// indicates this should be checked.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_get_and_clear_needs_persistence(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> bool {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_and_clear_needs_persistence();
	ret
}

/// Gets the latest best block which was connected either via the [`chain::Listen`] or
/// [`chain::Confirm`] interfaces.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_current_best_block(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::lightning::chain::BestBlock {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.current_best_block();
	crate::lightning::chain::BestBlock { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Fetches the set of [`NodeFeatures`] flags that are provided by or required by
/// [`ChannelManager`].
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_node_features(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::lightning_types::features::NodeFeatures {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.node_features();
	crate::lightning_types::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Fetches the set of [`ChannelFeatures`] flags that are provided by or required by
/// [`ChannelManager`].
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_channel_features(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::lightning_types::features::ChannelFeatures {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.channel_features();
	crate::lightning_types::features::ChannelFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Fetches the set of [`ChannelTypeFeatures`] flags that are provided by or required by
/// [`ChannelManager`].
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_channel_type_features(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::lightning_types::features::ChannelTypeFeatures {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.channel_type_features();
	crate::lightning_types::features::ChannelTypeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Fetches the set of [`InitFeatures`] flags that are provided by or required by
/// [`ChannelManager`].
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManager_init_features(this_arg: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::lightning_types::features::InitFeatures {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.init_features();
	crate::lightning_types::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

impl From<nativeChannelManager> for crate::lightning::ln::msgs::ChannelMessageHandler {
	fn from(obj: nativeChannelManager) -> Self {
		let rust_obj = crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ChannelManager_as_ChannelMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ChannelManager_free_void);
		ret
	}
}
/// Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ChannelManager_as_ChannelMessageHandler(this_arg: &ChannelManager) -> crate::lightning::ln::msgs::ChannelMessageHandler {
	crate::lightning::ln::msgs::ChannelMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_open_channel: ChannelManager_ChannelMessageHandler_handle_open_channel,
		handle_open_channel_v2: ChannelManager_ChannelMessageHandler_handle_open_channel_v2,
		handle_accept_channel: ChannelManager_ChannelMessageHandler_handle_accept_channel,
		handle_accept_channel_v2: ChannelManager_ChannelMessageHandler_handle_accept_channel_v2,
		handle_funding_created: ChannelManager_ChannelMessageHandler_handle_funding_created,
		handle_funding_signed: ChannelManager_ChannelMessageHandler_handle_funding_signed,
		handle_channel_ready: ChannelManager_ChannelMessageHandler_handle_channel_ready,
		handle_shutdown: ChannelManager_ChannelMessageHandler_handle_shutdown,
		handle_closing_signed: ChannelManager_ChannelMessageHandler_handle_closing_signed,
		handle_stfu: ChannelManager_ChannelMessageHandler_handle_stfu,
		handle_tx_add_input: ChannelManager_ChannelMessageHandler_handle_tx_add_input,
		handle_tx_add_output: ChannelManager_ChannelMessageHandler_handle_tx_add_output,
		handle_tx_remove_input: ChannelManager_ChannelMessageHandler_handle_tx_remove_input,
		handle_tx_remove_output: ChannelManager_ChannelMessageHandler_handle_tx_remove_output,
		handle_tx_complete: ChannelManager_ChannelMessageHandler_handle_tx_complete,
		handle_tx_signatures: ChannelManager_ChannelMessageHandler_handle_tx_signatures,
		handle_tx_init_rbf: ChannelManager_ChannelMessageHandler_handle_tx_init_rbf,
		handle_tx_ack_rbf: ChannelManager_ChannelMessageHandler_handle_tx_ack_rbf,
		handle_tx_abort: ChannelManager_ChannelMessageHandler_handle_tx_abort,
		handle_update_add_htlc: ChannelManager_ChannelMessageHandler_handle_update_add_htlc,
		handle_update_fulfill_htlc: ChannelManager_ChannelMessageHandler_handle_update_fulfill_htlc,
		handle_update_fail_htlc: ChannelManager_ChannelMessageHandler_handle_update_fail_htlc,
		handle_update_fail_malformed_htlc: ChannelManager_ChannelMessageHandler_handle_update_fail_malformed_htlc,
		handle_commitment_signed: ChannelManager_ChannelMessageHandler_handle_commitment_signed,
		handle_revoke_and_ack: ChannelManager_ChannelMessageHandler_handle_revoke_and_ack,
		handle_update_fee: ChannelManager_ChannelMessageHandler_handle_update_fee,
		handle_announcement_signatures: ChannelManager_ChannelMessageHandler_handle_announcement_signatures,
		peer_disconnected: ChannelManager_ChannelMessageHandler_peer_disconnected,
		peer_connected: ChannelManager_ChannelMessageHandler_peer_connected,
		handle_channel_reestablish: ChannelManager_ChannelMessageHandler_handle_channel_reestablish,
		handle_channel_update: ChannelManager_ChannelMessageHandler_handle_channel_update,
		handle_error: ChannelManager_ChannelMessageHandler_handle_error,
		provided_node_features: ChannelManager_ChannelMessageHandler_provided_node_features,
		provided_init_features: ChannelManager_ChannelMessageHandler_provided_init_features,
		get_chain_hashes: ChannelManager_ChannelMessageHandler_get_chain_hashes,
		message_received: ChannelManager_ChannelMessageHandler_message_received,
		MessageSendEventsProvider: crate::lightning::events::MessageSendEventsProvider {
			this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
			free: None,
			get_and_clear_pending_msg_events: ChannelManager_MessageSendEventsProvider_get_and_clear_pending_msg_events,
		},
	}
}

extern "C" fn ChannelManager_ChannelMessageHandler_handle_open_channel(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::OpenChannel) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_open_channel(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_open_channel_v2(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::OpenChannelV2) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_open_channel_v2(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_accept_channel(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::AcceptChannel) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_accept_channel(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_accept_channel_v2(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::AcceptChannelV2) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_accept_channel_v2(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_funding_created(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::FundingCreated) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_funding_created(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_funding_signed(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::FundingSigned) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_funding_signed(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_channel_ready(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelReady) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_channel_ready(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_shutdown(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::Shutdown) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_shutdown(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_closing_signed(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ClosingSigned) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_closing_signed(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_stfu(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::Stfu) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_stfu(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_tx_add_input(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAddInput) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_add_input(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_tx_add_output(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAddOutput) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_add_output(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_tx_remove_input(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxRemoveInput) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_remove_input(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_tx_remove_output(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxRemoveOutput) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_remove_output(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_tx_complete(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxComplete) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_complete(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_tx_signatures(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxSignatures) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_signatures(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_tx_init_rbf(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxInitRbf) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_init_rbf(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_tx_ack_rbf(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAckRbf) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_ack_rbf(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_tx_abort(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAbort) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_tx_abort(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_update_add_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateAddHTLC) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_update_add_htlc(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_update_fulfill_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFulfillHTLC) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_update_fulfill_htlc(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_update_fail_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFailHTLC) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_update_fail_htlc(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_update_fail_malformed_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFailMalformedHTLC) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_update_fail_malformed_htlc(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_commitment_signed(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::CommitmentSigned) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_commitment_signed(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_revoke_and_ack(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::RevokeAndACK) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_revoke_and_ack(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_update_fee(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFee) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_update_fee(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_announcement_signatures(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::AnnouncementSignatures) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_announcement_signatures(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_peer_disconnected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::peer_disconnected(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust())
}
#[must_use]
extern "C" fn ChannelManager_ChannelMessageHandler_peer_connected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::Init, mut inbound: bool) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut ret = <nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::peer_connected(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref(), inbound);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_channel_reestablish(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelReestablish) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_channel_reestablish(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_channel_update(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelUpdate) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_channel_update(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ChannelManager_ChannelMessageHandler_handle_error(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ErrorMessage) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::handle_error(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust(), msg.get_native_ref())
}
#[must_use]
extern "C" fn ChannelManager_ChannelMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning_types::features::NodeFeatures {
	let mut ret = <nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, );
	crate::lightning_types::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn ChannelManager_ChannelMessageHandler_provided_init_features(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) -> crate::lightning_types::features::InitFeatures {
	let mut ret = <nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::provided_init_features(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, their_node_id.into_rust());
	crate::lightning_types::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn ChannelManager_ChannelMessageHandler_get_chain_hashes(this_arg: *const c_void) -> crate::c_types::derived::COption_CVec_ThirtyTwoBytesZZ {
	let mut ret = <nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::get_chain_hashes(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, );
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_CVec_ThirtyTwoBytesZZ::None } else { crate::c_types::derived::COption_CVec_ThirtyTwoBytesZZ::Some( { let mut local_ret_0 = Vec::new(); for mut item in ret.unwrap().drain(..) { local_ret_0.push( { crate::c_types::ThirtyTwoBytes { data: *item.as_ref() } }); }; local_ret_0.into() }) };
	local_ret
}
extern "C" fn ChannelManager_ChannelMessageHandler_message_received(this_arg: *const c_void) {
	<nativeChannelManager as lightning::ln::msgs::ChannelMessageHandler>::message_received(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, )
}

impl From<nativeChannelManager> for crate::lightning::onion_message::offers::OffersMessageHandler {
	fn from(obj: nativeChannelManager) -> Self {
		let rust_obj = crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ChannelManager_as_OffersMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ChannelManager_free_void);
		ret
	}
}
/// Constructs a new OffersMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned OffersMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ChannelManager_as_OffersMessageHandler(this_arg: &ChannelManager) -> crate::lightning::onion_message::offers::OffersMessageHandler {
	crate::lightning::onion_message::offers::OffersMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_message: ChannelManager_OffersMessageHandler_handle_message,
		release_pending_messages: ChannelManager_OffersMessageHandler_release_pending_messages,
	}
}

#[must_use]
extern "C" fn ChannelManager_OffersMessageHandler_handle_message(this_arg: *const c_void, mut message: crate::lightning::onion_message::offers::OffersMessage, mut context: crate::c_types::derived::COption_OffersContextZ, mut responder: crate::lightning::onion_message::messenger::Responder) -> crate::c_types::derived::COption_C2Tuple_OffersMessageResponseInstructionZZ {
	let mut local_context = { /*context*/ let context_opt = context; if context_opt.is_none() { None } else { Some({ { { context_opt.take() }.into_native() }})} };
	let mut local_responder = if responder.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(responder.take_inner()) } }) };
	let mut ret = <nativeChannelManager as lightning::onion_message::offers::OffersMessageHandler>::handle_message(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, message.into_native(), local_context, local_responder);
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_C2Tuple_OffersMessageResponseInstructionZZ::None } else { crate::c_types::derived::COption_C2Tuple_OffersMessageResponseInstructionZZ::Some( { let (mut orig_ret_0_0, mut orig_ret_0_1) = (ret.unwrap()); let mut local_ret_0 = (crate::lightning::onion_message::offers::OffersMessage::native_into(orig_ret_0_0), crate::lightning::onion_message::messenger::ResponseInstruction { inner: ObjOps::heap_alloc(orig_ret_0_1), is_owned: true }).into(); local_ret_0 }) };
	local_ret
}
#[must_use]
extern "C" fn ChannelManager_OffersMessageHandler_release_pending_messages(this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_OffersMessageMessageSendInstructionsZZ {
	let mut ret = <nativeChannelManager as lightning::onion_message::offers::OffersMessageHandler>::release_pending_messages(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_ret_0 = (crate::lightning::onion_message::offers::OffersMessage::native_into(orig_ret_0_0), crate::lightning::onion_message::messenger::MessageSendInstructions::native_into(orig_ret_0_1)).into(); local_ret_0 }); };
	local_ret.into()
}

impl From<nativeChannelManager> for crate::lightning::onion_message::async_payments::AsyncPaymentsMessageHandler {
	fn from(obj: nativeChannelManager) -> Self {
		let rust_obj = crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ChannelManager_as_AsyncPaymentsMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ChannelManager_free_void);
		ret
	}
}
/// Constructs a new AsyncPaymentsMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned AsyncPaymentsMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ChannelManager_as_AsyncPaymentsMessageHandler(this_arg: &ChannelManager) -> crate::lightning::onion_message::async_payments::AsyncPaymentsMessageHandler {
	crate::lightning::onion_message::async_payments::AsyncPaymentsMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_held_htlc_available: ChannelManager_AsyncPaymentsMessageHandler_handle_held_htlc_available,
		handle_release_held_htlc: ChannelManager_AsyncPaymentsMessageHandler_handle_release_held_htlc,
		release_pending_messages: ChannelManager_AsyncPaymentsMessageHandler_release_pending_messages,
	}
}

#[must_use]
extern "C" fn ChannelManager_AsyncPaymentsMessageHandler_handle_held_htlc_available(this_arg: *const c_void, mut message: crate::lightning::onion_message::async_payments::HeldHtlcAvailable, mut responder: crate::lightning::onion_message::messenger::Responder) -> crate::c_types::derived::COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ {
	let mut local_responder = if responder.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(responder.take_inner()) } }) };
	let mut ret = <nativeChannelManager as lightning::onion_message::async_payments::AsyncPaymentsMessageHandler>::handle_held_htlc_available(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, *unsafe { Box::from_raw(message.take_inner()) }, local_responder);
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ::None } else { crate::c_types::derived::COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ::Some( { let (mut orig_ret_0_0, mut orig_ret_0_1) = (ret.unwrap()); let mut local_ret_0 = (crate::lightning::onion_message::async_payments::ReleaseHeldHtlc { inner: ObjOps::heap_alloc(orig_ret_0_0), is_owned: true }, crate::lightning::onion_message::messenger::ResponseInstruction { inner: ObjOps::heap_alloc(orig_ret_0_1), is_owned: true }).into(); local_ret_0 }) };
	local_ret
}
extern "C" fn ChannelManager_AsyncPaymentsMessageHandler_handle_release_held_htlc(this_arg: *const c_void, mut message: crate::lightning::onion_message::async_payments::ReleaseHeldHtlc, mut context: crate::lightning::blinded_path::message::AsyncPaymentsContext) {
	<nativeChannelManager as lightning::onion_message::async_payments::AsyncPaymentsMessageHandler>::handle_release_held_htlc(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, *unsafe { Box::from_raw(message.take_inner()) }, context.into_native())
}
#[must_use]
extern "C" fn ChannelManager_AsyncPaymentsMessageHandler_release_pending_messages(this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZZ {
	let mut ret = <nativeChannelManager as lightning::onion_message::async_payments::AsyncPaymentsMessageHandler>::release_pending_messages(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_ret_0 = (crate::lightning::onion_message::async_payments::AsyncPaymentsMessage::native_into(orig_ret_0_0), crate::lightning::onion_message::messenger::MessageSendInstructions::native_into(orig_ret_0_1)).into(); local_ret_0 }); };
	local_ret.into()
}

impl From<nativeChannelManager> for crate::lightning::onion_message::dns_resolution::DNSResolverMessageHandler {
	fn from(obj: nativeChannelManager) -> Self {
		let rust_obj = crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ChannelManager_as_DNSResolverMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ChannelManager_free_void);
		ret
	}
}
/// Constructs a new DNSResolverMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned DNSResolverMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ChannelManager_as_DNSResolverMessageHandler(this_arg: &ChannelManager) -> crate::lightning::onion_message::dns_resolution::DNSResolverMessageHandler {
	crate::lightning::onion_message::dns_resolution::DNSResolverMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_dnssec_query: ChannelManager_DNSResolverMessageHandler_handle_dnssec_query,
		handle_dnssec_proof: ChannelManager_DNSResolverMessageHandler_handle_dnssec_proof,
		provided_node_features: ChannelManager_DNSResolverMessageHandler_provided_node_features,
		release_pending_messages: ChannelManager_DNSResolverMessageHandler_release_pending_messages,
	}
}

#[must_use]
extern "C" fn ChannelManager_DNSResolverMessageHandler_handle_dnssec_query(this_arg: *const c_void, mut message: crate::lightning::onion_message::dns_resolution::DNSSECQuery, mut responder: crate::lightning::onion_message::messenger::Responder) -> crate::c_types::derived::COption_C2Tuple_DNSResolverMessageResponseInstructionZZ {
	let mut local_responder = if responder.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(responder.take_inner()) } }) };
	let mut ret = <nativeChannelManager as lightning::onion_message::dns_resolution::DNSResolverMessageHandler>::handle_dnssec_query(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, *unsafe { Box::from_raw(message.take_inner()) }, local_responder);
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_C2Tuple_DNSResolverMessageResponseInstructionZZ::None } else { crate::c_types::derived::COption_C2Tuple_DNSResolverMessageResponseInstructionZZ::Some( { let (mut orig_ret_0_0, mut orig_ret_0_1) = (ret.unwrap()); let mut local_ret_0 = (crate::lightning::onion_message::dns_resolution::DNSResolverMessage::native_into(orig_ret_0_0), crate::lightning::onion_message::messenger::ResponseInstruction { inner: ObjOps::heap_alloc(orig_ret_0_1), is_owned: true }).into(); local_ret_0 }) };
	local_ret
}
extern "C" fn ChannelManager_DNSResolverMessageHandler_handle_dnssec_proof(this_arg: *const c_void, mut message: crate::lightning::onion_message::dns_resolution::DNSSECProof, mut context: crate::lightning::blinded_path::message::DNSResolverContext) {
	<nativeChannelManager as lightning::onion_message::dns_resolution::DNSResolverMessageHandler>::handle_dnssec_proof(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, *unsafe { Box::from_raw(message.take_inner()) }, *unsafe { Box::from_raw(context.take_inner()) })
}
#[must_use]
extern "C" fn ChannelManager_DNSResolverMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning_types::features::NodeFeatures {
	let mut ret = <nativeChannelManager as lightning::onion_message::dns_resolution::DNSResolverMessageHandler>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, );
	crate::lightning_types::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn ChannelManager_DNSResolverMessageHandler_release_pending_messages(this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_DNSResolverMessageMessageSendInstructionsZZ {
	let mut ret = <nativeChannelManager as lightning::onion_message::dns_resolution::DNSResolverMessageHandler>::release_pending_messages(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_ret_0 = (crate::lightning::onion_message::dns_resolution::DNSResolverMessage::native_into(orig_ret_0_0), crate::lightning::onion_message::messenger::MessageSendInstructions::native_into(orig_ret_0_1)).into(); local_ret_0 }); };
	local_ret.into()
}

impl From<nativeChannelManager> for crate::lightning::blinded_path::NodeIdLookUp {
	fn from(obj: nativeChannelManager) -> Self {
		let rust_obj = crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ChannelManager_as_NodeIdLookUp(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so forget it and set ret's free() fn
		core::mem::forget(rust_obj);
		ret.free = Some(ChannelManager_free_void);
		ret
	}
}
/// Constructs a new NodeIdLookUp which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned NodeIdLookUp must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ChannelManager_as_NodeIdLookUp(this_arg: &ChannelManager) -> crate::lightning::blinded_path::NodeIdLookUp {
	crate::lightning::blinded_path::NodeIdLookUp {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		next_node_id: ChannelManager_NodeIdLookUp_next_node_id,
	}
}

#[must_use]
extern "C" fn ChannelManager_NodeIdLookUp_next_node_id(this_arg: *const c_void, mut short_channel_id: u64) -> crate::c_types::PublicKey {
	let mut ret = <nativeChannelManager as lightning::blinded_path::NodeIdLookUp>::next_node_id(unsafe { &mut *(this_arg as *mut nativeChannelManager) }, short_channel_id);
	let mut local_ret = if ret.is_none() { crate::c_types::PublicKey::null() } else {  { crate::c_types::PublicKey::from_rust(&(ret.unwrap())) } };
	local_ret
}

/// Fetches the set of [`InitFeatures`] flags that are provided by or required by
/// [`ChannelManager`].
#[no_mangle]
pub extern "C" fn provided_init_features(config: &crate::lightning::util::config::UserConfig) -> crate::lightning_types::features::InitFeatures {
	let mut ret = lightning::ln::channelmanager::provided_init_features(config.get_native_ref());
	crate::lightning_types::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

#[no_mangle]
/// Serialize the PhantomRouteHints object into a byte array which can be read by PhantomRouteHints_read
pub extern "C" fn PhantomRouteHints_write(obj: &crate::lightning::ln::channelmanager::PhantomRouteHints) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*obj }.get_native_ref())
}
#[allow(unused)]
pub(crate) extern "C" fn PhantomRouteHints_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*(obj as *const crate::lightning::ln::channelmanager::nativePhantomRouteHints) })
}
#[no_mangle]
/// Read a PhantomRouteHints from a byte array, created by PhantomRouteHints_write
pub extern "C" fn PhantomRouteHints_read(ser: crate::c_types::u8slice) -> crate::c_types::derived::CResult_PhantomRouteHintsDecodeErrorZ {
	let res: Result<lightning::ln::channelmanager::PhantomRouteHints, lightning::ln::msgs::DecodeError> = crate::c_types::deserialize_obj(ser);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::ln::channelmanager::PhantomRouteHints { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_res
}
#[no_mangle]
/// Serialize the BlindedForward object into a byte array which can be read by BlindedForward_read
pub extern "C" fn BlindedForward_write(obj: &crate::lightning::ln::channelmanager::BlindedForward) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*obj }.get_native_ref())
}
#[allow(unused)]
pub(crate) extern "C" fn BlindedForward_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*(obj as *const crate::lightning::ln::channelmanager::nativeBlindedForward) })
}
#[no_mangle]
/// Read a BlindedForward from a byte array, created by BlindedForward_write
pub extern "C" fn BlindedForward_read(ser: crate::c_types::u8slice) -> crate::c_types::derived::CResult_BlindedForwardDecodeErrorZ {
	let res: Result<lightning::ln::channelmanager::BlindedForward, lightning::ln::msgs::DecodeError> = crate::c_types::deserialize_obj(ser);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::ln::channelmanager::BlindedForward { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_res
}
#[no_mangle]
/// Serialize the PendingHTLCRouting object into a byte array which can be read by PendingHTLCRouting_read
pub extern "C" fn PendingHTLCRouting_write(obj: &crate::lightning::ln::channelmanager::PendingHTLCRouting) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(&unsafe { &*obj }.to_native())
}
#[allow(unused)]
pub(crate) extern "C" fn PendingHTLCRouting_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	PendingHTLCRouting_write(unsafe { &*(obj as *const PendingHTLCRouting) })
}
#[no_mangle]
/// Read a PendingHTLCRouting from a byte array, created by PendingHTLCRouting_write
pub extern "C" fn PendingHTLCRouting_read(ser: crate::c_types::u8slice) -> crate::c_types::derived::CResult_PendingHTLCRoutingDecodeErrorZ {
	let res: Result<lightning::ln::channelmanager::PendingHTLCRouting, lightning::ln::msgs::DecodeError> = crate::c_types::deserialize_obj(ser);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::ln::channelmanager::PendingHTLCRouting::native_into(o) }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_res
}
#[no_mangle]
/// Serialize the PendingHTLCInfo object into a byte array which can be read by PendingHTLCInfo_read
pub extern "C" fn PendingHTLCInfo_write(obj: &crate::lightning::ln::channelmanager::PendingHTLCInfo) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*obj }.get_native_ref())
}
#[allow(unused)]
pub(crate) extern "C" fn PendingHTLCInfo_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*(obj as *const crate::lightning::ln::channelmanager::nativePendingHTLCInfo) })
}
#[no_mangle]
/// Read a PendingHTLCInfo from a byte array, created by PendingHTLCInfo_write
pub extern "C" fn PendingHTLCInfo_read(ser: crate::c_types::u8slice) -> crate::c_types::derived::CResult_PendingHTLCInfoDecodeErrorZ {
	let res: Result<lightning::ln::channelmanager::PendingHTLCInfo, lightning::ln::msgs::DecodeError> = crate::c_types::deserialize_obj(ser);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::ln::channelmanager::PendingHTLCInfo { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_res
}
#[no_mangle]
/// Serialize the BlindedFailure object into a byte array which can be read by BlindedFailure_read
pub extern "C" fn BlindedFailure_write(obj: &crate::lightning::ln::channelmanager::BlindedFailure) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(&unsafe { &*obj }.to_native())
}
#[allow(unused)]
pub(crate) extern "C" fn BlindedFailure_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	BlindedFailure_write(unsafe { &*(obj as *const BlindedFailure) })
}
#[no_mangle]
/// Read a BlindedFailure from a byte array, created by BlindedFailure_write
pub extern "C" fn BlindedFailure_read(ser: crate::c_types::u8slice) -> crate::c_types::derived::CResult_BlindedFailureDecodeErrorZ {
	let res: Result<lightning::ln::channelmanager::BlindedFailure, lightning::ln::msgs::DecodeError> = crate::c_types::deserialize_obj(ser);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::ln::channelmanager::BlindedFailure::native_into(o) }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_res
}
#[no_mangle]
/// Serialize the ChannelManager object into a byte array which can be read by ChannelManager_read
pub extern "C" fn ChannelManager_write(obj: &crate::lightning::ln::channelmanager::ChannelManager) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*obj }.get_native_ref())
}
#[allow(unused)]
pub(crate) extern "C" fn ChannelManager_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*(obj as *const crate::lightning::ln::channelmanager::nativeChannelManager) })
}

use lightning::ln::channelmanager::ChannelManagerReadArgs as nativeChannelManagerReadArgsImport;
pub(crate) type nativeChannelManagerReadArgs = nativeChannelManagerReadArgsImport<'static, crate::lightning::chain::Watch, crate::lightning::chain::chaininterface::BroadcasterInterface, crate::lightning::sign::EntropySource, crate::lightning::sign::NodeSigner, crate::lightning::sign::SignerProvider, crate::lightning::chain::chaininterface::FeeEstimator, crate::lightning::routing::router::Router, crate::lightning::onion_message::messenger::MessageRouter, crate::lightning::util::logger::Logger, >;

/// Arguments for the creation of a ChannelManager that are not deserialized.
///
/// At a high-level, the process for deserializing a ChannelManager and resuming normal operation
/// is:
/// 1) Deserialize all stored [`ChannelMonitor`]s.
/// 2) Deserialize the [`ChannelManager`] by filling in this struct and calling:
///    `<(BlockHash, ChannelManager)>::read(reader, args)`
///    This may result in closing some channels if the [`ChannelMonitor`] is newer than the stored
///    [`ChannelManager`] state to ensure no loss of funds. Thus, transactions may be broadcasted.
/// 3) If you are not fetching full blocks, register all relevant [`ChannelMonitor`] outpoints the
///    same way you would handle a [`chain::Filter`] call using
///    [`ChannelMonitor::get_outputs_to_watch`] and [`ChannelMonitor::get_funding_txo`].
/// 4) Disconnect/connect blocks on your [`ChannelMonitor`]s to get them in sync with the chain.
/// 5) Disconnect/connect blocks on the [`ChannelManager`] to get it in sync with the chain.
/// 6) Optionally re-persist the [`ChannelMonitor`]s to ensure the latest state is on disk.
///    This is important if you have replayed a nontrivial number of blocks in step (4), allowing
///    you to avoid having to replay the same blocks if you shut down quickly after startup. It is
///    otherwise not required.
///    Note that if you're using a [`ChainMonitor`] for your [`chain::Watch`] implementation, you
///    will likely accomplish this as a side-effect of calling [`chain::Watch::watch_channel`] in
///    the next step.
/// 7) Move the [`ChannelMonitor`]s into your local [`chain::Watch`]. If you're using a
///    [`ChainMonitor`], this is done by calling [`chain::Watch::watch_channel`].
///
/// Note that the ordering of #4-7 is not of importance, however all four must occur before you
/// call any other methods on the newly-deserialized [`ChannelManager`].
///
/// Note that because some channels may be closed during deserialization, it is critical that you
/// always deserialize only the latest version of a ChannelManager and ChannelMonitors available to
/// you. If you deserialize an old ChannelManager (during which force-closure transactions may be
/// broadcast), and then later deserialize a newer version of the same ChannelManager (which will
/// not force-close the same channels but consider them live), you may end up revoking a state for
/// which you've already broadcasted the transaction.
///
/// [`ChainMonitor`]: crate::chain::chainmonitor::ChainMonitor
#[must_use]
#[repr(C)]
pub struct ChannelManagerReadArgs {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeChannelManagerReadArgs,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for ChannelManagerReadArgs {
	type Target = nativeChannelManagerReadArgs;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for ChannelManagerReadArgs { }
unsafe impl core::marker::Sync for ChannelManagerReadArgs { }
impl Drop for ChannelManagerReadArgs {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeChannelManagerReadArgs>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the ChannelManagerReadArgs, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_free(this_obj: ChannelManagerReadArgs) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChannelManagerReadArgs_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeChannelManagerReadArgs) };
}
#[allow(unused)]
impl ChannelManagerReadArgs {
	pub(crate) fn get_native_ref(&self) -> &'static nativeChannelManagerReadArgs {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeChannelManagerReadArgs {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeChannelManagerReadArgs {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// A cryptographically secure source of entropy.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_get_entropy_source(this_ptr: &ChannelManagerReadArgs) -> *const crate::lightning::sign::EntropySource {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().entropy_source;
	inner_val
}
/// A cryptographically secure source of entropy.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_set_entropy_source(this_ptr: &mut ChannelManagerReadArgs, mut val: crate::lightning::sign::EntropySource) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.entropy_source = val;
}
/// A signer that is able to perform node-scoped cryptographic operations.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_get_node_signer(this_ptr: &ChannelManagerReadArgs) -> *const crate::lightning::sign::NodeSigner {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().node_signer;
	inner_val
}
/// A signer that is able to perform node-scoped cryptographic operations.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_set_node_signer(this_ptr: &mut ChannelManagerReadArgs, mut val: crate::lightning::sign::NodeSigner) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.node_signer = val;
}
/// The keys provider which will give us relevant keys. Some keys will be loaded during
/// deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
/// signing data.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_get_signer_provider(this_ptr: &ChannelManagerReadArgs) -> *const crate::lightning::sign::SignerProvider {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().signer_provider;
	inner_val
}
/// The keys provider which will give us relevant keys. Some keys will be loaded during
/// deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
/// signing data.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_set_signer_provider(this_ptr: &mut ChannelManagerReadArgs, mut val: crate::lightning::sign::SignerProvider) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.signer_provider = val;
}
/// The fee_estimator for use in the ChannelManager in the future.
///
/// No calls to the FeeEstimator will be made during deserialization.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_get_fee_estimator(this_ptr: &ChannelManagerReadArgs) -> *const crate::lightning::chain::chaininterface::FeeEstimator {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().fee_estimator;
	inner_val
}
/// The fee_estimator for use in the ChannelManager in the future.
///
/// No calls to the FeeEstimator will be made during deserialization.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_set_fee_estimator(this_ptr: &mut ChannelManagerReadArgs, mut val: crate::lightning::chain::chaininterface::FeeEstimator) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.fee_estimator = val;
}
/// The chain::Watch for use in the ChannelManager in the future.
///
/// No calls to the chain::Watch will be made during deserialization. It is assumed that
/// you have deserialized ChannelMonitors separately and will add them to your
/// chain::Watch after deserializing this ChannelManager.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_get_chain_monitor(this_ptr: &ChannelManagerReadArgs) -> *const crate::lightning::chain::Watch {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().chain_monitor;
	inner_val
}
/// The chain::Watch for use in the ChannelManager in the future.
///
/// No calls to the chain::Watch will be made during deserialization. It is assumed that
/// you have deserialized ChannelMonitors separately and will add them to your
/// chain::Watch after deserializing this ChannelManager.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_set_chain_monitor(this_ptr: &mut ChannelManagerReadArgs, mut val: crate::lightning::chain::Watch) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.chain_monitor = val;
}
/// The BroadcasterInterface which will be used in the ChannelManager in the future and may be
/// used to broadcast the latest local commitment transactions of channels which must be
/// force-closed during deserialization.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_get_tx_broadcaster(this_ptr: &ChannelManagerReadArgs) -> *const crate::lightning::chain::chaininterface::BroadcasterInterface {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().tx_broadcaster;
	inner_val
}
/// The BroadcasterInterface which will be used in the ChannelManager in the future and may be
/// used to broadcast the latest local commitment transactions of channels which must be
/// force-closed during deserialization.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_set_tx_broadcaster(this_ptr: &mut ChannelManagerReadArgs, mut val: crate::lightning::chain::chaininterface::BroadcasterInterface) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.tx_broadcaster = val;
}
/// The router which will be used in the ChannelManager in the future for finding routes
/// on-the-fly for trampoline payments. Absent in private nodes that don't support forwarding.
///
/// No calls to the router will be made during deserialization.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_get_router(this_ptr: &ChannelManagerReadArgs) -> *const crate::lightning::routing::router::Router {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().router;
	inner_val
}
/// The router which will be used in the ChannelManager in the future for finding routes
/// on-the-fly for trampoline payments. Absent in private nodes that don't support forwarding.
///
/// No calls to the router will be made during deserialization.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_set_router(this_ptr: &mut ChannelManagerReadArgs, mut val: crate::lightning::routing::router::Router) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.router = val;
}
/// The [`MessageRouter`] used for constructing [`BlindedMessagePath`]s for [`Offer`]s,
/// [`Refund`]s, and any reply paths.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_get_message_router(this_ptr: &ChannelManagerReadArgs) -> *const crate::lightning::onion_message::messenger::MessageRouter {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().message_router;
	inner_val
}
/// The [`MessageRouter`] used for constructing [`BlindedMessagePath`]s for [`Offer`]s,
/// [`Refund`]s, and any reply paths.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_set_message_router(this_ptr: &mut ChannelManagerReadArgs, mut val: crate::lightning::onion_message::messenger::MessageRouter) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.message_router = val;
}
/// The Logger for use in the ChannelManager and which may be used to log information during
/// deserialization.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_get_logger(this_ptr: &ChannelManagerReadArgs) -> *const crate::lightning::util::logger::Logger {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().logger;
	inner_val
}
/// The Logger for use in the ChannelManager and which may be used to log information during
/// deserialization.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_set_logger(this_ptr: &mut ChannelManagerReadArgs, mut val: crate::lightning::util::logger::Logger) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.logger = val;
}
/// Default settings used for new channels. Any existing channels will continue to use the
/// runtime settings which were stored when the ChannelManager was serialized.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_get_default_config(this_ptr: &ChannelManagerReadArgs) -> crate::lightning::util::config::UserConfig {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().default_config;
	crate::lightning::util::config::UserConfig { inner: unsafe { ObjOps::nonnull_ptr_to_inner((inner_val as *const lightning::util::config::UserConfig<>) as *mut _) }, is_owned: false }
}
/// Default settings used for new channels. Any existing channels will continue to use the
/// runtime settings which were stored when the ChannelManager was serialized.
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_set_default_config(this_ptr: &mut ChannelManagerReadArgs, mut val: crate::lightning::util::config::UserConfig) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.default_config = *unsafe { Box::from_raw(val.take_inner()) };
}
/// Simple utility function to create a ChannelManagerReadArgs which creates the monitor
/// HashMap for you. This is primarily useful for C bindings where it is not practical to
/// populate a HashMap directly from C.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelManagerReadArgs_new(mut entropy_source: crate::lightning::sign::EntropySource, mut node_signer: crate::lightning::sign::NodeSigner, mut signer_provider: crate::lightning::sign::SignerProvider, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, mut chain_monitor: crate::lightning::chain::Watch, mut tx_broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut router: crate::lightning::routing::router::Router, mut message_router: crate::lightning::onion_message::messenger::MessageRouter, mut logger: crate::lightning::util::logger::Logger, mut default_config: crate::lightning::util::config::UserConfig, mut channel_monitors: crate::c_types::derived::CVec_ChannelMonitorZ) -> crate::lightning::ln::channelmanager::ChannelManagerReadArgs {
	let mut local_channel_monitors = Vec::new(); for mut item in channel_monitors.into_rust().drain(..) { local_channel_monitors.push( { item.get_native_ref() }); };
	let mut ret = lightning::ln::channelmanager::ChannelManagerReadArgs::new(entropy_source, node_signer, signer_provider, fee_estimator, chain_monitor, tx_broadcaster, router, message_router, logger, *unsafe { Box::from_raw(default_config.take_inner()) }, local_channel_monitors);
	crate::lightning::ln::channelmanager::ChannelManagerReadArgs { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

#[no_mangle]
/// Read a C2Tuple_ThirtyTwoBytesChannelManagerZ from a byte array, created by C2Tuple_ThirtyTwoBytesChannelManagerZ_write
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelManagerZ_read(ser: crate::c_types::u8slice, arg: crate::lightning::ln::channelmanager::ChannelManagerReadArgs) -> crate::c_types::derived::CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	let arg_conv = *unsafe { Box::from_raw(arg.take_inner()) };
	let res: Result<(bitcoin::hash_types::BlockHash, lightning::ln::channelmanager::ChannelManager<crate::lightning::chain::Watch, crate::lightning::chain::chaininterface::BroadcasterInterface, crate::lightning::sign::EntropySource, crate::lightning::sign::NodeSigner, crate::lightning::sign::SignerProvider, crate::lightning::chain::chaininterface::FeeEstimator, crate::lightning::routing::router::Router, crate::lightning::onion_message::messenger::MessageRouter, crate::lightning::util::logger::Logger>), lightning::ln::msgs::DecodeError> = crate::c_types::deserialize_obj_arg(ser, arg_conv);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { let (mut orig_res_0_0, mut orig_res_0_1) = o; let mut local_res_0 = (crate::c_types::ThirtyTwoBytes { data: *orig_res_0_0.as_ref() }, crate::lightning::ln::channelmanager::ChannelManager { inner: ObjOps::heap_alloc(orig_res_0_1), is_owned: true }).into(); local_res_0 }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_res
}
use crate::lightning::blinded_path::payment::nativeUnauthenticatedReceiveTlvs as nativeUnauthenticatedReceiveTlvs;
use crate::lightning::blinded_path::payment::UnauthenticatedReceiveTlvs;
use crate::lightning::blinded_path::payment::UnauthenticatedReceiveTlvs_free_void;
