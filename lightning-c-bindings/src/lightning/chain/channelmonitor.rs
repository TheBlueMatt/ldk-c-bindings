// This file is Copyright its original authors, visible in version control
// history and in the source files from which this was generated.
//
// This file is licensed under the license available in the LICENSE or LICENSE.md
// file in the root of this repository or, if no such file exists, the same
// license as that which applies to the original source files from which this
// source was automatically generated.

//! The logic to monitor for on-chain transactions and create the relevant claim responses lives
//! here.
//!
//! ChannelMonitor objects are generated by ChannelManager in response to relevant
//! messages/actions, and MUST be persisted to disk (and, preferably, remotely) before progress can
//! be made in responding to certain messages, see [`chain::Watch`] for more.
//!
//! Note that ChannelMonitors are an important part of the lightning trust model and a copy of the
//! latest ChannelMonitor must always be actively monitoring for chain updates (and no out-of-date
//! ChannelMonitors should do so). Thus, if you're building rust-lightning into an HSM or other
//! security-domain-separated system design, you should consider having multiple paths for
//! ChannelMonitors to get out of the HSM and onto monitoring devices.

use alloc::str::FromStr;
use alloc::string::String;
use core::ffi::c_void;
use core::convert::Infallible;
use bitcoin::hashes::Hash;
use crate::c_types::*;
#[cfg(feature="no-std")]
use alloc::{vec::Vec, boxed::Box};


use lightning::chain::channelmonitor::ChannelMonitorUpdate as nativeChannelMonitorUpdateImport;
pub(crate) type nativeChannelMonitorUpdate = nativeChannelMonitorUpdateImport;

/// An update generated by the underlying channel itself which contains some new information the
/// [`ChannelMonitor`] should be made aware of.
///
/// Because this represents only a small number of updates to the underlying state, it is generally
/// much smaller than a full [`ChannelMonitor`]. However, for large single commitment transaction
/// updates (e.g. ones during which there are hundreds of HTLCs pending on the commitment
/// transaction), a single update may reach upwards of 1 MiB in serialized size.
#[must_use]
#[repr(C)]
pub struct ChannelMonitorUpdate {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeChannelMonitorUpdate,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for ChannelMonitorUpdate {
	type Target = nativeChannelMonitorUpdate;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for ChannelMonitorUpdate { }
unsafe impl core::marker::Sync for ChannelMonitorUpdate { }
impl Drop for ChannelMonitorUpdate {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeChannelMonitorUpdate>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the ChannelMonitorUpdate, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_free(this_obj: ChannelMonitorUpdate) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChannelMonitorUpdate_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeChannelMonitorUpdate) };
}
#[allow(unused)]
impl ChannelMonitorUpdate {
	pub(crate) fn get_native_ref(&self) -> &'static nativeChannelMonitorUpdate {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeChannelMonitorUpdate {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeChannelMonitorUpdate {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
/// The sequence number of this update. Updates *must* be replayed in-order according to this
/// sequence number (and updates may panic if they are not). The update_id values are strictly
/// increasing and increase by one for each new update, with two exceptions specified below.
///
/// This sequence number is also used to track up to which points updates which returned
/// [`ChannelMonitorUpdateStatus::InProgress`] have been applied to all copies of a given
/// ChannelMonitor when ChannelManager::channel_monitor_updated is called.
///
/// The only instances we allow where update_id values are not strictly increasing have a
/// special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. This update ID is used for updates that
/// will force close the channel by broadcasting the latest commitment transaction or
/// special post-force-close updates, like providing preimages necessary to claim outputs on the
/// broadcast commitment transaction. See its docs for more details.
///
/// [`ChannelMonitorUpdateStatus::InProgress`]: super::ChannelMonitorUpdateStatus::InProgress
#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_get_update_id(this_ptr: &ChannelMonitorUpdate) -> u64 {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().update_id;
	*inner_val
}
/// The sequence number of this update. Updates *must* be replayed in-order according to this
/// sequence number (and updates may panic if they are not). The update_id values are strictly
/// increasing and increase by one for each new update, with two exceptions specified below.
///
/// This sequence number is also used to track up to which points updates which returned
/// [`ChannelMonitorUpdateStatus::InProgress`] have been applied to all copies of a given
/// ChannelMonitor when ChannelManager::channel_monitor_updated is called.
///
/// The only instances we allow where update_id values are not strictly increasing have a
/// special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. This update ID is used for updates that
/// will force close the channel by broadcasting the latest commitment transaction or
/// special post-force-close updates, like providing preimages necessary to claim outputs on the
/// broadcast commitment transaction. See its docs for more details.
///
/// [`ChannelMonitorUpdateStatus::InProgress`]: super::ChannelMonitorUpdateStatus::InProgress
#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_set_update_id(this_ptr: &mut ChannelMonitorUpdate, mut val: u64) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.update_id = val;
}
/// The channel ID associated with these updates.
///
/// Will be `None` for `ChannelMonitorUpdate`s constructed on LDK versions prior to 0.0.121 and
/// always `Some` otherwise.
///
/// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_get_channel_id(this_ptr: &ChannelMonitorUpdate) -> crate::lightning::ln::types::ChannelId {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().channel_id;
	let mut local_inner_val = crate::lightning::ln::types::ChannelId { inner: unsafe { (if inner_val.is_none() { core::ptr::null() } else { ObjOps::nonnull_ptr_to_inner( { (inner_val.as_ref().unwrap()) }) } as *const lightning::ln::types::ChannelId<>) as *mut _ }, is_owned: false };
	local_inner_val
}
/// The channel ID associated with these updates.
///
/// Will be `None` for `ChannelMonitorUpdate`s constructed on LDK versions prior to 0.0.121 and
/// always `Some` otherwise.
///
/// Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_set_channel_id(this_ptr: &mut ChannelMonitorUpdate, mut val: crate::lightning::ln::types::ChannelId) {
	let mut local_val = if val.inner.is_null() { None } else { Some( { *unsafe { Box::from_raw(val.take_inner()) } }) };
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.channel_id = local_val;
}
impl Clone for ChannelMonitorUpdate {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativeChannelMonitorUpdate>::is_null(self.inner) { core::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChannelMonitorUpdate_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const nativeChannelMonitorUpdate)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the ChannelMonitorUpdate
pub extern "C" fn ChannelMonitorUpdate_clone(orig: &ChannelMonitorUpdate) -> ChannelMonitorUpdate {
	orig.clone()
}
/// Get a string which allows debug introspection of a ChannelMonitorUpdate object
pub extern "C" fn ChannelMonitorUpdate_debug_str_void(o: *const c_void) -> Str {
	alloc::format!("{:?}", unsafe { o as *const crate::lightning::chain::channelmonitor::ChannelMonitorUpdate }).into()}
/// Checks if two ChannelMonitorUpdates contain equal inner contents.
/// This ignores pointers and is_owned flags and looks at the values in fields.
/// Two objects with NULL inner values will be considered "equal" here.
#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_eq(a: &ChannelMonitorUpdate, b: &ChannelMonitorUpdate) -> bool {
	if a.inner == b.inner { return true; }
	if a.inner.is_null() || b.inner.is_null() { return false; }
	if a.get_native_ref() == b.get_native_ref() { true } else { false }
}
/// The update ID used for a [`ChannelMonitorUpdate`] that is either:
///
///\t(1) attempting to force close the channel by broadcasting our latest commitment transaction or
///\t(2) providing a preimage (after the channel has been force closed) from a forward link that
///\t\tallows us to spend an HTLC output on this channel's (the backward link's) broadcasted
///\t\tcommitment transaction.
///
/// No other [`ChannelMonitorUpdate`]s are allowed after force-close.

#[no_mangle]
pub static CLOSED_CHANNEL_UPDATE_ID: u64 = lightning::chain::channelmonitor::CLOSED_CHANNEL_UPDATE_ID;
#[no_mangle]
/// Serialize the ChannelMonitorUpdate object into a byte array which can be read by ChannelMonitorUpdate_read
pub extern "C" fn ChannelMonitorUpdate_write(obj: &crate::lightning::chain::channelmonitor::ChannelMonitorUpdate) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*obj }.get_native_ref())
}
#[allow(unused)]
pub(crate) extern "C" fn ChannelMonitorUpdate_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*(obj as *const crate::lightning::chain::channelmonitor::nativeChannelMonitorUpdate) })
}
#[no_mangle]
/// Read a ChannelMonitorUpdate from a byte array, created by ChannelMonitorUpdate_write
pub extern "C" fn ChannelMonitorUpdate_read(ser: crate::c_types::u8slice) -> crate::c_types::derived::CResult_ChannelMonitorUpdateDecodeErrorZ {
	let res: Result<lightning::chain::channelmonitor::ChannelMonitorUpdate, lightning::ln::msgs::DecodeError> = crate::c_types::deserialize_obj(ser);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::chain::channelmonitor::ChannelMonitorUpdate { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_res
}
/// An event to be processed by the ChannelManager.
#[derive(Clone)]
#[must_use]
#[repr(C)]
pub enum MonitorEvent {
	/// A monitor event containing an HTLCUpdate.
	HTLCEvent(
		crate::lightning::chain::channelmonitor::HTLCUpdate),
	/// Indicates we broadcasted the channel's latest commitment transaction and thus closed the
	/// channel. Holds information about the channel and why it was closed.
	HolderForceClosedWithInfo {
		/// The reason the channel was closed.
		reason: crate::lightning::events::ClosureReason,
		/// The funding outpoint of the channel.
		outpoint: crate::lightning::chain::transaction::OutPoint,
		/// The channel ID of the channel.
		channel_id: crate::lightning::ln::types::ChannelId,
	},
	/// Indicates we broadcasted the channel's latest commitment transaction and thus closed the
	/// channel.
	HolderForceClosed(
		crate::lightning::chain::transaction::OutPoint),
	/// Indicates a [`ChannelMonitor`] update has completed. See
	/// [`ChannelMonitorUpdateStatus::InProgress`] for more information on how this is used.
	///
	/// [`ChannelMonitorUpdateStatus::InProgress`]: super::ChannelMonitorUpdateStatus::InProgress
	Completed {
		/// The funding outpoint of the [`ChannelMonitor`] that was updated
		funding_txo: crate::lightning::chain::transaction::OutPoint,
		/// The channel ID of the channel associated with the [`ChannelMonitor`]
		channel_id: crate::lightning::ln::types::ChannelId,
		/// The Update ID from [`ChannelMonitorUpdate::update_id`] which was applied or
		/// [`ChannelMonitor::get_latest_update_id`].
		///
		/// Note that this should only be set to a given update's ID if all previous updates for the
		/// same [`ChannelMonitor`] have been applied and persisted.
		monitor_update_id: u64,
	},
}
use lightning::chain::channelmonitor::MonitorEvent as MonitorEventImport;
pub(crate) type nativeMonitorEvent = MonitorEventImport;

impl MonitorEvent {
	#[allow(unused)]
	pub(crate) fn to_native(&self) -> nativeMonitorEvent {
		match self {
			MonitorEvent::HTLCEvent (ref a, ) => {
				let mut a_nonref = Clone::clone(a);
				nativeMonitorEvent::HTLCEvent (
					*unsafe { Box::from_raw(a_nonref.take_inner()) },
				)
			},
			MonitorEvent::HolderForceClosedWithInfo {ref reason, ref outpoint, ref channel_id, } => {
				let mut reason_nonref = Clone::clone(reason);
				let mut outpoint_nonref = Clone::clone(outpoint);
				let mut channel_id_nonref = Clone::clone(channel_id);
				nativeMonitorEvent::HolderForceClosedWithInfo {
					reason: reason_nonref.into_native(),
					outpoint: *unsafe { Box::from_raw(outpoint_nonref.take_inner()) },
					channel_id: *unsafe { Box::from_raw(channel_id_nonref.take_inner()) },
				}
			},
			MonitorEvent::HolderForceClosed (ref a, ) => {
				let mut a_nonref = Clone::clone(a);
				nativeMonitorEvent::HolderForceClosed (
					*unsafe { Box::from_raw(a_nonref.take_inner()) },
				)
			},
			MonitorEvent::Completed {ref funding_txo, ref channel_id, ref monitor_update_id, } => {
				let mut funding_txo_nonref = Clone::clone(funding_txo);
				let mut channel_id_nonref = Clone::clone(channel_id);
				let mut monitor_update_id_nonref = Clone::clone(monitor_update_id);
				nativeMonitorEvent::Completed {
					funding_txo: *unsafe { Box::from_raw(funding_txo_nonref.take_inner()) },
					channel_id: *unsafe { Box::from_raw(channel_id_nonref.take_inner()) },
					monitor_update_id: monitor_update_id_nonref,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn into_native(self) -> nativeMonitorEvent {
		match self {
			MonitorEvent::HTLCEvent (mut a, ) => {
				nativeMonitorEvent::HTLCEvent (
					*unsafe { Box::from_raw(a.take_inner()) },
				)
			},
			MonitorEvent::HolderForceClosedWithInfo {mut reason, mut outpoint, mut channel_id, } => {
				nativeMonitorEvent::HolderForceClosedWithInfo {
					reason: reason.into_native(),
					outpoint: *unsafe { Box::from_raw(outpoint.take_inner()) },
					channel_id: *unsafe { Box::from_raw(channel_id.take_inner()) },
				}
			},
			MonitorEvent::HolderForceClosed (mut a, ) => {
				nativeMonitorEvent::HolderForceClosed (
					*unsafe { Box::from_raw(a.take_inner()) },
				)
			},
			MonitorEvent::Completed {mut funding_txo, mut channel_id, mut monitor_update_id, } => {
				nativeMonitorEvent::Completed {
					funding_txo: *unsafe { Box::from_raw(funding_txo.take_inner()) },
					channel_id: *unsafe { Box::from_raw(channel_id.take_inner()) },
					monitor_update_id: monitor_update_id,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn from_native(native: &MonitorEventImport) -> Self {
		let native = unsafe { &*(native as *const _ as *const c_void as *const nativeMonitorEvent) };
		match native {
			nativeMonitorEvent::HTLCEvent (ref a, ) => {
				let mut a_nonref = Clone::clone(a);
				MonitorEvent::HTLCEvent (
					crate::lightning::chain::channelmonitor::HTLCUpdate { inner: ObjOps::heap_alloc(a_nonref), is_owned: true },
				)
			},
			nativeMonitorEvent::HolderForceClosedWithInfo {ref reason, ref outpoint, ref channel_id, } => {
				let mut reason_nonref = Clone::clone(reason);
				let mut outpoint_nonref = Clone::clone(outpoint);
				let mut channel_id_nonref = Clone::clone(channel_id);
				MonitorEvent::HolderForceClosedWithInfo {
					reason: crate::lightning::events::ClosureReason::native_into(reason_nonref),
					outpoint: crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(outpoint_nonref), is_owned: true },
					channel_id: crate::lightning::ln::types::ChannelId { inner: ObjOps::heap_alloc(channel_id_nonref), is_owned: true },
				}
			},
			nativeMonitorEvent::HolderForceClosed (ref a, ) => {
				let mut a_nonref = Clone::clone(a);
				MonitorEvent::HolderForceClosed (
					crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(a_nonref), is_owned: true },
				)
			},
			nativeMonitorEvent::Completed {ref funding_txo, ref channel_id, ref monitor_update_id, } => {
				let mut funding_txo_nonref = Clone::clone(funding_txo);
				let mut channel_id_nonref = Clone::clone(channel_id);
				let mut monitor_update_id_nonref = Clone::clone(monitor_update_id);
				MonitorEvent::Completed {
					funding_txo: crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(funding_txo_nonref), is_owned: true },
					channel_id: crate::lightning::ln::types::ChannelId { inner: ObjOps::heap_alloc(channel_id_nonref), is_owned: true },
					monitor_update_id: monitor_update_id_nonref,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn native_into(native: nativeMonitorEvent) -> Self {
		match native {
			nativeMonitorEvent::HTLCEvent (mut a, ) => {
				MonitorEvent::HTLCEvent (
					crate::lightning::chain::channelmonitor::HTLCUpdate { inner: ObjOps::heap_alloc(a), is_owned: true },
				)
			},
			nativeMonitorEvent::HolderForceClosedWithInfo {mut reason, mut outpoint, mut channel_id, } => {
				MonitorEvent::HolderForceClosedWithInfo {
					reason: crate::lightning::events::ClosureReason::native_into(reason),
					outpoint: crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(outpoint), is_owned: true },
					channel_id: crate::lightning::ln::types::ChannelId { inner: ObjOps::heap_alloc(channel_id), is_owned: true },
				}
			},
			nativeMonitorEvent::HolderForceClosed (mut a, ) => {
				MonitorEvent::HolderForceClosed (
					crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(a), is_owned: true },
				)
			},
			nativeMonitorEvent::Completed {mut funding_txo, mut channel_id, mut monitor_update_id, } => {
				MonitorEvent::Completed {
					funding_txo: crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(funding_txo), is_owned: true },
					channel_id: crate::lightning::ln::types::ChannelId { inner: ObjOps::heap_alloc(channel_id), is_owned: true },
					monitor_update_id: monitor_update_id,
				}
			},
		}
	}
}
/// Frees any resources used by the MonitorEvent
#[no_mangle]
pub extern "C" fn MonitorEvent_free(this_ptr: MonitorEvent) { }
/// Creates a copy of the MonitorEvent
#[no_mangle]
pub extern "C" fn MonitorEvent_clone(orig: &MonitorEvent) -> MonitorEvent {
	orig.clone()
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn MonitorEvent_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const MonitorEvent)).clone() })) as *mut c_void
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn MonitorEvent_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut MonitorEvent) };
}
#[no_mangle]
/// Utility method to constructs a new HTLCEvent-variant MonitorEvent
pub extern "C" fn MonitorEvent_htlcevent(a: crate::lightning::chain::channelmonitor::HTLCUpdate) -> MonitorEvent {
	MonitorEvent::HTLCEvent(a, )
}
#[no_mangle]
/// Utility method to constructs a new HolderForceClosedWithInfo-variant MonitorEvent
pub extern "C" fn MonitorEvent_holder_force_closed_with_info(reason: crate::lightning::events::ClosureReason, outpoint: crate::lightning::chain::transaction::OutPoint, channel_id: crate::lightning::ln::types::ChannelId) -> MonitorEvent {
	MonitorEvent::HolderForceClosedWithInfo {
		reason,
		outpoint,
		channel_id,
	}
}
#[no_mangle]
/// Utility method to constructs a new HolderForceClosed-variant MonitorEvent
pub extern "C" fn MonitorEvent_holder_force_closed(a: crate::lightning::chain::transaction::OutPoint) -> MonitorEvent {
	MonitorEvent::HolderForceClosed(a, )
}
#[no_mangle]
/// Utility method to constructs a new Completed-variant MonitorEvent
pub extern "C" fn MonitorEvent_completed(funding_txo: crate::lightning::chain::transaction::OutPoint, channel_id: crate::lightning::ln::types::ChannelId, monitor_update_id: u64) -> MonitorEvent {
	MonitorEvent::Completed {
		funding_txo,
		channel_id,
		monitor_update_id,
	}
}
/// Checks if two MonitorEvents contain equal inner contents.
/// This ignores pointers and is_owned flags and looks at the values in fields.
#[no_mangle]
pub extern "C" fn MonitorEvent_eq(a: &MonitorEvent, b: &MonitorEvent) -> bool {
	if &a.to_native() == &b.to_native() { true } else { false }
}
#[no_mangle]
/// Serialize the MonitorEvent object into a byte array which can be read by MonitorEvent_read
pub extern "C" fn MonitorEvent_write(obj: &crate::lightning::chain::channelmonitor::MonitorEvent) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(&unsafe { &*obj }.to_native())
}
#[allow(unused)]
pub(crate) extern "C" fn MonitorEvent_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	MonitorEvent_write(unsafe { &*(obj as *const MonitorEvent) })
}
#[no_mangle]
/// Read a MonitorEvent from a byte array, created by MonitorEvent_write
pub extern "C" fn MonitorEvent_read(ser: crate::c_types::u8slice) -> crate::c_types::derived::CResult_COption_MonitorEventZDecodeErrorZ {
	let res: Result<Option<lightning::chain::channelmonitor::MonitorEvent>, lightning::ln::msgs::DecodeError> = crate::c_types::maybe_deserialize_obj(ser);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { let mut local_res_0 = if o.is_none() { crate::c_types::derived::COption_MonitorEventZ::None } else { crate::c_types::derived::COption_MonitorEventZ::Some( { crate::lightning::chain::channelmonitor::MonitorEvent::native_into(o.unwrap()) }) }; local_res_0 }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_res
}

use lightning::chain::channelmonitor::HTLCUpdate as nativeHTLCUpdateImport;
pub(crate) type nativeHTLCUpdate = nativeHTLCUpdateImport;

/// Simple structure sent back by `chain::Watch` when an HTLC from a forward channel is detected on
/// chain. Used to update the corresponding HTLC in the backward channel. Failing to pass the
/// preimage claim backward will lead to loss of funds.
#[must_use]
#[repr(C)]
pub struct HTLCUpdate {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeHTLCUpdate,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for HTLCUpdate {
	type Target = nativeHTLCUpdate;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for HTLCUpdate { }
unsafe impl core::marker::Sync for HTLCUpdate { }
impl Drop for HTLCUpdate {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeHTLCUpdate>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the HTLCUpdate, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn HTLCUpdate_free(this_obj: HTLCUpdate) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn HTLCUpdate_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeHTLCUpdate) };
}
#[allow(unused)]
impl HTLCUpdate {
	pub(crate) fn get_native_ref(&self) -> &'static nativeHTLCUpdate {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeHTLCUpdate {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeHTLCUpdate {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
impl Clone for HTLCUpdate {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativeHTLCUpdate>::is_null(self.inner) { core::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn HTLCUpdate_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const nativeHTLCUpdate)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the HTLCUpdate
pub extern "C" fn HTLCUpdate_clone(orig: &HTLCUpdate) -> HTLCUpdate {
	orig.clone()
}
/// Checks if two HTLCUpdates contain equal inner contents.
/// This ignores pointers and is_owned flags and looks at the values in fields.
/// Two objects with NULL inner values will be considered "equal" here.
#[no_mangle]
pub extern "C" fn HTLCUpdate_eq(a: &HTLCUpdate, b: &HTLCUpdate) -> bool {
	if a.inner == b.inner { return true; }
	if a.inner.is_null() || b.inner.is_null() { return false; }
	if a.get_native_ref() == b.get_native_ref() { true } else { false }
}
#[no_mangle]
/// Serialize the HTLCUpdate object into a byte array which can be read by HTLCUpdate_read
pub extern "C" fn HTLCUpdate_write(obj: &crate::lightning::chain::channelmonitor::HTLCUpdate) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*obj }.get_native_ref())
}
#[allow(unused)]
pub(crate) extern "C" fn HTLCUpdate_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*(obj as *const crate::lightning::chain::channelmonitor::nativeHTLCUpdate) })
}
#[no_mangle]
/// Read a HTLCUpdate from a byte array, created by HTLCUpdate_write
pub extern "C" fn HTLCUpdate_read(ser: crate::c_types::u8slice) -> crate::c_types::derived::CResult_HTLCUpdateDecodeErrorZ {
	let res: Result<lightning::chain::channelmonitor::HTLCUpdate, lightning::ln::msgs::DecodeError> = crate::c_types::deserialize_obj(ser);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::chain::channelmonitor::HTLCUpdate { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_res
}
/// Number of blocks we wait on seeing a HTLC output being solved before we fail corresponding
/// inbound HTLCs. This prevents us from failing backwards and then getting a reorg resulting in us
/// losing money.
///
/// Note that this is a library-wide security assumption. If a reorg deeper than this number of
/// blocks occurs, counterparties may be able to steal funds or claims made by and balances exposed
/// by a  [`ChannelMonitor`] may be incorrect.

#[no_mangle]
pub static ANTI_REORG_DELAY: u32 = lightning::chain::channelmonitor::ANTI_REORG_DELAY;
/// Indicates whether the balance is derived from a cooperative close, a force-close
/// (for holder or counterparty), or whether it is for an HTLC.
#[derive(Clone)]
#[must_use]
#[repr(C)]
pub enum BalanceSource {
	/// The channel was force closed by the holder.
	HolderForceClosed,
	/// The channel was force closed by the counterparty.
	CounterpartyForceClosed,
	/// The channel was cooperatively closed.
	CoopClose,
	/// This balance is the result of an HTLC.
	Htlc,
}
use lightning::chain::channelmonitor::BalanceSource as BalanceSourceImport;
pub(crate) type nativeBalanceSource = BalanceSourceImport;

impl BalanceSource {
	#[allow(unused)]
	pub(crate) fn to_native(&self) -> nativeBalanceSource {
		match self {
			BalanceSource::HolderForceClosed => nativeBalanceSource::HolderForceClosed,
			BalanceSource::CounterpartyForceClosed => nativeBalanceSource::CounterpartyForceClosed,
			BalanceSource::CoopClose => nativeBalanceSource::CoopClose,
			BalanceSource::Htlc => nativeBalanceSource::Htlc,
		}
	}
	#[allow(unused)]
	pub(crate) fn into_native(self) -> nativeBalanceSource {
		match self {
			BalanceSource::HolderForceClosed => nativeBalanceSource::HolderForceClosed,
			BalanceSource::CounterpartyForceClosed => nativeBalanceSource::CounterpartyForceClosed,
			BalanceSource::CoopClose => nativeBalanceSource::CoopClose,
			BalanceSource::Htlc => nativeBalanceSource::Htlc,
		}
	}
	#[allow(unused)]
	pub(crate) fn from_native(native: &BalanceSourceImport) -> Self {
		let native = unsafe { &*(native as *const _ as *const c_void as *const nativeBalanceSource) };
		match native {
			nativeBalanceSource::HolderForceClosed => BalanceSource::HolderForceClosed,
			nativeBalanceSource::CounterpartyForceClosed => BalanceSource::CounterpartyForceClosed,
			nativeBalanceSource::CoopClose => BalanceSource::CoopClose,
			nativeBalanceSource::Htlc => BalanceSource::Htlc,
		}
	}
	#[allow(unused)]
	pub(crate) fn native_into(native: nativeBalanceSource) -> Self {
		match native {
			nativeBalanceSource::HolderForceClosed => BalanceSource::HolderForceClosed,
			nativeBalanceSource::CounterpartyForceClosed => BalanceSource::CounterpartyForceClosed,
			nativeBalanceSource::CoopClose => BalanceSource::CoopClose,
			nativeBalanceSource::Htlc => BalanceSource::Htlc,
		}
	}
}
/// Creates a copy of the BalanceSource
#[no_mangle]
pub extern "C" fn BalanceSource_clone(orig: &BalanceSource) -> BalanceSource {
	orig.clone()
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn BalanceSource_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const BalanceSource)).clone() })) as *mut c_void
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn BalanceSource_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut BalanceSource) };
}
#[no_mangle]
/// Utility method to constructs a new HolderForceClosed-variant BalanceSource
pub extern "C" fn BalanceSource_holder_force_closed() -> BalanceSource {
	BalanceSource::HolderForceClosed}
#[no_mangle]
/// Utility method to constructs a new CounterpartyForceClosed-variant BalanceSource
pub extern "C" fn BalanceSource_counterparty_force_closed() -> BalanceSource {
	BalanceSource::CounterpartyForceClosed}
#[no_mangle]
/// Utility method to constructs a new CoopClose-variant BalanceSource
pub extern "C" fn BalanceSource_coop_close() -> BalanceSource {
	BalanceSource::CoopClose}
#[no_mangle]
/// Utility method to constructs a new Htlc-variant BalanceSource
pub extern "C" fn BalanceSource_htlc() -> BalanceSource {
	BalanceSource::Htlc}
/// Get a string which allows debug introspection of a BalanceSource object
pub extern "C" fn BalanceSource_debug_str_void(o: *const c_void) -> Str {
	alloc::format!("{:?}", unsafe { o as *const crate::lightning::chain::channelmonitor::BalanceSource }).into()}
/// Checks if two BalanceSources contain equal inner contents.
/// This ignores pointers and is_owned flags and looks at the values in fields.
#[no_mangle]
pub extern "C" fn BalanceSource_eq(a: &BalanceSource, b: &BalanceSource) -> bool {
	if &a.to_native() == &b.to_native() { true } else { false }
}
/// Details about the balance(s) available for spending once the channel appears on chain.
///
/// See [`ChannelMonitor::get_claimable_balances`] for more details on when these will or will not
/// be provided.
#[derive(Clone)]
#[must_use]
#[repr(C)]
pub enum Balance {
	/// The channel is not yet closed (or the commitment or closing transaction has not yet
	/// appeared in a block). The given balance is claimable (less on-chain fees) if the channel is
	/// force-closed now.
	ClaimableOnChannelClose {
		/// The amount available to claim, in satoshis, excluding the on-chain fees which will be
		/// required to do so.
		amount_satoshis: u64,
		/// The transaction fee we pay for the closing commitment transaction. This amount is not
		/// included in the [`Balance::ClaimableOnChannelClose::amount_satoshis`] value.
		///
		/// Note that if this channel is inbound (and thus our counterparty pays the commitment
		/// transaction fee) this value will be zero. For [`ChannelMonitor`]s created prior to LDK
		/// 0.0.124, the channel is always treated as outbound (and thus this value is never zero).
		transaction_fee_satoshis: u64,
		/// The amount of millisatoshis which has been burned to fees from HTLCs which are outbound
		/// from us and are related to a payment which was sent by us. This is the sum of the
		/// millisatoshis part of all HTLCs which are otherwise represented by
		/// [`Balance::MaybeTimeoutClaimableHTLC`] with their
		/// [`Balance::MaybeTimeoutClaimableHTLC::outbound_payment`] flag set, as well as any dust
		/// HTLCs which would otherwise be represented the same.
		///
		/// This amount (rounded up to a whole satoshi value) will not be included in `amount_satoshis`.
		outbound_payment_htlc_rounded_msat: u64,
		/// The amount of millisatoshis which has been burned to fees from HTLCs which are outbound
		/// from us and are related to a forwarded HTLC. This is the sum of the millisatoshis part
		/// of all HTLCs which are otherwise represented by [`Balance::MaybeTimeoutClaimableHTLC`]
		/// with their [`Balance::MaybeTimeoutClaimableHTLC::outbound_payment`] flag *not* set, as
		/// well as any dust HTLCs which would otherwise be represented the same.
		///
		/// This amount (rounded up to a whole satoshi value) will not be included in `amount_satoshis`.
		outbound_forwarded_htlc_rounded_msat: u64,
		/// The amount of millisatoshis which has been burned to fees from HTLCs which are inbound
		/// to us and for which we know the preimage. This is the sum of the millisatoshis part of
		/// all HTLCs which would be represented by [`Balance::ContentiousClaimable`] on channel
		/// close, but whose current value is included in
		/// [`Balance::ClaimableOnChannelClose::amount_satoshis`], as well as any dust HTLCs which
		/// would otherwise be represented the same.
		///
		/// This amount (rounded up to a whole satoshi value) will not be included in the counterparty's
		/// `amount_satoshis`.
		inbound_claiming_htlc_rounded_msat: u64,
		/// The amount of millisatoshis which has been burned to fees from HTLCs which are inbound
		/// to us and for which we do not know the preimage. This is the sum of the millisatoshis
		/// part of all HTLCs which would be represented by [`Balance::MaybePreimageClaimableHTLC`]
		/// on channel close, as well as any dust HTLCs which would otherwise be represented the
		/// same.
		///
		/// This amount (rounded up to a whole satoshi value) will not be included in the counterparty's
		/// `amount_satoshis`.
		inbound_htlc_rounded_msat: u64,
	},
	/// The channel has been closed, and the given balance is ours but awaiting confirmations until
	/// we consider it spendable.
	ClaimableAwaitingConfirmations {
		/// The amount available to claim, in satoshis, possibly excluding the on-chain fees which
		/// were spent in broadcasting the transaction.
		amount_satoshis: u64,
		/// The height at which an [`Event::SpendableOutputs`] event will be generated for this
		/// amount.
		confirmation_height: u32,
		/// Whether this balance is a result of cooperative close, a force-close, or an HTLC.
		source: crate::lightning::chain::channelmonitor::BalanceSource,
	},
	/// The channel has been closed, and the given balance should be ours but awaiting spending
	/// transaction confirmation. If the spending transaction does not confirm in time, it is
	/// possible our counterparty can take the funds by broadcasting an HTLC timeout on-chain.
	///
	/// Once the spending transaction confirms, before it has reached enough confirmations to be
	/// considered safe from chain reorganizations, the balance will instead be provided via
	/// [`Balance::ClaimableAwaitingConfirmations`].
	ContentiousClaimable {
		/// The amount available to claim, in satoshis, excluding the on-chain fees which will be
		/// required to do so.
		amount_satoshis: u64,
		/// The height at which the counterparty may be able to claim the balance if we have not
		/// done so.
		timeout_height: u32,
		/// The payment hash that locks this HTLC.
		payment_hash: crate::c_types::ThirtyTwoBytes,
		/// The preimage that can be used to claim this HTLC.
		payment_preimage: crate::c_types::ThirtyTwoBytes,
	},
	/// HTLCs which we sent to our counterparty which are claimable after a timeout (less on-chain
	/// fees) if the counterparty does not know the preimage for the HTLCs. These are somewhat
	/// likely to be claimed by our counterparty before we do.
	MaybeTimeoutClaimableHTLC {
		/// The amount potentially available to claim, in satoshis, excluding the on-chain fees
		/// which will be required to do so.
		amount_satoshis: u64,
		/// The height at which we will be able to claim the balance if our counterparty has not
		/// done so.
		claimable_height: u32,
		/// The payment hash whose preimage our counterparty needs to claim this HTLC.
		payment_hash: crate::c_types::ThirtyTwoBytes,
		/// Whether this HTLC represents a payment which was sent outbound from us. Otherwise it
		/// represents an HTLC which was forwarded (and should, thus, have a corresponding inbound
		/// edge on another channel).
		outbound_payment: bool,
	},
	/// HTLCs which we received from our counterparty which are claimable with a preimage which we
	/// do not currently have. This will only be claimable if we receive the preimage from the node
	/// to which we forwarded this HTLC before the timeout.
	MaybePreimageClaimableHTLC {
		/// The amount potentially available to claim, in satoshis, excluding the on-chain fees
		/// which will be required to do so.
		amount_satoshis: u64,
		/// The height at which our counterparty will be able to claim the balance if we have not
		/// yet received the preimage and claimed it ourselves.
		expiry_height: u32,
		/// The payment hash whose preimage we need to claim this HTLC.
		payment_hash: crate::c_types::ThirtyTwoBytes,
	},
	/// The channel has been closed, and our counterparty broadcasted a revoked commitment
	/// transaction.
	///
	/// Thus, we're able to claim all outputs in the commitment transaction, one of which has the
	/// following amount.
	CounterpartyRevokedOutputClaimable {
		/// The amount, in satoshis, of the output which we can claim.
		///
		/// Note that for outputs from HTLC balances this may be excluding some on-chain fees that
		/// were already spent.
		amount_satoshis: u64,
	},
}
use lightning::chain::channelmonitor::Balance as BalanceImport;
pub(crate) type nativeBalance = BalanceImport;

impl Balance {
	#[allow(unused)]
	pub(crate) fn to_native(&self) -> nativeBalance {
		match self {
			Balance::ClaimableOnChannelClose {ref amount_satoshis, ref transaction_fee_satoshis, ref outbound_payment_htlc_rounded_msat, ref outbound_forwarded_htlc_rounded_msat, ref inbound_claiming_htlc_rounded_msat, ref inbound_htlc_rounded_msat, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				let mut transaction_fee_satoshis_nonref = Clone::clone(transaction_fee_satoshis);
				let mut outbound_payment_htlc_rounded_msat_nonref = Clone::clone(outbound_payment_htlc_rounded_msat);
				let mut outbound_forwarded_htlc_rounded_msat_nonref = Clone::clone(outbound_forwarded_htlc_rounded_msat);
				let mut inbound_claiming_htlc_rounded_msat_nonref = Clone::clone(inbound_claiming_htlc_rounded_msat);
				let mut inbound_htlc_rounded_msat_nonref = Clone::clone(inbound_htlc_rounded_msat);
				nativeBalance::ClaimableOnChannelClose {
					amount_satoshis: amount_satoshis_nonref,
					transaction_fee_satoshis: transaction_fee_satoshis_nonref,
					outbound_payment_htlc_rounded_msat: outbound_payment_htlc_rounded_msat_nonref,
					outbound_forwarded_htlc_rounded_msat: outbound_forwarded_htlc_rounded_msat_nonref,
					inbound_claiming_htlc_rounded_msat: inbound_claiming_htlc_rounded_msat_nonref,
					inbound_htlc_rounded_msat: inbound_htlc_rounded_msat_nonref,
				}
			},
			Balance::ClaimableAwaitingConfirmations {ref amount_satoshis, ref confirmation_height, ref source, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				let mut confirmation_height_nonref = Clone::clone(confirmation_height);
				let mut source_nonref = Clone::clone(source);
				nativeBalance::ClaimableAwaitingConfirmations {
					amount_satoshis: amount_satoshis_nonref,
					confirmation_height: confirmation_height_nonref,
					source: source_nonref.into_native(),
				}
			},
			Balance::ContentiousClaimable {ref amount_satoshis, ref timeout_height, ref payment_hash, ref payment_preimage, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				let mut timeout_height_nonref = Clone::clone(timeout_height);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				let mut payment_preimage_nonref = Clone::clone(payment_preimage);
				nativeBalance::ContentiousClaimable {
					amount_satoshis: amount_satoshis_nonref,
					timeout_height: timeout_height_nonref,
					payment_hash: ::lightning::ln::types::PaymentHash(payment_hash_nonref.data),
					payment_preimage: ::lightning::ln::types::PaymentPreimage(payment_preimage_nonref.data),
				}
			},
			Balance::MaybeTimeoutClaimableHTLC {ref amount_satoshis, ref claimable_height, ref payment_hash, ref outbound_payment, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				let mut claimable_height_nonref = Clone::clone(claimable_height);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				let mut outbound_payment_nonref = Clone::clone(outbound_payment);
				nativeBalance::MaybeTimeoutClaimableHTLC {
					amount_satoshis: amount_satoshis_nonref,
					claimable_height: claimable_height_nonref,
					payment_hash: ::lightning::ln::types::PaymentHash(payment_hash_nonref.data),
					outbound_payment: outbound_payment_nonref,
				}
			},
			Balance::MaybePreimageClaimableHTLC {ref amount_satoshis, ref expiry_height, ref payment_hash, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				let mut expiry_height_nonref = Clone::clone(expiry_height);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				nativeBalance::MaybePreimageClaimableHTLC {
					amount_satoshis: amount_satoshis_nonref,
					expiry_height: expiry_height_nonref,
					payment_hash: ::lightning::ln::types::PaymentHash(payment_hash_nonref.data),
				}
			},
			Balance::CounterpartyRevokedOutputClaimable {ref amount_satoshis, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				nativeBalance::CounterpartyRevokedOutputClaimable {
					amount_satoshis: amount_satoshis_nonref,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn into_native(self) -> nativeBalance {
		match self {
			Balance::ClaimableOnChannelClose {mut amount_satoshis, mut transaction_fee_satoshis, mut outbound_payment_htlc_rounded_msat, mut outbound_forwarded_htlc_rounded_msat, mut inbound_claiming_htlc_rounded_msat, mut inbound_htlc_rounded_msat, } => {
				nativeBalance::ClaimableOnChannelClose {
					amount_satoshis: amount_satoshis,
					transaction_fee_satoshis: transaction_fee_satoshis,
					outbound_payment_htlc_rounded_msat: outbound_payment_htlc_rounded_msat,
					outbound_forwarded_htlc_rounded_msat: outbound_forwarded_htlc_rounded_msat,
					inbound_claiming_htlc_rounded_msat: inbound_claiming_htlc_rounded_msat,
					inbound_htlc_rounded_msat: inbound_htlc_rounded_msat,
				}
			},
			Balance::ClaimableAwaitingConfirmations {mut amount_satoshis, mut confirmation_height, mut source, } => {
				nativeBalance::ClaimableAwaitingConfirmations {
					amount_satoshis: amount_satoshis,
					confirmation_height: confirmation_height,
					source: source.into_native(),
				}
			},
			Balance::ContentiousClaimable {mut amount_satoshis, mut timeout_height, mut payment_hash, mut payment_preimage, } => {
				nativeBalance::ContentiousClaimable {
					amount_satoshis: amount_satoshis,
					timeout_height: timeout_height,
					payment_hash: ::lightning::ln::types::PaymentHash(payment_hash.data),
					payment_preimage: ::lightning::ln::types::PaymentPreimage(payment_preimage.data),
				}
			},
			Balance::MaybeTimeoutClaimableHTLC {mut amount_satoshis, mut claimable_height, mut payment_hash, mut outbound_payment, } => {
				nativeBalance::MaybeTimeoutClaimableHTLC {
					amount_satoshis: amount_satoshis,
					claimable_height: claimable_height,
					payment_hash: ::lightning::ln::types::PaymentHash(payment_hash.data),
					outbound_payment: outbound_payment,
				}
			},
			Balance::MaybePreimageClaimableHTLC {mut amount_satoshis, mut expiry_height, mut payment_hash, } => {
				nativeBalance::MaybePreimageClaimableHTLC {
					amount_satoshis: amount_satoshis,
					expiry_height: expiry_height,
					payment_hash: ::lightning::ln::types::PaymentHash(payment_hash.data),
				}
			},
			Balance::CounterpartyRevokedOutputClaimable {mut amount_satoshis, } => {
				nativeBalance::CounterpartyRevokedOutputClaimable {
					amount_satoshis: amount_satoshis,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn from_native(native: &BalanceImport) -> Self {
		let native = unsafe { &*(native as *const _ as *const c_void as *const nativeBalance) };
		match native {
			nativeBalance::ClaimableOnChannelClose {ref amount_satoshis, ref transaction_fee_satoshis, ref outbound_payment_htlc_rounded_msat, ref outbound_forwarded_htlc_rounded_msat, ref inbound_claiming_htlc_rounded_msat, ref inbound_htlc_rounded_msat, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				let mut transaction_fee_satoshis_nonref = Clone::clone(transaction_fee_satoshis);
				let mut outbound_payment_htlc_rounded_msat_nonref = Clone::clone(outbound_payment_htlc_rounded_msat);
				let mut outbound_forwarded_htlc_rounded_msat_nonref = Clone::clone(outbound_forwarded_htlc_rounded_msat);
				let mut inbound_claiming_htlc_rounded_msat_nonref = Clone::clone(inbound_claiming_htlc_rounded_msat);
				let mut inbound_htlc_rounded_msat_nonref = Clone::clone(inbound_htlc_rounded_msat);
				Balance::ClaimableOnChannelClose {
					amount_satoshis: amount_satoshis_nonref,
					transaction_fee_satoshis: transaction_fee_satoshis_nonref,
					outbound_payment_htlc_rounded_msat: outbound_payment_htlc_rounded_msat_nonref,
					outbound_forwarded_htlc_rounded_msat: outbound_forwarded_htlc_rounded_msat_nonref,
					inbound_claiming_htlc_rounded_msat: inbound_claiming_htlc_rounded_msat_nonref,
					inbound_htlc_rounded_msat: inbound_htlc_rounded_msat_nonref,
				}
			},
			nativeBalance::ClaimableAwaitingConfirmations {ref amount_satoshis, ref confirmation_height, ref source, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				let mut confirmation_height_nonref = Clone::clone(confirmation_height);
				let mut source_nonref = Clone::clone(source);
				Balance::ClaimableAwaitingConfirmations {
					amount_satoshis: amount_satoshis_nonref,
					confirmation_height: confirmation_height_nonref,
					source: crate::lightning::chain::channelmonitor::BalanceSource::native_into(source_nonref),
				}
			},
			nativeBalance::ContentiousClaimable {ref amount_satoshis, ref timeout_height, ref payment_hash, ref payment_preimage, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				let mut timeout_height_nonref = Clone::clone(timeout_height);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				let mut payment_preimage_nonref = Clone::clone(payment_preimage);
				Balance::ContentiousClaimable {
					amount_satoshis: amount_satoshis_nonref,
					timeout_height: timeout_height_nonref,
					payment_hash: crate::c_types::ThirtyTwoBytes { data: payment_hash_nonref.0 },
					payment_preimage: crate::c_types::ThirtyTwoBytes { data: payment_preimage_nonref.0 },
				}
			},
			nativeBalance::MaybeTimeoutClaimableHTLC {ref amount_satoshis, ref claimable_height, ref payment_hash, ref outbound_payment, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				let mut claimable_height_nonref = Clone::clone(claimable_height);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				let mut outbound_payment_nonref = Clone::clone(outbound_payment);
				Balance::MaybeTimeoutClaimableHTLC {
					amount_satoshis: amount_satoshis_nonref,
					claimable_height: claimable_height_nonref,
					payment_hash: crate::c_types::ThirtyTwoBytes { data: payment_hash_nonref.0 },
					outbound_payment: outbound_payment_nonref,
				}
			},
			nativeBalance::MaybePreimageClaimableHTLC {ref amount_satoshis, ref expiry_height, ref payment_hash, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				let mut expiry_height_nonref = Clone::clone(expiry_height);
				let mut payment_hash_nonref = Clone::clone(payment_hash);
				Balance::MaybePreimageClaimableHTLC {
					amount_satoshis: amount_satoshis_nonref,
					expiry_height: expiry_height_nonref,
					payment_hash: crate::c_types::ThirtyTwoBytes { data: payment_hash_nonref.0 },
				}
			},
			nativeBalance::CounterpartyRevokedOutputClaimable {ref amount_satoshis, } => {
				let mut amount_satoshis_nonref = Clone::clone(amount_satoshis);
				Balance::CounterpartyRevokedOutputClaimable {
					amount_satoshis: amount_satoshis_nonref,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn native_into(native: nativeBalance) -> Self {
		match native {
			nativeBalance::ClaimableOnChannelClose {mut amount_satoshis, mut transaction_fee_satoshis, mut outbound_payment_htlc_rounded_msat, mut outbound_forwarded_htlc_rounded_msat, mut inbound_claiming_htlc_rounded_msat, mut inbound_htlc_rounded_msat, } => {
				Balance::ClaimableOnChannelClose {
					amount_satoshis: amount_satoshis,
					transaction_fee_satoshis: transaction_fee_satoshis,
					outbound_payment_htlc_rounded_msat: outbound_payment_htlc_rounded_msat,
					outbound_forwarded_htlc_rounded_msat: outbound_forwarded_htlc_rounded_msat,
					inbound_claiming_htlc_rounded_msat: inbound_claiming_htlc_rounded_msat,
					inbound_htlc_rounded_msat: inbound_htlc_rounded_msat,
				}
			},
			nativeBalance::ClaimableAwaitingConfirmations {mut amount_satoshis, mut confirmation_height, mut source, } => {
				Balance::ClaimableAwaitingConfirmations {
					amount_satoshis: amount_satoshis,
					confirmation_height: confirmation_height,
					source: crate::lightning::chain::channelmonitor::BalanceSource::native_into(source),
				}
			},
			nativeBalance::ContentiousClaimable {mut amount_satoshis, mut timeout_height, mut payment_hash, mut payment_preimage, } => {
				Balance::ContentiousClaimable {
					amount_satoshis: amount_satoshis,
					timeout_height: timeout_height,
					payment_hash: crate::c_types::ThirtyTwoBytes { data: payment_hash.0 },
					payment_preimage: crate::c_types::ThirtyTwoBytes { data: payment_preimage.0 },
				}
			},
			nativeBalance::MaybeTimeoutClaimableHTLC {mut amount_satoshis, mut claimable_height, mut payment_hash, mut outbound_payment, } => {
				Balance::MaybeTimeoutClaimableHTLC {
					amount_satoshis: amount_satoshis,
					claimable_height: claimable_height,
					payment_hash: crate::c_types::ThirtyTwoBytes { data: payment_hash.0 },
					outbound_payment: outbound_payment,
				}
			},
			nativeBalance::MaybePreimageClaimableHTLC {mut amount_satoshis, mut expiry_height, mut payment_hash, } => {
				Balance::MaybePreimageClaimableHTLC {
					amount_satoshis: amount_satoshis,
					expiry_height: expiry_height,
					payment_hash: crate::c_types::ThirtyTwoBytes { data: payment_hash.0 },
				}
			},
			nativeBalance::CounterpartyRevokedOutputClaimable {mut amount_satoshis, } => {
				Balance::CounterpartyRevokedOutputClaimable {
					amount_satoshis: amount_satoshis,
				}
			},
		}
	}
}
/// Frees any resources used by the Balance
#[no_mangle]
pub extern "C" fn Balance_free(this_ptr: Balance) { }
/// Creates a copy of the Balance
#[no_mangle]
pub extern "C" fn Balance_clone(orig: &Balance) -> Balance {
	orig.clone()
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn Balance_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const Balance)).clone() })) as *mut c_void
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn Balance_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut Balance) };
}
#[no_mangle]
/// Utility method to constructs a new ClaimableOnChannelClose-variant Balance
pub extern "C" fn Balance_claimable_on_channel_close(amount_satoshis: u64, transaction_fee_satoshis: u64, outbound_payment_htlc_rounded_msat: u64, outbound_forwarded_htlc_rounded_msat: u64, inbound_claiming_htlc_rounded_msat: u64, inbound_htlc_rounded_msat: u64) -> Balance {
	Balance::ClaimableOnChannelClose {
		amount_satoshis,
		transaction_fee_satoshis,
		outbound_payment_htlc_rounded_msat,
		outbound_forwarded_htlc_rounded_msat,
		inbound_claiming_htlc_rounded_msat,
		inbound_htlc_rounded_msat,
	}
}
#[no_mangle]
/// Utility method to constructs a new ClaimableAwaitingConfirmations-variant Balance
pub extern "C" fn Balance_claimable_awaiting_confirmations(amount_satoshis: u64, confirmation_height: u32, source: crate::lightning::chain::channelmonitor::BalanceSource) -> Balance {
	Balance::ClaimableAwaitingConfirmations {
		amount_satoshis,
		confirmation_height,
		source,
	}
}
#[no_mangle]
/// Utility method to constructs a new ContentiousClaimable-variant Balance
pub extern "C" fn Balance_contentious_claimable(amount_satoshis: u64, timeout_height: u32, payment_hash: crate::c_types::ThirtyTwoBytes, payment_preimage: crate::c_types::ThirtyTwoBytes) -> Balance {
	Balance::ContentiousClaimable {
		amount_satoshis,
		timeout_height,
		payment_hash,
		payment_preimage,
	}
}
#[no_mangle]
/// Utility method to constructs a new MaybeTimeoutClaimableHTLC-variant Balance
pub extern "C" fn Balance_maybe_timeout_claimable_htlc(amount_satoshis: u64, claimable_height: u32, payment_hash: crate::c_types::ThirtyTwoBytes, outbound_payment: bool) -> Balance {
	Balance::MaybeTimeoutClaimableHTLC {
		amount_satoshis,
		claimable_height,
		payment_hash,
		outbound_payment,
	}
}
#[no_mangle]
/// Utility method to constructs a new MaybePreimageClaimableHTLC-variant Balance
pub extern "C" fn Balance_maybe_preimage_claimable_htlc(amount_satoshis: u64, expiry_height: u32, payment_hash: crate::c_types::ThirtyTwoBytes) -> Balance {
	Balance::MaybePreimageClaimableHTLC {
		amount_satoshis,
		expiry_height,
		payment_hash,
	}
}
#[no_mangle]
/// Utility method to constructs a new CounterpartyRevokedOutputClaimable-variant Balance
pub extern "C" fn Balance_counterparty_revoked_output_claimable(amount_satoshis: u64) -> Balance {
	Balance::CounterpartyRevokedOutputClaimable {
		amount_satoshis,
	}
}
/// Get a string which allows debug introspection of a Balance object
pub extern "C" fn Balance_debug_str_void(o: *const c_void) -> Str {
	alloc::format!("{:?}", unsafe { o as *const crate::lightning::chain::channelmonitor::Balance }).into()}
/// Checks if two Balances contain equal inner contents.
/// This ignores pointers and is_owned flags and looks at the values in fields.
#[no_mangle]
pub extern "C" fn Balance_eq(a: &Balance, b: &Balance) -> bool {
	if &a.to_native() == &b.to_native() { true } else { false }
}
/// The amount claimable, in satoshis.
///
/// For outbound payments, this excludes the balance from the possible HTLC timeout.
///
/// For forwarded payments, this includes the balance from the possible HTLC timeout as
/// (to be conservative) that balance does not include routing fees we'd earn if we'd claim
/// the balance from a preimage in a successful forward.
///
/// For more information on these balances see [`Balance::MaybeTimeoutClaimableHTLC`] and
/// [`Balance::MaybePreimageClaimableHTLC`].
///
/// On-chain fees required to claim the balance are not included in this amount.
#[must_use]
#[no_mangle]
pub extern "C" fn Balance_claimable_amount_satoshis(this_arg: &crate::lightning::chain::channelmonitor::Balance) -> u64 {
	let mut ret = this_arg.to_native().claimable_amount_satoshis();
	ret
}


use lightning::chain::channelmonitor::ChannelMonitor as nativeChannelMonitorImport;
pub(crate) type nativeChannelMonitor = nativeChannelMonitorImport<crate::lightning::sign::ecdsa::EcdsaChannelSigner, >;

/// A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
/// on-chain transactions to ensure no loss of funds occurs.
///
/// You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
/// information and are actively monitoring the chain.
///
/// Note that the deserializer is only implemented for (BlockHash, ChannelMonitor), which
/// tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
/// the \"reorg path\" (ie disconnecting blocks until you find a common ancestor from both the
/// returned block hash and the the current chain and then reconnecting blocks to get to the
/// best chain) upon deserializing the object!
#[must_use]
#[repr(C)]
pub struct ChannelMonitor {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeChannelMonitor,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl core::ops::Deref for ChannelMonitor {
	type Target = nativeChannelMonitor;
	fn deref(&self) -> &Self::Target { unsafe { &*ObjOps::untweak_ptr(self.inner) } }
}
unsafe impl core::marker::Send for ChannelMonitor { }
unsafe impl core::marker::Sync for ChannelMonitor { }
impl Drop for ChannelMonitor {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeChannelMonitor>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the ChannelMonitor, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn ChannelMonitor_free(this_obj: ChannelMonitor) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChannelMonitor_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeChannelMonitor) };
}
#[allow(unused)]
impl ChannelMonitor {
	pub(crate) fn get_native_ref(&self) -> &'static nativeChannelMonitor {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeChannelMonitor {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeChannelMonitor {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
	pub(crate) fn as_ref_to(&self) -> Self {
		Self { inner: self.inner, is_owned: false }
	}
}
impl Clone for ChannelMonitor {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativeChannelMonitor>::is_null(self.inner) { core::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChannelMonitor_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *const nativeChannelMonitor)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the ChannelMonitor
pub extern "C" fn ChannelMonitor_clone(orig: &ChannelMonitor) -> ChannelMonitor {
	orig.clone()
}
#[no_mangle]
/// Serialize the ChannelMonitor object into a byte array which can be read by ChannelMonitor_read
pub extern "C" fn ChannelMonitor_write(obj: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*obj }.get_native_ref())
}
#[allow(unused)]
pub(crate) extern "C" fn ChannelMonitor_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*(obj as *const crate::lightning::chain::channelmonitor::nativeChannelMonitor) })
}
/// Updates a ChannelMonitor on the basis of some new information provided by the Channel
/// itself.
///
/// panics if the given update is not the next update by update_id.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_update_monitor(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, updates: &crate::lightning::chain::channelmonitor::ChannelMonitorUpdate, broadcaster: &crate::lightning::chain::chaininterface::BroadcasterInterface, fee_estimator: &crate::lightning::chain::chaininterface::FeeEstimator, logger: &crate::lightning::util::logger::Logger) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.update_monitor(updates.get_native_ref(), broadcaster, fee_estimator, logger);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}

/// Gets the update_id from the latest ChannelMonitorUpdate which was applied to this
/// ChannelMonitor.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_latest_update_id(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> u64 {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_latest_update_id();
	ret
}

/// Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_funding_txo(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> crate::c_types::derived::C2Tuple_OutPointCVec_u8ZZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_funding_txo();
	let (mut orig_ret_0, mut orig_ret_1) = ret; let mut local_ret = (crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(orig_ret_0), is_owned: true }, orig_ret_1.to_bytes().into()).into();
	local_ret
}

/// Gets the channel_id of the channel this ChannelMonitor is monitoring for.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_channel_id(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> crate::lightning::ln::types::ChannelId {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.channel_id();
	crate::lightning::ln::types::ChannelId { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Gets a list of txids, with their output scripts (in the order they appear in the
/// transaction), which we must learn about spends of via block_connected().
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_outputs_to_watch(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_outputs_to_watch();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_orig_ret_0_1 = Vec::new(); for mut item in orig_ret_0_1.drain(..) { local_orig_ret_0_1.push( { let (mut orig_orig_ret_0_1_0_0, mut orig_orig_ret_0_1_0_1) = item; let mut local_orig_ret_0_1_0 = (orig_orig_ret_0_1_0_0, orig_orig_ret_0_1_0_1.to_bytes().into()).into(); local_orig_ret_0_1_0 }); }; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: *orig_ret_0_0.as_ref() }, local_orig_ret_0_1.into()).into(); local_ret_0 }); };
	local_ret.into()
}

/// Loads the funding txo and outputs to watch into the given `chain::Filter` by repeatedly
/// calling `chain::Filter::register_output` and `chain::Filter::register_tx` until all outputs
/// have been registered.
#[no_mangle]
pub extern "C" fn ChannelMonitor_load_outputs_to_watch(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, filter: &crate::lightning::chain::Filter, logger: &crate::lightning::util::logger::Logger) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.load_outputs_to_watch(filter, logger)
}

/// Get the list of HTLCs who's status has been updated on chain. This should be called by
/// ChannelManager via [`chain::Watch::release_pending_monitor_events`].
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_and_clear_pending_monitor_events(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> crate::c_types::derived::CVec_MonitorEventZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_and_clear_pending_monitor_events();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::chain::channelmonitor::MonitorEvent::native_into(item) }); };
	local_ret.into()
}

/// Processes [`SpendableOutputs`] events produced from each [`ChannelMonitor`] upon maturity.
///
/// For channels featuring anchor outputs, this method will also process [`BumpTransaction`]
/// events produced from each [`ChannelMonitor`] while there is a balance to claim onchain
/// within each channel. As the confirmation of a commitment transaction may be critical to the
/// safety of funds, we recommend invoking this every 30 seconds, or lower if running in an
/// environment with spotty connections, like on mobile.
///
/// An [`EventHandler`] may safely call back to the provider, though this shouldn't be needed in
/// order to handle these events.
///
/// Will return a [`ReplayEvent`] error if event handling failed and should eventually be retried.
///
/// [`SpendableOutputs`]: crate::events::Event::SpendableOutputs
/// [`BumpTransaction`]: crate::events::Event::BumpTransaction
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_process_pending_events(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, handler: &crate::lightning::events::EventHandler) -> crate::c_types::derived::CResult_NoneReplayEventZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.process_pending_events(handler);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::events::ReplayEvent { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}

/// Gets the counterparty's initial commitment transaction. The returned commitment
/// transaction is unsigned. This is intended to be called during the initial persistence of
/// the monitor (inside an implementation of [`Persist::persist_new_channel`]), to allow for
/// watchtowers in the persistence pipeline to have enough data to form justice transactions.
///
/// This is similar to [`Self::counterparty_commitment_txs_from_update`], except
/// that for the initial commitment transaction, we don't have a corresponding update.
///
/// This will only return `Some` for channel monitors that have been created after upgrading
/// to LDK 0.0.117+.
///
/// [`Persist::persist_new_channel`]: crate::chain::chainmonitor::Persist::persist_new_channel
///
/// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_initial_counterparty_commitment_tx(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> crate::lightning::ln::chan_utils::CommitmentTransaction {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.initial_counterparty_commitment_tx();
	let mut local_ret = crate::lightning::ln::chan_utils::CommitmentTransaction { inner: if ret.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((ret.unwrap())) } }, is_owned: true };
	local_ret
}

/// Gets all of the counterparty commitment transactions provided by the given update. This
/// may be empty if the update doesn't include any new counterparty commitments. Returned
/// commitment transactions are unsigned.
///
/// This is provided so that watchtower clients in the persistence pipeline are able to build
/// justice transactions for each counterparty commitment upon each update. It's intended to be
/// used within an implementation of [`Persist::update_persisted_channel`], which is provided
/// with a monitor and an update. Once revoked, signing a justice transaction can be done using
/// [`Self::sign_to_local_justice_tx`].
///
/// It is expected that a watchtower client may use this method to retrieve the latest counterparty
/// commitment transaction(s), and then hold the necessary data until a later update in which
/// the monitor has been updated with the corresponding revocation data, at which point the
/// monitor can sign the justice transaction.
///
/// This will only return a non-empty list for monitor updates that have been created after
/// upgrading to LDK 0.0.117+. Note that no restriction lies on the monitors themselves, which
/// may have been created prior to upgrading.
///
/// [`Persist::update_persisted_channel`]: crate::chain::chainmonitor::Persist::update_persisted_channel
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_counterparty_commitment_txs_from_update(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, update: &crate::lightning::chain::channelmonitor::ChannelMonitorUpdate) -> crate::c_types::derived::CVec_CommitmentTransactionZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.counterparty_commitment_txs_from_update(update.get_native_ref());
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::ln::chan_utils::CommitmentTransaction { inner: ObjOps::heap_alloc(item), is_owned: true } }); };
	local_ret.into()
}

/// Wrapper around [`EcdsaChannelSigner::sign_justice_revoked_output`] to make
/// signing the justice transaction easier for implementors of
/// [`chain::chainmonitor::Persist`]. On success this method returns the provided transaction
/// signing the input at `input_idx`. This method will only produce a valid signature for
/// a transaction spending the `to_local` output of a commitment transaction, i.e. this cannot
/// be used for revoked HTLC outputs.
///
/// `Value` is the value of the output being spent by the input at `input_idx`, committed
/// in the BIP 143 signature.
///
/// This method will only succeed if this monitor has received the revocation secret for the
/// provided `commitment_number`. If a commitment number is provided that does not correspond
/// to the commitment transaction being revoked, this will return a signed transaction, but
/// the signature will not be valid.
///
/// [`EcdsaChannelSigner::sign_justice_revoked_output`]: crate::sign::ecdsa::EcdsaChannelSigner::sign_justice_revoked_output
/// [`Persist`]: crate::chain::chainmonitor::Persist
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_sign_to_local_justice_tx(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, mut justice_tx: crate::c_types::Transaction, mut input_idx: usize, mut value: u64, mut commitment_number: u64) -> crate::c_types::derived::CResult_TransactionNoneZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.sign_to_local_justice_tx(justice_tx.into_bitcoin(), input_idx, value, commitment_number);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::c_types::Transaction::from_bitcoin(&o) }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}

/// Gets the `node_id` of the counterparty for this channel.
///
/// Will be `None` for channels constructed on LDK versions prior to 0.0.110 and always `Some`
/// otherwise.
///
/// Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_counterparty_node_id(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> crate::c_types::PublicKey {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_counterparty_node_id();
	let mut local_ret = if ret.is_none() { crate::c_types::PublicKey::null() } else {  { crate::c_types::PublicKey::from_rust(&(ret.unwrap())) } };
	local_ret
}

/// You may use this to broadcast the latest local commitment transaction, either because
/// a monitor update failed or because we've fallen behind (i.e. we've received proof that our
/// counterparty side knows a revocation secret we gave them that they shouldn't know).
///
/// Broadcasting these transactions in this manner is UNSAFE, as they allow counterparty
/// side to punish you. Nevertheless you may want to broadcast them if counterparty doesn't
/// close channel with their commitment transaction after a substantial amount of time. Best
/// may be to contact the other node operator out-of-band to coordinate other options available
/// to you.
#[no_mangle]
pub extern "C" fn ChannelMonitor_broadcast_latest_holder_commitment_txn(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, broadcaster: &crate::lightning::chain::chaininterface::BroadcasterInterface, fee_estimator: &crate::lightning::chain::chaininterface::FeeEstimator, logger: &crate::lightning::util::logger::Logger) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.broadcast_latest_holder_commitment_txn(broadcaster, fee_estimator, logger)
}

/// Processes transactions in a newly connected block, which may result in any of the following:
/// - update the monitor's state against resolved HTLCs
/// - punish the counterparty in the case of seeing a revoked commitment transaction
/// - force close the channel and claim/timeout incoming/outgoing HTLCs if near expiration
/// - detect settled outputs for later spending
/// - schedule and bump any in-flight claims
///
/// Returns any new outputs to watch from `txdata`; after called, these are also included in
/// [`get_outputs_to_watch`].
///
/// [`get_outputs_to_watch`]: #method.get_outputs_to_watch
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_block_connected(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, header: *const [u8; 80], mut txdata: crate::c_types::derived::CVec_C2Tuple_usizeTransactionZZ, mut height: u32, mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, logger: &crate::lightning::util::logger::Logger) -> crate::c_types::derived::CVec_TransactionOutputsZ {
	let mut local_txdata = Vec::new(); for mut item in txdata.into_rust().drain(..) { local_txdata.push( { let (mut orig_txdata_0_0, mut orig_txdata_0_1) = item.to_rust(); let mut local_txdata_0 = (orig_txdata_0_0, orig_txdata_0_1.into_bitcoin()); local_txdata_0 }); };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.block_connected(&::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), &local_txdata.iter().map(|(a, b)| (*a, b)).collect::<Vec<_>>()[..], height, broadcaster, fee_estimator, logger);
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_orig_ret_0_1 = Vec::new(); for mut item in orig_ret_0_1.drain(..) { local_orig_ret_0_1.push( { let (mut orig_orig_ret_0_1_0_0, mut orig_orig_ret_0_1_0_1) = item; let mut local_orig_ret_0_1_0 = (orig_orig_ret_0_1_0_0, crate::c_types::TxOut::from_rust(&orig_orig_ret_0_1_0_1)).into(); local_orig_ret_0_1_0 }); }; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: *orig_ret_0_0.as_ref() }, local_orig_ret_0_1.into()).into(); local_ret_0 }); };
	local_ret.into()
}

/// Determines if the disconnected block contained any transactions of interest and updates
/// appropriately.
#[no_mangle]
pub extern "C" fn ChannelMonitor_block_disconnected(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, header: *const [u8; 80], mut height: u32, mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, logger: &crate::lightning::util::logger::Logger) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.block_disconnected(&::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), height, broadcaster, fee_estimator, logger)
}

/// Processes transactions confirmed in a block with the given header and height, returning new
/// outputs to watch. See [`block_connected`] for details.
///
/// Used instead of [`block_connected`] by clients that are notified of transactions rather than
/// blocks. See [`chain::Confirm`] for calling expectations.
///
/// [`block_connected`]: Self::block_connected
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_transactions_confirmed(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, header: *const [u8; 80], mut txdata: crate::c_types::derived::CVec_C2Tuple_usizeTransactionZZ, mut height: u32, mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, logger: &crate::lightning::util::logger::Logger) -> crate::c_types::derived::CVec_TransactionOutputsZ {
	let mut local_txdata = Vec::new(); for mut item in txdata.into_rust().drain(..) { local_txdata.push( { let (mut orig_txdata_0_0, mut orig_txdata_0_1) = item.to_rust(); let mut local_txdata_0 = (orig_txdata_0_0, orig_txdata_0_1.into_bitcoin()); local_txdata_0 }); };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.transactions_confirmed(&::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), &local_txdata.iter().map(|(a, b)| (*a, b)).collect::<Vec<_>>()[..], height, broadcaster, fee_estimator, logger);
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_orig_ret_0_1 = Vec::new(); for mut item in orig_ret_0_1.drain(..) { local_orig_ret_0_1.push( { let (mut orig_orig_ret_0_1_0_0, mut orig_orig_ret_0_1_0_1) = item; let mut local_orig_ret_0_1_0 = (orig_orig_ret_0_1_0_0, crate::c_types::TxOut::from_rust(&orig_orig_ret_0_1_0_1)).into(); local_orig_ret_0_1_0 }); }; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: *orig_ret_0_0.as_ref() }, local_orig_ret_0_1.into()).into(); local_ret_0 }); };
	local_ret.into()
}

/// Processes a transaction that was reorganized out of the chain.
///
/// Used instead of [`block_disconnected`] by clients that are notified of transactions rather
/// than blocks. See [`chain::Confirm`] for calling expectations.
///
/// [`block_disconnected`]: Self::block_disconnected
#[no_mangle]
pub extern "C" fn ChannelMonitor_transaction_unconfirmed(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, txid: *const [u8; 32], mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, logger: &crate::lightning::util::logger::Logger) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.transaction_unconfirmed(&::bitcoin::hash_types::Txid::from_slice(&unsafe { &*txid }[..]).unwrap(), broadcaster, fee_estimator, logger)
}

/// Updates the monitor with the current best chain tip, returning new outputs to watch. See
/// [`block_connected`] for details.
///
/// Used instead of [`block_connected`] by clients that are notified of transactions rather than
/// blocks. See [`chain::Confirm`] for calling expectations.
///
/// [`block_connected`]: Self::block_connected
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_best_block_updated(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, header: *const [u8; 80], mut height: u32, mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, logger: &crate::lightning::util::logger::Logger) -> crate::c_types::derived::CVec_TransactionOutputsZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.best_block_updated(&::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), height, broadcaster, fee_estimator, logger);
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_orig_ret_0_1 = Vec::new(); for mut item in orig_ret_0_1.drain(..) { local_orig_ret_0_1.push( { let (mut orig_orig_ret_0_1_0_0, mut orig_orig_ret_0_1_0_1) = item; let mut local_orig_ret_0_1_0 = (orig_orig_ret_0_1_0_0, crate::c_types::TxOut::from_rust(&orig_orig_ret_0_1_0_1)).into(); local_orig_ret_0_1_0 }); }; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: *orig_ret_0_0.as_ref() }, local_orig_ret_0_1.into()).into(); local_ret_0 }); };
	local_ret.into()
}

/// Returns the set of txids that should be monitored for re-organization out of the chain.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_relevant_txids(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> crate::c_types::derived::CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_relevant_txids();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1, mut orig_ret_0_2) = item; let mut local_orig_ret_0_2 = if orig_ret_0_2.is_none() { crate::c_types::derived::COption_ThirtyTwoBytesZ::None } else { crate::c_types::derived::COption_ThirtyTwoBytesZ::Some( { crate::c_types::ThirtyTwoBytes { data: *orig_ret_0_2.unwrap().as_ref() } }) }; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: *orig_ret_0_0.as_ref() }, orig_ret_0_1, local_orig_ret_0_2).into(); local_ret_0 }); };
	local_ret.into()
}

/// Gets the latest best block which was connected either via the [`chain::Listen`] or
/// [`chain::Confirm`] interfaces.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_current_best_block(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> crate::lightning::chain::BestBlock {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.current_best_block();
	crate::lightning::chain::BestBlock { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Triggers rebroadcasts/fee-bumps of pending claims from a force-closed channel. This is
/// crucial in preventing certain classes of pinning attacks, detecting substantial mempool
/// feerate changes between blocks, and ensuring reliability if broadcasting fails. We recommend
/// invoking this every 30 seconds, or lower if running in an environment with spotty
/// connections, like on mobile.
#[no_mangle]
pub extern "C" fn ChannelMonitor_rebroadcast_pending_claims(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, logger: &crate::lightning::util::logger::Logger) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.rebroadcast_pending_claims(broadcaster, fee_estimator, logger)
}

/// Returns true if the monitor has pending claim requests that are not fully confirmed yet.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_has_pending_claims(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> bool {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.has_pending_claims();
	ret
}

/// Triggers rebroadcasts of pending claims from a force-closed channel after a transaction
/// signature generation failure.
#[no_mangle]
pub extern "C" fn ChannelMonitor_signer_unblocked(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, logger: &crate::lightning::util::logger::Logger) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.signer_unblocked(broadcaster, fee_estimator, logger)
}

/// Returns the descriptors for relevant outputs (i.e., those that we can spend) within the
/// transaction if they exist and the transaction has at least [`ANTI_REORG_DELAY`]
/// confirmations. For [`SpendableOutputDescriptor::DelayedPaymentOutput`] descriptors to be
/// returned, the transaction must have at least `max(ANTI_REORG_DELAY, to_self_delay)`
/// confirmations.
///
/// Descriptors returned by this method are primarily exposed via [`Event::SpendableOutputs`]
/// once they are no longer under reorg risk. This method serves as a way to retrieve these
/// descriptors at a later time, either for historical purposes, or to replay any
/// missed/unhandled descriptors. For the purpose of gathering historical records, if the
/// channel close has fully resolved (i.e., [`ChannelMonitor::get_claimable_balances`] returns
/// an empty set), you can retrieve all spendable outputs by providing all descendant spending
/// transactions starting from the channel's funding transaction and going down three levels.
///
/// `tx` is a transaction we'll scan the outputs of. Any transaction can be provided. If any
/// outputs which can be spent by us are found, at least one descriptor is returned.
///
/// `confirmation_height` must be the height of the block in which `tx` was included in.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_spendable_outputs(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, mut tx: crate::c_types::Transaction, mut confirmation_height: u32) -> crate::c_types::derived::CVec_SpendableOutputDescriptorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_spendable_outputs(&tx.into_bitcoin(), confirmation_height);
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::sign::SpendableOutputDescriptor::native_into(item) }); };
	local_ret.into()
}

/// Checks if the monitor is fully resolved. Resolved monitor is one that has claimed all of
/// its outputs and balances (i.e. [`Self::get_claimable_balances`] returns an empty set).
///
/// This function returns true only if [`Self::get_claimable_balances`] has been empty for at least
/// 4032 blocks as an additional protection against any bugs resulting in spuriously empty balance sets.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_is_fully_resolved(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor, logger: &crate::lightning::util::logger::Logger) -> bool {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.is_fully_resolved(logger);
	ret
}

/// Gets the balances in this channel which are either claimable by us if we were to
/// force-close the channel now or which are claimable on-chain (possibly awaiting
/// confirmation).
///
/// Any balances in the channel which are available on-chain (excluding on-chain fees) are
/// included here until an [`Event::SpendableOutputs`] event has been generated for the
/// balance, or until our counterparty has claimed the balance and accrued several
/// confirmations on the claim transaction.
///
/// Note that for `ChannelMonitors` which track a channel which went on-chain with versions of
/// LDK prior to 0.0.111, not all or excess balances may be included.
///
/// See [`Balance`] for additional details on the types of claimable balances which
/// may be returned here and their meanings.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_claimable_balances(this_arg: &crate::lightning::chain::channelmonitor::ChannelMonitor) -> crate::c_types::derived::CVec_BalanceZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_claimable_balances();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::chain::channelmonitor::Balance::native_into(item) }); };
	local_ret.into()
}

#[no_mangle]
/// Read a C2Tuple_ThirtyTwoBytesChannelMonitorZ from a byte array, created by C2Tuple_ThirtyTwoBytesChannelMonitorZ_write
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelMonitorZ_read(ser: crate::c_types::u8slice, arg_a: &crate::lightning::sign::EntropySource, arg_b: &crate::lightning::sign::SignerProvider) -> crate::c_types::derived::CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	let arg_a_conv = arg_a;
	let arg_b_conv = arg_b;
	let arg_conv = (arg_a_conv, arg_b_conv);
	let res: Result<(bitcoin::hash_types::BlockHash, lightning::chain::channelmonitor::ChannelMonitor<crate::lightning::sign::ecdsa::EcdsaChannelSigner>), lightning::ln::msgs::DecodeError> = crate::c_types::deserialize_obj_arg(ser, arg_conv);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { let (mut orig_res_0_0, mut orig_res_0_1) = o; let mut local_res_0 = (crate::c_types::ThirtyTwoBytes { data: *orig_res_0_0.as_ref() }, crate::lightning::chain::channelmonitor::ChannelMonitor { inner: ObjOps::heap_alloc(orig_res_0_1), is_owned: true }).into(); local_res_0 }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_res
}
