// This file is Copyright its original authors, visible in version control
// history and in the source files from which this was generated.
//
// This file is licensed under the license available in the LICENSE or LICENSE.md
// file in the root of this repository or, if no such file exists, the same
// license as that which applies to the original source files from which this
// source was automatically generated.

//! The logic to monitor for on-chain transactions and create the relevant claim responses lives
//! here.
//!
//! ChannelMonitor objects are generated by ChannelManager in response to relevant
//! messages/actions, and MUST be persisted to disk (and, preferably, remotely) before progress can
//! be made in responding to certain messages, see [`chain::Watch`] for more.
//!
//! Note that ChannelMonitors are an important part of the lightning trust model and a copy of the
//! latest ChannelMonitor must always be actively monitoring for chain updates (and no out-of-date
//! ChannelMonitors should do so). Thus, if you're building rust-lightning into an HSM or other
//! security-domain-separated system design, you should consider having multiple paths for
//! ChannelMonitors to get out of the HSM and onto monitoring devices.

use std::str::FromStr;
use std::ffi::c_void;
use core::convert::Infallible;
use bitcoin::hashes::Hash;
use crate::c_types::*;


use lightning::chain::channelmonitor::ChannelMonitorUpdate as nativeChannelMonitorUpdateImport;
pub(crate) type nativeChannelMonitorUpdate = nativeChannelMonitorUpdateImport;

/// An update generated by the underlying Channel itself which contains some new information the
/// ChannelMonitor should be made aware of.
#[must_use]
#[repr(C)]
pub struct ChannelMonitorUpdate {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeChannelMonitorUpdate,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl Drop for ChannelMonitorUpdate {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeChannelMonitorUpdate>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the ChannelMonitorUpdate, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_free(this_obj: ChannelMonitorUpdate) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChannelMonitorUpdate_free_void(this_ptr: *mut c_void) {
	unsafe { let _ = Box::from_raw(this_ptr as *mut nativeChannelMonitorUpdate); }
}
#[allow(unused)]
impl ChannelMonitorUpdate {
	pub(crate) fn get_native_ref(&self) -> &'static nativeChannelMonitorUpdate {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeChannelMonitorUpdate {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeChannelMonitorUpdate {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = std::ptr::null_mut();
		ret
	}
}
/// The sequence number of this update. Updates *must* be replayed in-order according to this
/// sequence number (and updates may panic if they are not). The update_id values are strictly
/// increasing and increase by one for each new update, with one exception specified below.
///
/// This sequence number is also used to track up to which points updates which returned
/// ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
/// ChannelMonitor when ChannelManager::channel_monitor_updated is called.
///
/// The only instance where update_id values are not strictly increasing is the case where we
/// allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
/// its docs for more details.
#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_get_update_id(this_ptr: &ChannelMonitorUpdate) -> u64 {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().update_id;
	*inner_val
}
/// The sequence number of this update. Updates *must* be replayed in-order according to this
/// sequence number (and updates may panic if they are not). The update_id values are strictly
/// increasing and increase by one for each new update, with one exception specified below.
///
/// This sequence number is also used to track up to which points updates which returned
/// ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
/// ChannelMonitor when ChannelManager::channel_monitor_updated is called.
///
/// The only instance where update_id values are not strictly increasing is the case where we
/// allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
/// its docs for more details.
#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_set_update_id(this_ptr: &mut ChannelMonitorUpdate, mut val: u64) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.update_id = val;
}
impl Clone for ChannelMonitorUpdate {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativeChannelMonitorUpdate>::is_null(self.inner) { std::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChannelMonitorUpdate_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *mut nativeChannelMonitorUpdate)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the ChannelMonitorUpdate
pub extern "C" fn ChannelMonitorUpdate_clone(orig: &ChannelMonitorUpdate) -> ChannelMonitorUpdate {
	orig.clone()
}
/// If:
///    (1) a channel has been force closed and
///    (2) we receive a preimage from a forward link that allows us to spend an HTLC output on
///        this channel's (the backward link's) broadcasted commitment transaction
/// then we allow the `ChannelManager` to send a `ChannelMonitorUpdate` with this update ID,
/// with the update providing said payment preimage. No other update types are allowed after
/// force-close.

#[no_mangle]
pub static CLOSED_CHANNEL_UPDATE_ID: u64 = lightning::chain::channelmonitor::CLOSED_CHANNEL_UPDATE_ID;
#[no_mangle]
/// Serialize the ChannelMonitorUpdate object into a byte array which can be read by ChannelMonitorUpdate_read
pub extern "C" fn ChannelMonitorUpdate_write(obj: &ChannelMonitorUpdate) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*obj }.get_native_ref())
}
#[no_mangle]
pub(crate) extern "C" fn ChannelMonitorUpdate_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*(obj as *const nativeChannelMonitorUpdate) })
}
#[no_mangle]
/// Read a ChannelMonitorUpdate from a byte array, created by ChannelMonitorUpdate_write
pub extern "C" fn ChannelMonitorUpdate_read(ser: crate::c_types::u8slice) -> crate::c_types::derived::CResult_ChannelMonitorUpdateDecodeErrorZ {
	let res = crate::c_types::deserialize_obj(ser);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::chain::channelmonitor::ChannelMonitorUpdate { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_res
}

use lightning::chain::channelmonitor::MonitorUpdateError as nativeMonitorUpdateErrorImport;
pub(crate) type nativeMonitorUpdateError = nativeMonitorUpdateErrorImport;

/// General Err type for ChannelMonitor actions. Generally, this implies that the data provided is
/// inconsistent with the ChannelMonitor being called. eg for ChannelMonitor::update_monitor this
/// means you tried to update a monitor for a different channel or the ChannelMonitorUpdate was
/// corrupted.
/// Contains a developer-readable error message.
#[must_use]
#[repr(C)]
pub struct MonitorUpdateError {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeMonitorUpdateError,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl Drop for MonitorUpdateError {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeMonitorUpdateError>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the MonitorUpdateError, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn MonitorUpdateError_free(this_obj: MonitorUpdateError) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn MonitorUpdateError_free_void(this_ptr: *mut c_void) {
	unsafe { let _ = Box::from_raw(this_ptr as *mut nativeMonitorUpdateError); }
}
#[allow(unused)]
impl MonitorUpdateError {
	pub(crate) fn get_native_ref(&self) -> &'static nativeMonitorUpdateError {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeMonitorUpdateError {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeMonitorUpdateError {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = std::ptr::null_mut();
		ret
	}
}
#[no_mangle]
pub extern "C" fn MonitorUpdateError_get_a(this_ptr: &MonitorUpdateError) -> crate::c_types::Str {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().0;
	inner_val.into()
}
#[no_mangle]
pub extern "C" fn MonitorUpdateError_set_a(this_ptr: &mut MonitorUpdateError, mut val: crate::c_types::Str) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.0 = val.into_str();
}
/// Constructs a new MonitorUpdateError given each field
#[must_use]
#[no_mangle]
pub extern "C" fn MonitorUpdateError_new(mut a_arg: crate::c_types::Str) -> MonitorUpdateError {
	MonitorUpdateError { inner: ObjOps::heap_alloc(lightning::chain::channelmonitor::MonitorUpdateError (
		a_arg.into_str(),
	)), is_owned: true }
}
impl Clone for MonitorUpdateError {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativeMonitorUpdateError>::is_null(self.inner) { std::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn MonitorUpdateError_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *mut nativeMonitorUpdateError)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the MonitorUpdateError
pub extern "C" fn MonitorUpdateError_clone(orig: &MonitorUpdateError) -> MonitorUpdateError {
	orig.clone()
}
/// An event to be processed by the ChannelManager.
#[must_use]
#[derive(Clone)]
#[repr(C)]
pub enum MonitorEvent {
	/// A monitor event containing an HTLCUpdate.
	HTLCEvent(crate::lightning::chain::channelmonitor::HTLCUpdate),
	/// A monitor event that the Channel's commitment transaction was confirmed.
	CommitmentTxConfirmed(crate::lightning::chain::transaction::OutPoint),
	/// Indicates a [`ChannelMonitor`] update has completed. See
	/// [`ChannelMonitorUpdateErr::TemporaryFailure`] for more information on how this is used.
	///
	/// [`ChannelMonitorUpdateErr::TemporaryFailure`]: super::ChannelMonitorUpdateErr::TemporaryFailure
	UpdateCompleted {
		/// The funding outpoint of the [`ChannelMonitor`] that was updated
		funding_txo: crate::lightning::chain::transaction::OutPoint,
		/// The Update ID from [`ChannelMonitorUpdate::update_id`] which was applied or
		/// [`ChannelMonitor::get_latest_update_id`].
		///
		/// Note that this should only be set to a given update's ID if all previous updates for the
		/// same [`ChannelMonitor`] have been applied and persisted.
		monitor_update_id: u64,
	},
	/// Indicates a [`ChannelMonitor`] update has failed. See
	/// [`ChannelMonitorUpdateErr::PermanentFailure`] for more information on how this is used.
	///
	/// [`ChannelMonitorUpdateErr::PermanentFailure`]: super::ChannelMonitorUpdateErr::PermanentFailure
	UpdateFailed(crate::lightning::chain::transaction::OutPoint),
}
use lightning::chain::channelmonitor::MonitorEvent as nativeMonitorEvent;
impl MonitorEvent {
	#[allow(unused)]
	pub(crate) fn to_native(&self) -> nativeMonitorEvent {
		match self {
			MonitorEvent::HTLCEvent (ref a, ) => {
				let mut a_nonref = (*a).clone();
				nativeMonitorEvent::HTLCEvent (
					*unsafe { Box::from_raw(a_nonref.take_inner()) },
				)
			},
			MonitorEvent::CommitmentTxConfirmed (ref a, ) => {
				let mut a_nonref = (*a).clone();
				nativeMonitorEvent::CommitmentTxConfirmed (
					*unsafe { Box::from_raw(a_nonref.take_inner()) },
				)
			},
			MonitorEvent::UpdateCompleted {ref funding_txo, ref monitor_update_id, } => {
				let mut funding_txo_nonref = (*funding_txo).clone();
				let mut monitor_update_id_nonref = (*monitor_update_id).clone();
				nativeMonitorEvent::UpdateCompleted {
					funding_txo: *unsafe { Box::from_raw(funding_txo_nonref.take_inner()) },
					monitor_update_id: monitor_update_id_nonref,
				}
			},
			MonitorEvent::UpdateFailed (ref a, ) => {
				let mut a_nonref = (*a).clone();
				nativeMonitorEvent::UpdateFailed (
					*unsafe { Box::from_raw(a_nonref.take_inner()) },
				)
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn into_native(self) -> nativeMonitorEvent {
		match self {
			MonitorEvent::HTLCEvent (mut a, ) => {
				nativeMonitorEvent::HTLCEvent (
					*unsafe { Box::from_raw(a.take_inner()) },
				)
			},
			MonitorEvent::CommitmentTxConfirmed (mut a, ) => {
				nativeMonitorEvent::CommitmentTxConfirmed (
					*unsafe { Box::from_raw(a.take_inner()) },
				)
			},
			MonitorEvent::UpdateCompleted {mut funding_txo, mut monitor_update_id, } => {
				nativeMonitorEvent::UpdateCompleted {
					funding_txo: *unsafe { Box::from_raw(funding_txo.take_inner()) },
					monitor_update_id: monitor_update_id,
				}
			},
			MonitorEvent::UpdateFailed (mut a, ) => {
				nativeMonitorEvent::UpdateFailed (
					*unsafe { Box::from_raw(a.take_inner()) },
				)
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn from_native(native: &nativeMonitorEvent) -> Self {
		match native {
			nativeMonitorEvent::HTLCEvent (ref a, ) => {
				let mut a_nonref = (*a).clone();
				MonitorEvent::HTLCEvent (
					crate::lightning::chain::channelmonitor::HTLCUpdate { inner: ObjOps::heap_alloc(a_nonref), is_owned: true },
				)
			},
			nativeMonitorEvent::CommitmentTxConfirmed (ref a, ) => {
				let mut a_nonref = (*a).clone();
				MonitorEvent::CommitmentTxConfirmed (
					crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(a_nonref), is_owned: true },
				)
			},
			nativeMonitorEvent::UpdateCompleted {ref funding_txo, ref monitor_update_id, } => {
				let mut funding_txo_nonref = (*funding_txo).clone();
				let mut monitor_update_id_nonref = (*monitor_update_id).clone();
				MonitorEvent::UpdateCompleted {
					funding_txo: crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(funding_txo_nonref), is_owned: true },
					monitor_update_id: monitor_update_id_nonref,
				}
			},
			nativeMonitorEvent::UpdateFailed (ref a, ) => {
				let mut a_nonref = (*a).clone();
				MonitorEvent::UpdateFailed (
					crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(a_nonref), is_owned: true },
				)
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn native_into(native: nativeMonitorEvent) -> Self {
		match native {
			nativeMonitorEvent::HTLCEvent (mut a, ) => {
				MonitorEvent::HTLCEvent (
					crate::lightning::chain::channelmonitor::HTLCUpdate { inner: ObjOps::heap_alloc(a), is_owned: true },
				)
			},
			nativeMonitorEvent::CommitmentTxConfirmed (mut a, ) => {
				MonitorEvent::CommitmentTxConfirmed (
					crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(a), is_owned: true },
				)
			},
			nativeMonitorEvent::UpdateCompleted {mut funding_txo, mut monitor_update_id, } => {
				MonitorEvent::UpdateCompleted {
					funding_txo: crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(funding_txo), is_owned: true },
					monitor_update_id: monitor_update_id,
				}
			},
			nativeMonitorEvent::UpdateFailed (mut a, ) => {
				MonitorEvent::UpdateFailed (
					crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(a), is_owned: true },
				)
			},
		}
	}
}
/// Frees any resources used by the MonitorEvent
#[no_mangle]
pub extern "C" fn MonitorEvent_free(this_ptr: MonitorEvent) { }
/// Creates a copy of the MonitorEvent
#[no_mangle]
pub extern "C" fn MonitorEvent_clone(orig: &MonitorEvent) -> MonitorEvent {
	orig.clone()
}
#[no_mangle]
/// Utility method to constructs a new HTLCEvent-variant MonitorEvent
pub extern "C" fn MonitorEvent_htlcevent(a: crate::lightning::chain::channelmonitor::HTLCUpdate) -> MonitorEvent {
	MonitorEvent::HTLCEvent(a, )
}
#[no_mangle]
/// Utility method to constructs a new CommitmentTxConfirmed-variant MonitorEvent
pub extern "C" fn MonitorEvent_commitment_tx_confirmed(a: crate::lightning::chain::transaction::OutPoint) -> MonitorEvent {
	MonitorEvent::CommitmentTxConfirmed(a, )
}
#[no_mangle]
/// Utility method to constructs a new UpdateCompleted-variant MonitorEvent
pub extern "C" fn MonitorEvent_update_completed(funding_txo: crate::lightning::chain::transaction::OutPoint, monitor_update_id: u64) -> MonitorEvent {
	MonitorEvent::UpdateCompleted {
		funding_txo,
		monitor_update_id,
	}
}
#[no_mangle]
/// Utility method to constructs a new UpdateFailed-variant MonitorEvent
pub extern "C" fn MonitorEvent_update_failed(a: crate::lightning::chain::transaction::OutPoint) -> MonitorEvent {
	MonitorEvent::UpdateFailed(a, )
}
#[no_mangle]
/// Serialize the MonitorEvent object into a byte array which can be read by MonitorEvent_read
pub extern "C" fn MonitorEvent_write(obj: &MonitorEvent) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(&unsafe { &*obj }.to_native())
}

use lightning::chain::channelmonitor::HTLCUpdate as nativeHTLCUpdateImport;
pub(crate) type nativeHTLCUpdate = nativeHTLCUpdateImport;

/// Simple structure sent back by `chain::Watch` when an HTLC from a forward channel is detected on
/// chain. Used to update the corresponding HTLC in the backward channel. Failing to pass the
/// preimage claim backward will lead to loss of funds.
#[must_use]
#[repr(C)]
pub struct HTLCUpdate {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeHTLCUpdate,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl Drop for HTLCUpdate {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeHTLCUpdate>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the HTLCUpdate, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn HTLCUpdate_free(this_obj: HTLCUpdate) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn HTLCUpdate_free_void(this_ptr: *mut c_void) {
	unsafe { let _ = Box::from_raw(this_ptr as *mut nativeHTLCUpdate); }
}
#[allow(unused)]
impl HTLCUpdate {
	pub(crate) fn get_native_ref(&self) -> &'static nativeHTLCUpdate {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeHTLCUpdate {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeHTLCUpdate {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = std::ptr::null_mut();
		ret
	}
}
impl Clone for HTLCUpdate {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativeHTLCUpdate>::is_null(self.inner) { std::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn HTLCUpdate_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *mut nativeHTLCUpdate)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the HTLCUpdate
pub extern "C" fn HTLCUpdate_clone(orig: &HTLCUpdate) -> HTLCUpdate {
	orig.clone()
}
#[no_mangle]
/// Serialize the HTLCUpdate object into a byte array which can be read by HTLCUpdate_read
pub extern "C" fn HTLCUpdate_write(obj: &HTLCUpdate) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*obj }.get_native_ref())
}
#[no_mangle]
pub(crate) extern "C" fn HTLCUpdate_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*(obj as *const nativeHTLCUpdate) })
}
#[no_mangle]
/// Read a HTLCUpdate from a byte array, created by HTLCUpdate_write
pub extern "C" fn HTLCUpdate_read(ser: crate::c_types::u8slice) -> crate::c_types::derived::CResult_HTLCUpdateDecodeErrorZ {
	let res = crate::c_types::deserialize_obj(ser);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { crate::lightning::chain::channelmonitor::HTLCUpdate { inner: ObjOps::heap_alloc(o), is_owned: true } }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_res
}
/// Number of blocks we wait on seeing a HTLC output being solved before we fail corresponding
/// inbound HTLCs. This prevents us from failing backwards and then getting a reorg resulting in us
/// losing money.
///
/// Note that this is a library-wide security assumption. If a reorg deeper than this number of
/// blocks occurs, counterparties may be able to steal funds or claims made by and balances exposed
/// by a  [`ChannelMonitor`] may be incorrect.

#[no_mangle]
pub static ANTI_REORG_DELAY: u32 = lightning::chain::channelmonitor::ANTI_REORG_DELAY;
/// Details about the balance(s) available for spending once the channel appears on chain.
///
/// See [`ChannelMonitor::get_claimable_balances`] for more details on when these will or will not
/// be provided.
#[must_use]
#[derive(Clone)]
#[repr(C)]
pub enum Balance {
	/// The channel is not yet closed (or the commitment or closing transaction has not yet
	/// appeared in a block). The given balance is claimable (less on-chain fees) if the channel is
	/// force-closed now.
	ClaimableOnChannelClose {
		/// The amount available to claim, in satoshis, excluding the on-chain fees which will be
		/// required to do so.
		claimable_amount_satoshis: u64,
	},
	/// The channel has been closed, and the given balance is ours but awaiting confirmations until
	/// we consider it spendable.
	ClaimableAwaitingConfirmations {
		/// The amount available to claim, in satoshis, possibly excluding the on-chain fees which
		/// were spent in broadcasting the transaction.
		claimable_amount_satoshis: u64,
		/// The height at which an [`Event::SpendableOutputs`] event will be generated for this
		/// amount.
		confirmation_height: u32,
	},
	/// The channel has been closed, and the given balance should be ours but awaiting spending
	/// transaction confirmation. If the spending transaction does not confirm in time, it is
	/// possible our counterparty can take the funds by broadcasting an HTLC timeout on-chain.
	///
	/// Once the spending transaction confirms, before it has reached enough confirmations to be
	/// considered safe from chain reorganizations, the balance will instead be provided via
	/// [`Balance::ClaimableAwaitingConfirmations`].
	ContentiousClaimable {
		/// The amount available to claim, in satoshis, excluding the on-chain fees which will be
		/// required to do so.
		claimable_amount_satoshis: u64,
		/// The height at which the counterparty may be able to claim the balance if we have not
		/// done so.
		timeout_height: u32,
	},
	/// HTLCs which we sent to our counterparty which are claimable after a timeout (less on-chain
	/// fees) if the counterparty does not know the preimage for the HTLCs. These are somewhat
	/// likely to be claimed by our counterparty before we do.
	MaybeClaimableHTLCAwaitingTimeout {
		/// The amount available to claim, in satoshis, excluding the on-chain fees which will be
		/// required to do so.
		claimable_amount_satoshis: u64,
		/// The height at which we will be able to claim the balance if our counterparty has not
		/// done so.
		claimable_height: u32,
	},
}
use lightning::chain::channelmonitor::Balance as nativeBalance;
impl Balance {
	#[allow(unused)]
	pub(crate) fn to_native(&self) -> nativeBalance {
		match self {
			Balance::ClaimableOnChannelClose {ref claimable_amount_satoshis, } => {
				let mut claimable_amount_satoshis_nonref = (*claimable_amount_satoshis).clone();
				nativeBalance::ClaimableOnChannelClose {
					claimable_amount_satoshis: claimable_amount_satoshis_nonref,
				}
			},
			Balance::ClaimableAwaitingConfirmations {ref claimable_amount_satoshis, ref confirmation_height, } => {
				let mut claimable_amount_satoshis_nonref = (*claimable_amount_satoshis).clone();
				let mut confirmation_height_nonref = (*confirmation_height).clone();
				nativeBalance::ClaimableAwaitingConfirmations {
					claimable_amount_satoshis: claimable_amount_satoshis_nonref,
					confirmation_height: confirmation_height_nonref,
				}
			},
			Balance::ContentiousClaimable {ref claimable_amount_satoshis, ref timeout_height, } => {
				let mut claimable_amount_satoshis_nonref = (*claimable_amount_satoshis).clone();
				let mut timeout_height_nonref = (*timeout_height).clone();
				nativeBalance::ContentiousClaimable {
					claimable_amount_satoshis: claimable_amount_satoshis_nonref,
					timeout_height: timeout_height_nonref,
				}
			},
			Balance::MaybeClaimableHTLCAwaitingTimeout {ref claimable_amount_satoshis, ref claimable_height, } => {
				let mut claimable_amount_satoshis_nonref = (*claimable_amount_satoshis).clone();
				let mut claimable_height_nonref = (*claimable_height).clone();
				nativeBalance::MaybeClaimableHTLCAwaitingTimeout {
					claimable_amount_satoshis: claimable_amount_satoshis_nonref,
					claimable_height: claimable_height_nonref,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn into_native(self) -> nativeBalance {
		match self {
			Balance::ClaimableOnChannelClose {mut claimable_amount_satoshis, } => {
				nativeBalance::ClaimableOnChannelClose {
					claimable_amount_satoshis: claimable_amount_satoshis,
				}
			},
			Balance::ClaimableAwaitingConfirmations {mut claimable_amount_satoshis, mut confirmation_height, } => {
				nativeBalance::ClaimableAwaitingConfirmations {
					claimable_amount_satoshis: claimable_amount_satoshis,
					confirmation_height: confirmation_height,
				}
			},
			Balance::ContentiousClaimable {mut claimable_amount_satoshis, mut timeout_height, } => {
				nativeBalance::ContentiousClaimable {
					claimable_amount_satoshis: claimable_amount_satoshis,
					timeout_height: timeout_height,
				}
			},
			Balance::MaybeClaimableHTLCAwaitingTimeout {mut claimable_amount_satoshis, mut claimable_height, } => {
				nativeBalance::MaybeClaimableHTLCAwaitingTimeout {
					claimable_amount_satoshis: claimable_amount_satoshis,
					claimable_height: claimable_height,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn from_native(native: &nativeBalance) -> Self {
		match native {
			nativeBalance::ClaimableOnChannelClose {ref claimable_amount_satoshis, } => {
				let mut claimable_amount_satoshis_nonref = (*claimable_amount_satoshis).clone();
				Balance::ClaimableOnChannelClose {
					claimable_amount_satoshis: claimable_amount_satoshis_nonref,
				}
			},
			nativeBalance::ClaimableAwaitingConfirmations {ref claimable_amount_satoshis, ref confirmation_height, } => {
				let mut claimable_amount_satoshis_nonref = (*claimable_amount_satoshis).clone();
				let mut confirmation_height_nonref = (*confirmation_height).clone();
				Balance::ClaimableAwaitingConfirmations {
					claimable_amount_satoshis: claimable_amount_satoshis_nonref,
					confirmation_height: confirmation_height_nonref,
				}
			},
			nativeBalance::ContentiousClaimable {ref claimable_amount_satoshis, ref timeout_height, } => {
				let mut claimable_amount_satoshis_nonref = (*claimable_amount_satoshis).clone();
				let mut timeout_height_nonref = (*timeout_height).clone();
				Balance::ContentiousClaimable {
					claimable_amount_satoshis: claimable_amount_satoshis_nonref,
					timeout_height: timeout_height_nonref,
				}
			},
			nativeBalance::MaybeClaimableHTLCAwaitingTimeout {ref claimable_amount_satoshis, ref claimable_height, } => {
				let mut claimable_amount_satoshis_nonref = (*claimable_amount_satoshis).clone();
				let mut claimable_height_nonref = (*claimable_height).clone();
				Balance::MaybeClaimableHTLCAwaitingTimeout {
					claimable_amount_satoshis: claimable_amount_satoshis_nonref,
					claimable_height: claimable_height_nonref,
				}
			},
		}
	}
	#[allow(unused)]
	pub(crate) fn native_into(native: nativeBalance) -> Self {
		match native {
			nativeBalance::ClaimableOnChannelClose {mut claimable_amount_satoshis, } => {
				Balance::ClaimableOnChannelClose {
					claimable_amount_satoshis: claimable_amount_satoshis,
				}
			},
			nativeBalance::ClaimableAwaitingConfirmations {mut claimable_amount_satoshis, mut confirmation_height, } => {
				Balance::ClaimableAwaitingConfirmations {
					claimable_amount_satoshis: claimable_amount_satoshis,
					confirmation_height: confirmation_height,
				}
			},
			nativeBalance::ContentiousClaimable {mut claimable_amount_satoshis, mut timeout_height, } => {
				Balance::ContentiousClaimable {
					claimable_amount_satoshis: claimable_amount_satoshis,
					timeout_height: timeout_height,
				}
			},
			nativeBalance::MaybeClaimableHTLCAwaitingTimeout {mut claimable_amount_satoshis, mut claimable_height, } => {
				Balance::MaybeClaimableHTLCAwaitingTimeout {
					claimable_amount_satoshis: claimable_amount_satoshis,
					claimable_height: claimable_height,
				}
			},
		}
	}
}
/// Frees any resources used by the Balance
#[no_mangle]
pub extern "C" fn Balance_free(this_ptr: Balance) { }
/// Creates a copy of the Balance
#[no_mangle]
pub extern "C" fn Balance_clone(orig: &Balance) -> Balance {
	orig.clone()
}
#[no_mangle]
/// Utility method to constructs a new ClaimableOnChannelClose-variant Balance
pub extern "C" fn Balance_claimable_on_channel_close(claimable_amount_satoshis: u64) -> Balance {
	Balance::ClaimableOnChannelClose {
		claimable_amount_satoshis,
	}
}
#[no_mangle]
/// Utility method to constructs a new ClaimableAwaitingConfirmations-variant Balance
pub extern "C" fn Balance_claimable_awaiting_confirmations(claimable_amount_satoshis: u64, confirmation_height: u32) -> Balance {
	Balance::ClaimableAwaitingConfirmations {
		claimable_amount_satoshis,
		confirmation_height,
	}
}
#[no_mangle]
/// Utility method to constructs a new ContentiousClaimable-variant Balance
pub extern "C" fn Balance_contentious_claimable(claimable_amount_satoshis: u64, timeout_height: u32) -> Balance {
	Balance::ContentiousClaimable {
		claimable_amount_satoshis,
		timeout_height,
	}
}
#[no_mangle]
/// Utility method to constructs a new MaybeClaimableHTLCAwaitingTimeout-variant Balance
pub extern "C" fn Balance_maybe_claimable_htlcawaiting_timeout(claimable_amount_satoshis: u64, claimable_height: u32) -> Balance {
	Balance::MaybeClaimableHTLCAwaitingTimeout {
		claimable_amount_satoshis,
		claimable_height,
	}
}
/// Checks if two Balances contain equal inner contents.
/// This ignores pointers and is_owned flags and looks at the values in fields.
#[no_mangle]
pub extern "C" fn Balance_eq(a: &Balance, b: &Balance) -> bool {
	if &a.to_native() == &b.to_native() { true } else { false }
}

use lightning::chain::channelmonitor::ChannelMonitor as nativeChannelMonitorImport;
pub(crate) type nativeChannelMonitor = nativeChannelMonitorImport<crate::lightning::chain::keysinterface::Sign>;

/// A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
/// on-chain transactions to ensure no loss of funds occurs.
///
/// You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
/// information and are actively monitoring the chain.
///
/// Pending Events or updated HTLCs which have not yet been read out by
/// get_and_clear_pending_monitor_events or get_and_clear_pending_events are serialized to disk and
/// reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events
/// gotten are fully handled before re-serializing the new state.
///
/// Note that the deserializer is only implemented for (BlockHash, ChannelMonitor), which
/// tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
/// the \"reorg path\" (ie disconnecting blocks until you find a common ancestor from both the
/// returned block hash and the the current chain and then reconnecting blocks to get to the
/// best chain) upon deserializing the object!
#[must_use]
#[repr(C)]
pub struct ChannelMonitor {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeChannelMonitor,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl Drop for ChannelMonitor {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeChannelMonitor>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the ChannelMonitor, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn ChannelMonitor_free(this_obj: ChannelMonitor) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ChannelMonitor_free_void(this_ptr: *mut c_void) {
	unsafe { let _ = Box::from_raw(this_ptr as *mut nativeChannelMonitor); }
}
#[allow(unused)]
impl ChannelMonitor {
	pub(crate) fn get_native_ref(&self) -> &'static nativeChannelMonitor {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeChannelMonitor {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeChannelMonitor {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = std::ptr::null_mut();
		ret
	}
}
#[no_mangle]
/// Serialize the ChannelMonitor object into a byte array which can be read by ChannelMonitor_read
pub extern "C" fn ChannelMonitor_write(obj: &ChannelMonitor) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*obj }.get_native_ref())
}
#[no_mangle]
pub(crate) extern "C" fn ChannelMonitor_write_void(obj: *const c_void) -> crate::c_types::derived::CVec_u8Z {
	crate::c_types::serialize_obj(unsafe { &*(obj as *const nativeChannelMonitor) })
}
/// Updates a ChannelMonitor on the basis of some new information provided by the Channel
/// itself.
///
/// panics if the given update is not the next update by update_id.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_update_monitor(this_arg: &ChannelMonitor, updates: &crate::lightning::chain::channelmonitor::ChannelMonitorUpdate, broadcaster: &crate::lightning::chain::chaininterface::BroadcasterInterface, fee_estimator: &crate::lightning::chain::chaininterface::FeeEstimator, logger: &crate::lightning::util::logger::Logger) -> crate::c_types::derived::CResult_NoneMonitorUpdateErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.update_monitor(updates.get_native_ref(), broadcaster, fee_estimator, logger);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::chain::channelmonitor::MonitorUpdateError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}

/// Gets the update_id from the latest ChannelMonitorUpdate which was applied to this
/// ChannelMonitor.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_latest_update_id(this_arg: &ChannelMonitor) -> u64 {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_latest_update_id();
	ret
}

/// Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_funding_txo(this_arg: &ChannelMonitor) -> crate::c_types::derived::C2Tuple_OutPointScriptZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_funding_txo();
	let (mut orig_ret_0, mut orig_ret_1) = ret; let mut local_ret = (crate::lightning::chain::transaction::OutPoint { inner: ObjOps::heap_alloc(orig_ret_0), is_owned: true }, orig_ret_1.into_bytes().into()).into();
	local_ret
}

/// Gets a list of txids, with their output scripts (in the order they appear in the
/// transaction), which we must learn about spends of via block_connected().
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_outputs_to_watch(this_arg: &ChannelMonitor) -> crate::c_types::derived::CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_outputs_to_watch();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_orig_ret_0_1 = Vec::new(); for mut item in orig_ret_0_1.drain(..) { local_orig_ret_0_1.push( { let (mut orig_orig_ret_0_1_0_0, mut orig_orig_ret_0_1_0_1) = item; let mut local_orig_ret_0_1_0 = (orig_orig_ret_0_1_0_0, orig_orig_ret_0_1_0_1.into_bytes().into()).into(); local_orig_ret_0_1_0 }); }; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: orig_ret_0_0.into_inner() }, local_orig_ret_0_1.into()).into(); local_ret_0 }); };
	local_ret.into()
}

/// Loads the funding txo and outputs to watch into the given `chain::Filter` by repeatedly
/// calling `chain::Filter::register_output` and `chain::Filter::register_tx` until all outputs
/// have been registered.
#[no_mangle]
pub extern "C" fn ChannelMonitor_load_outputs_to_watch(this_arg: &ChannelMonitor, filter: &crate::lightning::chain::Filter) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.load_outputs_to_watch(filter)
}

/// Get the list of HTLCs who's status has been updated on chain. This should be called by
/// ChannelManager via [`chain::Watch::release_pending_monitor_events`].
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_and_clear_pending_monitor_events(this_arg: &ChannelMonitor) -> crate::c_types::derived::CVec_MonitorEventZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_and_clear_pending_monitor_events();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::chain::channelmonitor::MonitorEvent::native_into(item) }); };
	local_ret.into()
}

/// Gets the list of pending events which were generated by previous actions, clearing the list
/// in the process.
///
/// This is called by ChainMonitor::get_and_clear_pending_events() and is equivalent to
/// EventsProvider::get_and_clear_pending_events() except that it requires &mut self as we do
/// no internal locking in ChannelMonitors.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_and_clear_pending_events(this_arg: &ChannelMonitor) -> crate::c_types::derived::CVec_EventZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_and_clear_pending_events();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::util::events::Event::native_into(item) }); };
	local_ret.into()
}

/// Used by ChannelManager deserialization to broadcast the latest holder state if its copy of
/// the Channel was out-of-date. You may use it to get a broadcastable holder toxic tx in case of
/// fallen-behind, i.e when receiving a channel_reestablish with a proof that our counterparty side knows
/// a higher revocation secret than the holder commitment number we are aware of. Broadcasting these
/// transactions are UNSAFE, as they allow counterparty side to punish you. Nevertheless you may want to
/// broadcast them if counterparty don't close channel with his higher commitment transaction after a
/// substantial amount of time (a month or even a year) to get back funds. Best may be to contact
/// out-of-band the other node operator to coordinate with him if option is available to you.
/// In any-case, choice is up to the user.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_latest_holder_commitment_txn(this_arg: &ChannelMonitor, logger: &crate::lightning::util::logger::Logger) -> crate::c_types::derived::CVec_TransactionZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_latest_holder_commitment_txn(logger);
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::c_types::Transaction::from_bitcoin(&item) }); };
	local_ret.into()
}

/// Processes transactions in a newly connected block, which may result in any of the following:
/// - update the monitor's state against resolved HTLCs
/// - punish the counterparty in the case of seeing a revoked commitment transaction
/// - force close the channel and claim/timeout incoming/outgoing HTLCs if near expiration
/// - detect settled outputs for later spending
/// - schedule and bump any in-flight claims
///
/// Returns any new outputs to watch from `txdata`; after called, these are also included in
/// [`get_outputs_to_watch`].
///
/// [`get_outputs_to_watch`]: #method.get_outputs_to_watch
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_block_connected(this_arg: &ChannelMonitor, header: *const [u8; 80], mut txdata: crate::c_types::derived::CVec_C2Tuple_usizeTransactionZZ, mut height: u32, mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, mut logger: crate::lightning::util::logger::Logger) -> crate::c_types::derived::CVec_TransactionOutputsZ {
	let mut local_txdata = Vec::new(); for mut item in txdata.into_rust().drain(..) { local_txdata.push( { let (mut orig_txdata_0_0, mut orig_txdata_0_1) = item.to_rust(); let mut local_txdata_0 = (orig_txdata_0_0, orig_txdata_0_1.into_bitcoin()); local_txdata_0 }); };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.block_connected(&::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), &local_txdata.iter().map(|(a, b)| (*a, b)).collect::<Vec<_>>()[..], height, broadcaster, fee_estimator, logger);
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_orig_ret_0_1 = Vec::new(); for mut item in orig_ret_0_1.drain(..) { local_orig_ret_0_1.push( { let (mut orig_orig_ret_0_1_0_0, mut orig_orig_ret_0_1_0_1) = item; let mut local_orig_ret_0_1_0 = (orig_orig_ret_0_1_0_0, crate::c_types::TxOut::from_rust(orig_orig_ret_0_1_0_1)).into(); local_orig_ret_0_1_0 }); }; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: orig_ret_0_0.into_inner() }, local_orig_ret_0_1.into()).into(); local_ret_0 }); };
	local_ret.into()
}

/// Determines if the disconnected block contained any transactions of interest and updates
/// appropriately.
#[no_mangle]
pub extern "C" fn ChannelMonitor_block_disconnected(this_arg: &ChannelMonitor, header: *const [u8; 80], mut height: u32, mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, mut logger: crate::lightning::util::logger::Logger) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.block_disconnected(&::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), height, broadcaster, fee_estimator, logger)
}

/// Processes transactions confirmed in a block with the given header and height, returning new
/// outputs to watch. See [`block_connected`] for details.
///
/// Used instead of [`block_connected`] by clients that are notified of transactions rather than
/// blocks. See [`chain::Confirm`] for calling expectations.
///
/// [`block_connected`]: Self::block_connected
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_transactions_confirmed(this_arg: &ChannelMonitor, header: *const [u8; 80], mut txdata: crate::c_types::derived::CVec_C2Tuple_usizeTransactionZZ, mut height: u32, mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, mut logger: crate::lightning::util::logger::Logger) -> crate::c_types::derived::CVec_TransactionOutputsZ {
	let mut local_txdata = Vec::new(); for mut item in txdata.into_rust().drain(..) { local_txdata.push( { let (mut orig_txdata_0_0, mut orig_txdata_0_1) = item.to_rust(); let mut local_txdata_0 = (orig_txdata_0_0, orig_txdata_0_1.into_bitcoin()); local_txdata_0 }); };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.transactions_confirmed(&::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), &local_txdata.iter().map(|(a, b)| (*a, b)).collect::<Vec<_>>()[..], height, broadcaster, fee_estimator, logger);
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_orig_ret_0_1 = Vec::new(); for mut item in orig_ret_0_1.drain(..) { local_orig_ret_0_1.push( { let (mut orig_orig_ret_0_1_0_0, mut orig_orig_ret_0_1_0_1) = item; let mut local_orig_ret_0_1_0 = (orig_orig_ret_0_1_0_0, crate::c_types::TxOut::from_rust(orig_orig_ret_0_1_0_1)).into(); local_orig_ret_0_1_0 }); }; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: orig_ret_0_0.into_inner() }, local_orig_ret_0_1.into()).into(); local_ret_0 }); };
	local_ret.into()
}

/// Processes a transaction that was reorganized out of the chain.
///
/// Used instead of [`block_disconnected`] by clients that are notified of transactions rather
/// than blocks. See [`chain::Confirm`] for calling expectations.
///
/// [`block_disconnected`]: Self::block_disconnected
#[no_mangle]
pub extern "C" fn ChannelMonitor_transaction_unconfirmed(this_arg: &ChannelMonitor, txid: *const [u8; 32], mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, mut logger: crate::lightning::util::logger::Logger) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.transaction_unconfirmed(&::bitcoin::hash_types::Txid::from_slice(&unsafe { &*txid }[..]).unwrap(), broadcaster, fee_estimator, logger)
}

/// Updates the monitor with the current best chain tip, returning new outputs to watch. See
/// [`block_connected`] for details.
///
/// Used instead of [`block_connected`] by clients that are notified of transactions rather than
/// blocks. See [`chain::Confirm`] for calling expectations.
///
/// [`block_connected`]: Self::block_connected
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_best_block_updated(this_arg: &ChannelMonitor, header: *const [u8; 80], mut height: u32, mut broadcaster: crate::lightning::chain::chaininterface::BroadcasterInterface, mut fee_estimator: crate::lightning::chain::chaininterface::FeeEstimator, mut logger: crate::lightning::util::logger::Logger) -> crate::c_types::derived::CVec_TransactionOutputsZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.best_block_updated(&::bitcoin::consensus::encode::deserialize(unsafe { &*header }).unwrap(), height, broadcaster, fee_estimator, logger);
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_orig_ret_0_1 = Vec::new(); for mut item in orig_ret_0_1.drain(..) { local_orig_ret_0_1.push( { let (mut orig_orig_ret_0_1_0_0, mut orig_orig_ret_0_1_0_1) = item; let mut local_orig_ret_0_1_0 = (orig_orig_ret_0_1_0_0, crate::c_types::TxOut::from_rust(orig_orig_ret_0_1_0_1)).into(); local_orig_ret_0_1_0 }); }; let mut local_ret_0 = (crate::c_types::ThirtyTwoBytes { data: orig_ret_0_0.into_inner() }, local_orig_ret_0_1.into()).into(); local_ret_0 }); };
	local_ret.into()
}

/// Returns the set of txids that should be monitored for re-organization out of the chain.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_relevant_txids(this_arg: &ChannelMonitor) -> crate::c_types::derived::CVec_TxidZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_relevant_txids();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::c_types::ThirtyTwoBytes { data: item.into_inner() } }); };
	local_ret.into()
}

/// Gets the latest best block which was connected either via the [`chain::Listen`] or
/// [`chain::Confirm`] interfaces.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_current_best_block(this_arg: &ChannelMonitor) -> crate::lightning::chain::BestBlock {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.current_best_block();
	crate::lightning::chain::BestBlock { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Gets the balances in this channel which are either claimable by us if we were to
/// force-close the channel now or which are claimable on-chain (possibly awaiting
/// confirmation).
///
/// Any balances in the channel which are available on-chain (excluding on-chain fees) are
/// included here until an [`Event::SpendableOutputs`] event has been generated for the
/// balance, or until our counterparty has claimed the balance and accrued several
/// confirmations on the claim transaction.
///
/// Note that the balances available when you or your counterparty have broadcasted revoked
/// state(s) may not be fully captured here.
///
/// See [`Balance`] for additional details on the types of claimable balances which
/// may be returned here and their meanings.
#[must_use]
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_claimable_balances(this_arg: &ChannelMonitor) -> crate::c_types::derived::CVec_BalanceZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_claimable_balances();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::chain::channelmonitor::Balance::native_into(item) }); };
	local_ret.into()
}

#[no_mangle]
/// Read a C2Tuple_BlockHashChannelMonitorZ from a byte array, created by C2Tuple_BlockHashChannelMonitorZ_write
pub extern "C" fn C2Tuple_BlockHashChannelMonitorZ_read(ser: crate::c_types::u8slice, arg: &crate::lightning::chain::keysinterface::KeysInterface) -> crate::c_types::derived::CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ {
	let arg_conv = arg;
	let res: Result<(bitcoin::hash_types::BlockHash, lightning::chain::channelmonitor::ChannelMonitor<crate::lightning::chain::keysinterface::Sign>), lightning::ln::msgs::DecodeError> = crate::c_types::deserialize_obj_arg(ser, arg_conv);
	let mut local_res = match res { Ok(mut o) => crate::c_types::CResultTempl::ok( { let (mut orig_res_0_0, mut orig_res_0_1) = o; let mut local_res_0 = (crate::c_types::ThirtyTwoBytes { data: orig_res_0_0.into_inner() }, crate::lightning::chain::channelmonitor::ChannelMonitor { inner: ObjOps::heap_alloc(orig_res_0_1), is_owned: true }).into(); local_res_0 }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_res
}
