
use alloc::str::FromStr;
use alloc::string::String;
use core::ffi::c_void;
use core::convert::Infallible;
use bitcoin::hashes::Hash;
use crate::c_types::*;
#[cfg(feature="no-std")]
use alloc::{vec::Vec, boxed::Box};

#[repr(C)]
/// A dynamically-allocated array of u8s of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_u8Z {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut u8,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_u8Z {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<u8> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[u8] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<u8>> for CVec_u8Z {
	fn from(v: Vec<u8>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_u8Z_free(_res: CVec_u8Z) { }
impl Drop for CVec_u8Z {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_u8Z {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ
pub union CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::refund::RefundMaybeWithDerivedMetadataBuilder,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::refund::RefundMaybeWithDerivedMetadataBuilder on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	/// The contents of this CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZPtr,
	/// Whether this CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ_ok(o: crate::lightning::offers::refund::RefundMaybeWithDerivedMetadataBuilder) -> CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ {
		contents: CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ {
		contents: CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ_is_ok(o: &CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ.
pub extern "C" fn CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ_free(_res: CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ) { }
impl Drop for CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::refund::RefundMaybeWithDerivedMetadataBuilder, crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::refund::RefundMaybeWithDerivedMetadataBuilder, crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::refund::RefundMaybeWithDerivedMetadataBuilder>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ_clone(orig: &CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ) -> CResult_RefundMaybeWithDerivedMetadataBuilderBolt12SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RefundBolt12SemanticErrorZ
pub union CResult_RefundBolt12SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::refund::Refund,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_RefundBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::refund::Refund on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RefundBolt12SemanticErrorZ {
	/// The contents of this CResult_RefundBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RefundBolt12SemanticErrorZPtr,
	/// Whether this CResult_RefundBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RefundBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_RefundBolt12SemanticErrorZ_ok(o: crate::lightning::offers::refund::Refund) -> CResult_RefundBolt12SemanticErrorZ {
	CResult_RefundBolt12SemanticErrorZ {
		contents: CResult_RefundBolt12SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RefundBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_RefundBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_RefundBolt12SemanticErrorZ {
	CResult_RefundBolt12SemanticErrorZ {
		contents: CResult_RefundBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RefundBolt12SemanticErrorZ_is_ok(o: &CResult_RefundBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RefundBolt12SemanticErrorZ.
pub extern "C" fn CResult_RefundBolt12SemanticErrorZ_free(_res: CResult_RefundBolt12SemanticErrorZ) { }
impl Drop for CResult_RefundBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::refund::Refund, crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_RefundBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::refund::Refund, crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RefundBolt12SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RefundBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RefundBolt12SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RefundBolt12SemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::refund::Refund>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RefundBolt12SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RefundBolt12SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RefundBolt12SemanticErrorZ_clone(orig: &CResult_RefundBolt12SemanticErrorZ) -> CResult_RefundBolt12SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a u64 or not
pub enum COption_u64Z {
	/// When we're in this state, this COption_u64Z contains a u64
	Some(u64),
	/// When we're in this state, this COption_u64Z contains nothing
	None
}
impl COption_u64Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> u64 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_u64Z containing a u64
pub extern "C" fn COption_u64Z_some(o: u64) -> COption_u64Z {
	COption_u64Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_u64Z containing nothing
pub extern "C" fn COption_u64Z_none() -> COption_u64Z {
	COption_u64Z::None
}
#[no_mangle]
/// Frees any resources associated with the u64, if we are in the Some state
pub extern "C" fn COption_u64Z_free(_res: COption_u64Z) { }
#[no_mangle]
/// Creates a new COption_u64Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_u64Z_clone(orig: &COption_u64Z) -> COption_u64Z { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::blinded_path::message::BlindedMessagePaths of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_BlindedMessagePathZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::blinded_path::message::BlindedMessagePath,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_BlindedMessagePathZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::blinded_path::message::BlindedMessagePath> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::blinded_path::message::BlindedMessagePath] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::blinded_path::message::BlindedMessagePath>> for CVec_BlindedMessagePathZ {
	fn from(v: Vec<crate::lightning::blinded_path::message::BlindedMessagePath>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_BlindedMessagePathZ_free(_res: CVec_BlindedMessagePathZ) { }
impl Drop for CVec_BlindedMessagePathZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_BlindedMessagePathZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RefundDecodeErrorZ
pub union CResult_RefundDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::refund::Refund,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RefundDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::refund::Refund on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RefundDecodeErrorZ {
	/// The contents of this CResult_RefundDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RefundDecodeErrorZPtr,
	/// Whether this CResult_RefundDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RefundDecodeErrorZ in the success state.
pub extern "C" fn CResult_RefundDecodeErrorZ_ok(o: crate::lightning::offers::refund::Refund) -> CResult_RefundDecodeErrorZ {
	CResult_RefundDecodeErrorZ {
		contents: CResult_RefundDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RefundDecodeErrorZ in the error state.
pub extern "C" fn CResult_RefundDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RefundDecodeErrorZ {
	CResult_RefundDecodeErrorZ {
		contents: CResult_RefundDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RefundDecodeErrorZ_is_ok(o: &CResult_RefundDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RefundDecodeErrorZ.
pub extern "C" fn CResult_RefundDecodeErrorZ_free(_res: CResult_RefundDecodeErrorZ) { }
impl Drop for CResult_RefundDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::refund::Refund, crate::lightning::ln::msgs::DecodeError>> for CResult_RefundDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::refund::Refund, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RefundDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RefundDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RefundDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RefundDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::refund::Refund>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RefundDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RefundDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RefundDecodeErrorZ_clone(orig: &CResult_RefundDecodeErrorZ) -> CResult_RefundDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RefundBolt12ParseErrorZ
pub union CResult_RefundBolt12ParseErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::refund::Refund,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12ParseError,
}
#[repr(C)]
/// A CResult_RefundBolt12ParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::refund::Refund on success and a crate::lightning::offers::parse::Bolt12ParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RefundBolt12ParseErrorZ {
	/// The contents of this CResult_RefundBolt12ParseErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RefundBolt12ParseErrorZPtr,
	/// Whether this CResult_RefundBolt12ParseErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RefundBolt12ParseErrorZ in the success state.
pub extern "C" fn CResult_RefundBolt12ParseErrorZ_ok(o: crate::lightning::offers::refund::Refund) -> CResult_RefundBolt12ParseErrorZ {
	CResult_RefundBolt12ParseErrorZ {
		contents: CResult_RefundBolt12ParseErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RefundBolt12ParseErrorZ in the error state.
pub extern "C" fn CResult_RefundBolt12ParseErrorZ_err(e: crate::lightning::offers::parse::Bolt12ParseError) -> CResult_RefundBolt12ParseErrorZ {
	CResult_RefundBolt12ParseErrorZ {
		contents: CResult_RefundBolt12ParseErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RefundBolt12ParseErrorZ_is_ok(o: &CResult_RefundBolt12ParseErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RefundBolt12ParseErrorZ.
pub extern "C" fn CResult_RefundBolt12ParseErrorZ_free(_res: CResult_RefundBolt12ParseErrorZ) { }
impl Drop for CResult_RefundBolt12ParseErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::refund::Refund, crate::lightning::offers::parse::Bolt12ParseError>> for CResult_RefundBolt12ParseErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::refund::Refund, crate::lightning::offers::parse::Bolt12ParseError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RefundBolt12ParseErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RefundBolt12ParseErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RefundBolt12ParseErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RefundBolt12ParseErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::refund::Refund>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RefundBolt12ParseErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12ParseError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RefundBolt12ParseErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RefundBolt12ParseErrorZ_clone(orig: &CResult_RefundBolt12ParseErrorZ) -> CResult_RefundBolt12ParseErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RetryDecodeErrorZ
pub union CResult_RetryDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::outbound_payment::Retry,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RetryDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::outbound_payment::Retry on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RetryDecodeErrorZ {
	/// The contents of this CResult_RetryDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RetryDecodeErrorZPtr,
	/// Whether this CResult_RetryDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RetryDecodeErrorZ in the success state.
pub extern "C" fn CResult_RetryDecodeErrorZ_ok(o: crate::lightning::ln::outbound_payment::Retry) -> CResult_RetryDecodeErrorZ {
	CResult_RetryDecodeErrorZ {
		contents: CResult_RetryDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RetryDecodeErrorZ in the error state.
pub extern "C" fn CResult_RetryDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RetryDecodeErrorZ {
	CResult_RetryDecodeErrorZ {
		contents: CResult_RetryDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RetryDecodeErrorZ_is_ok(o: &CResult_RetryDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RetryDecodeErrorZ.
pub extern "C" fn CResult_RetryDecodeErrorZ_free(_res: CResult_RetryDecodeErrorZ) { }
impl Drop for CResult_RetryDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::Retry, crate::lightning::ln::msgs::DecodeError>> for CResult_RetryDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::Retry, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RetryDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RetryDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RetryDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RetryDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::Retry>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RetryDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RetryDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RetryDecodeErrorZ_clone(orig: &CResult_RetryDecodeErrorZ) -> CResult_RetryDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::ThirtyTwoBytes or not
pub enum COption_ThirtyTwoBytesZ {
	/// When we're in this state, this COption_ThirtyTwoBytesZ contains a crate::c_types::ThirtyTwoBytes
	Some(crate::c_types::ThirtyTwoBytes),
	/// When we're in this state, this COption_ThirtyTwoBytesZ contains nothing
	None
}
impl COption_ThirtyTwoBytesZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::ThirtyTwoBytes {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_ThirtyTwoBytesZ containing a crate::c_types::ThirtyTwoBytes
pub extern "C" fn COption_ThirtyTwoBytesZ_some(o: crate::c_types::ThirtyTwoBytes) -> COption_ThirtyTwoBytesZ {
	COption_ThirtyTwoBytesZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_ThirtyTwoBytesZ containing nothing
pub extern "C" fn COption_ThirtyTwoBytesZ_none() -> COption_ThirtyTwoBytesZ {
	COption_ThirtyTwoBytesZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::ThirtyTwoBytes, if we are in the Some state
pub extern "C" fn COption_ThirtyTwoBytesZ_free(_res: COption_ThirtyTwoBytesZ) { }
#[no_mangle]
/// Creates a new COption_ThirtyTwoBytesZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_ThirtyTwoBytesZ_clone(orig: &COption_ThirtyTwoBytesZ) -> COption_ThirtyTwoBytesZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::CVec_u8Z or not
pub enum COption_CVec_u8ZZ {
	/// When we're in this state, this COption_CVec_u8ZZ contains a crate::c_types::derived::CVec_u8Z
	Some(crate::c_types::derived::CVec_u8Z),
	/// When we're in this state, this COption_CVec_u8ZZ contains nothing
	None
}
impl COption_CVec_u8ZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::CVec_u8Z {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_CVec_u8ZZ containing a crate::c_types::derived::CVec_u8Z
pub extern "C" fn COption_CVec_u8ZZ_some(o: crate::c_types::derived::CVec_u8Z) -> COption_CVec_u8ZZ {
	COption_CVec_u8ZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_CVec_u8ZZ containing nothing
pub extern "C" fn COption_CVec_u8ZZ_none() -> COption_CVec_u8ZZ {
	COption_CVec_u8ZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::CVec_u8Z, if we are in the Some state
pub extern "C" fn COption_CVec_u8ZZ_free(_res: COption_CVec_u8ZZ) { }
#[no_mangle]
/// Creates a new COption_CVec_u8ZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_CVec_u8ZZ_clone(orig: &COption_CVec_u8ZZ) -> COption_CVec_u8ZZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RecipientOnionFieldsDecodeErrorZ
pub union CResult_RecipientOnionFieldsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::outbound_payment::RecipientOnionFields,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RecipientOnionFieldsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::outbound_payment::RecipientOnionFields on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RecipientOnionFieldsDecodeErrorZ {
	/// The contents of this CResult_RecipientOnionFieldsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RecipientOnionFieldsDecodeErrorZPtr,
	/// Whether this CResult_RecipientOnionFieldsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsDecodeErrorZ in the success state.
pub extern "C" fn CResult_RecipientOnionFieldsDecodeErrorZ_ok(o: crate::lightning::ln::outbound_payment::RecipientOnionFields) -> CResult_RecipientOnionFieldsDecodeErrorZ {
	CResult_RecipientOnionFieldsDecodeErrorZ {
		contents: CResult_RecipientOnionFieldsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsDecodeErrorZ in the error state.
pub extern "C" fn CResult_RecipientOnionFieldsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RecipientOnionFieldsDecodeErrorZ {
	CResult_RecipientOnionFieldsDecodeErrorZ {
		contents: CResult_RecipientOnionFieldsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RecipientOnionFieldsDecodeErrorZ_is_ok(o: &CResult_RecipientOnionFieldsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RecipientOnionFieldsDecodeErrorZ.
pub extern "C" fn CResult_RecipientOnionFieldsDecodeErrorZ_free(_res: CResult_RecipientOnionFieldsDecodeErrorZ) { }
impl Drop for CResult_RecipientOnionFieldsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::RecipientOnionFields, crate::lightning::ln::msgs::DecodeError>> for CResult_RecipientOnionFieldsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::RecipientOnionFields, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RecipientOnionFieldsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RecipientOnionFieldsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RecipientOnionFieldsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RecipientOnionFieldsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::RecipientOnionFields>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RecipientOnionFieldsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RecipientOnionFieldsDecodeErrorZ_clone(orig: &CResult_RecipientOnionFieldsDecodeErrorZ) -> CResult_RecipientOnionFieldsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_u64CVec_u8ZZ {
	/// The element at position 0
	pub a: u64,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_u8Z,
}
impl From<(u64, crate::c_types::derived::CVec_u8Z)> for C2Tuple_u64CVec_u8ZZ {
	fn from (tup: (u64, crate::c_types::derived::CVec_u8Z)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_u64CVec_u8ZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (u64, crate::c_types::derived::CVec_u8Z) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_u64CVec_u8ZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_u64CVec_u8ZZ_clone(orig: &C2Tuple_u64CVec_u8ZZ) -> C2Tuple_u64CVec_u8ZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_u64CVec_u8ZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_u64CVec_u8ZZ_new(a: u64, b: crate::c_types::derived::CVec_u8Z) -> C2Tuple_u64CVec_u8ZZ {
	C2Tuple_u64CVec_u8ZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_u64CVec_u8ZZ.
pub extern "C" fn C2Tuple_u64CVec_u8ZZ_free(_res: C2Tuple_u64CVec_u8ZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_u64CVec_u8ZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_u64CVec_u8ZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_u64CVec_u8ZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_u64CVec_u8ZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_u64CVec_u8ZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_u64CVec_u8ZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_u64CVec_u8ZZ>> for CVec_C2Tuple_u64CVec_u8ZZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_u64CVec_u8ZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_u64CVec_u8ZZZ_free(_res: CVec_C2Tuple_u64CVec_u8ZZZ) { }
impl Drop for CVec_C2Tuple_u64CVec_u8ZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_u64CVec_u8ZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RecipientOnionFieldsNoneZ
pub union CResult_RecipientOnionFieldsNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::outbound_payment::RecipientOnionFields,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_RecipientOnionFieldsNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::outbound_payment::RecipientOnionFields on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RecipientOnionFieldsNoneZ {
	/// The contents of this CResult_RecipientOnionFieldsNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RecipientOnionFieldsNoneZPtr,
	/// Whether this CResult_RecipientOnionFieldsNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsNoneZ in the success state.
pub extern "C" fn CResult_RecipientOnionFieldsNoneZ_ok(o: crate::lightning::ln::outbound_payment::RecipientOnionFields) -> CResult_RecipientOnionFieldsNoneZ {
	CResult_RecipientOnionFieldsNoneZ {
		contents: CResult_RecipientOnionFieldsNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsNoneZ in the error state.
pub extern "C" fn CResult_RecipientOnionFieldsNoneZ_err() -> CResult_RecipientOnionFieldsNoneZ {
	CResult_RecipientOnionFieldsNoneZ {
		contents: CResult_RecipientOnionFieldsNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RecipientOnionFieldsNoneZ_is_ok(o: &CResult_RecipientOnionFieldsNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RecipientOnionFieldsNoneZ.
pub extern "C" fn CResult_RecipientOnionFieldsNoneZ_free(_res: CResult_RecipientOnionFieldsNoneZ) { }
impl Drop for CResult_RecipientOnionFieldsNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::RecipientOnionFields, ()>> for CResult_RecipientOnionFieldsNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::RecipientOnionFields, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RecipientOnionFieldsNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_RecipientOnionFieldsNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RecipientOnionFieldsNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RecipientOnionFieldsNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::RecipientOnionFields>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RecipientOnionFieldsNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RecipientOnionFieldsNoneZ_clone(orig: &CResult_RecipientOnionFieldsNoneZ) -> CResult_RecipientOnionFieldsNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_DNSResolverMessageResponseInstructionZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::dns_resolution::DNSResolverMessage,
	/// The element at position 1
	pub b: crate::lightning::onion_message::messenger::ResponseInstruction,
}
impl From<(crate::lightning::onion_message::dns_resolution::DNSResolverMessage, crate::lightning::onion_message::messenger::ResponseInstruction)> for C2Tuple_DNSResolverMessageResponseInstructionZ {
	fn from (tup: (crate::lightning::onion_message::dns_resolution::DNSResolverMessage, crate::lightning::onion_message::messenger::ResponseInstruction)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_DNSResolverMessageResponseInstructionZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::dns_resolution::DNSResolverMessage, crate::lightning::onion_message::messenger::ResponseInstruction) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_DNSResolverMessageResponseInstructionZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_DNSResolverMessageResponseInstructionZ_clone(orig: &C2Tuple_DNSResolverMessageResponseInstructionZ) -> C2Tuple_DNSResolverMessageResponseInstructionZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_DNSResolverMessageResponseInstructionZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_DNSResolverMessageResponseInstructionZ_new(a: crate::lightning::onion_message::dns_resolution::DNSResolverMessage, b: crate::lightning::onion_message::messenger::ResponseInstruction) -> C2Tuple_DNSResolverMessageResponseInstructionZ {
	C2Tuple_DNSResolverMessageResponseInstructionZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_DNSResolverMessageResponseInstructionZ.
pub extern "C" fn C2Tuple_DNSResolverMessageResponseInstructionZ_free(_res: C2Tuple_DNSResolverMessageResponseInstructionZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_DNSResolverMessageResponseInstructionZ or not
pub enum COption_C2Tuple_DNSResolverMessageResponseInstructionZZ {
	/// When we're in this state, this COption_C2Tuple_DNSResolverMessageResponseInstructionZZ contains a crate::c_types::derived::C2Tuple_DNSResolverMessageResponseInstructionZ
	Some(crate::c_types::derived::C2Tuple_DNSResolverMessageResponseInstructionZ),
	/// When we're in this state, this COption_C2Tuple_DNSResolverMessageResponseInstructionZZ contains nothing
	None
}
impl COption_C2Tuple_DNSResolverMessageResponseInstructionZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_DNSResolverMessageResponseInstructionZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_DNSResolverMessageResponseInstructionZZ containing a crate::c_types::derived::C2Tuple_DNSResolverMessageResponseInstructionZ
pub extern "C" fn COption_C2Tuple_DNSResolverMessageResponseInstructionZZ_some(o: crate::c_types::derived::C2Tuple_DNSResolverMessageResponseInstructionZ) -> COption_C2Tuple_DNSResolverMessageResponseInstructionZZ {
	COption_C2Tuple_DNSResolverMessageResponseInstructionZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_DNSResolverMessageResponseInstructionZZ containing nothing
pub extern "C" fn COption_C2Tuple_DNSResolverMessageResponseInstructionZZ_none() -> COption_C2Tuple_DNSResolverMessageResponseInstructionZZ {
	COption_C2Tuple_DNSResolverMessageResponseInstructionZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_DNSResolverMessageResponseInstructionZ, if we are in the Some state
pub extern "C" fn COption_C2Tuple_DNSResolverMessageResponseInstructionZZ_free(_res: COption_C2Tuple_DNSResolverMessageResponseInstructionZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_DNSResolverMessageResponseInstructionZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_DNSResolverMessageResponseInstructionZZ_clone(orig: &COption_C2Tuple_DNSResolverMessageResponseInstructionZZ) -> COption_C2Tuple_DNSResolverMessageResponseInstructionZZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_DNSResolverMessageMessageSendInstructionsZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::dns_resolution::DNSResolverMessage,
	/// The element at position 1
	pub b: crate::lightning::onion_message::messenger::MessageSendInstructions,
}
impl From<(crate::lightning::onion_message::dns_resolution::DNSResolverMessage, crate::lightning::onion_message::messenger::MessageSendInstructions)> for C2Tuple_DNSResolverMessageMessageSendInstructionsZ {
	fn from (tup: (crate::lightning::onion_message::dns_resolution::DNSResolverMessage, crate::lightning::onion_message::messenger::MessageSendInstructions)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_DNSResolverMessageMessageSendInstructionsZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::dns_resolution::DNSResolverMessage, crate::lightning::onion_message::messenger::MessageSendInstructions) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_DNSResolverMessageMessageSendInstructionsZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_DNSResolverMessageMessageSendInstructionsZ_clone(orig: &C2Tuple_DNSResolverMessageMessageSendInstructionsZ) -> C2Tuple_DNSResolverMessageMessageSendInstructionsZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_DNSResolverMessageMessageSendInstructionsZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_DNSResolverMessageMessageSendInstructionsZ_new(a: crate::lightning::onion_message::dns_resolution::DNSResolverMessage, b: crate::lightning::onion_message::messenger::MessageSendInstructions) -> C2Tuple_DNSResolverMessageMessageSendInstructionsZ {
	C2Tuple_DNSResolverMessageMessageSendInstructionsZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_DNSResolverMessageMessageSendInstructionsZ.
pub extern "C" fn C2Tuple_DNSResolverMessageMessageSendInstructionsZ_free(_res: C2Tuple_DNSResolverMessageMessageSendInstructionsZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_DNSResolverMessageMessageSendInstructionsZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_DNSResolverMessageMessageSendInstructionsZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_DNSResolverMessageMessageSendInstructionsZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_DNSResolverMessageMessageSendInstructionsZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_DNSResolverMessageMessageSendInstructionsZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_DNSResolverMessageMessageSendInstructionsZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_DNSResolverMessageMessageSendInstructionsZ>> for CVec_C2Tuple_DNSResolverMessageMessageSendInstructionsZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_DNSResolverMessageMessageSendInstructionsZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_DNSResolverMessageMessageSendInstructionsZZ_free(_res: CVec_C2Tuple_DNSResolverMessageMessageSendInstructionsZZ) { }
impl Drop for CVec_C2Tuple_DNSResolverMessageMessageSendInstructionsZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_DNSResolverMessageMessageSendInstructionsZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_DNSResolverMessageDecodeErrorZ
pub union CResult_DNSResolverMessageDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::dns_resolution::DNSResolverMessage,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_DNSResolverMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::dns_resolution::DNSResolverMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_DNSResolverMessageDecodeErrorZ {
	/// The contents of this CResult_DNSResolverMessageDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_DNSResolverMessageDecodeErrorZPtr,
	/// Whether this CResult_DNSResolverMessageDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_DNSResolverMessageDecodeErrorZ in the success state.
pub extern "C" fn CResult_DNSResolverMessageDecodeErrorZ_ok(o: crate::lightning::onion_message::dns_resolution::DNSResolverMessage) -> CResult_DNSResolverMessageDecodeErrorZ {
	CResult_DNSResolverMessageDecodeErrorZ {
		contents: CResult_DNSResolverMessageDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_DNSResolverMessageDecodeErrorZ in the error state.
pub extern "C" fn CResult_DNSResolverMessageDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_DNSResolverMessageDecodeErrorZ {
	CResult_DNSResolverMessageDecodeErrorZ {
		contents: CResult_DNSResolverMessageDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_DNSResolverMessageDecodeErrorZ_is_ok(o: &CResult_DNSResolverMessageDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_DNSResolverMessageDecodeErrorZ.
pub extern "C" fn CResult_DNSResolverMessageDecodeErrorZ_free(_res: CResult_DNSResolverMessageDecodeErrorZ) { }
impl Drop for CResult_DNSResolverMessageDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::dns_resolution::DNSResolverMessage, crate::lightning::ln::msgs::DecodeError>> for CResult_DNSResolverMessageDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::dns_resolution::DNSResolverMessage, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_DNSResolverMessageDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_DNSResolverMessageDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_DNSResolverMessageDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_DNSResolverMessageDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::dns_resolution::DNSResolverMessage>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_DNSResolverMessageDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_DNSResolverMessageDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_DNSResolverMessageDecodeErrorZ_clone(orig: &CResult_DNSResolverMessageDecodeErrorZ) -> CResult_DNSResolverMessageDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HumanReadableNameNoneZ
pub union CResult_HumanReadableNameNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::dns_resolution::HumanReadableName,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_HumanReadableNameNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::dns_resolution::HumanReadableName on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HumanReadableNameNoneZ {
	/// The contents of this CResult_HumanReadableNameNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HumanReadableNameNoneZPtr,
	/// Whether this CResult_HumanReadableNameNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HumanReadableNameNoneZ in the success state.
pub extern "C" fn CResult_HumanReadableNameNoneZ_ok(o: crate::lightning::onion_message::dns_resolution::HumanReadableName) -> CResult_HumanReadableNameNoneZ {
	CResult_HumanReadableNameNoneZ {
		contents: CResult_HumanReadableNameNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HumanReadableNameNoneZ in the error state.
pub extern "C" fn CResult_HumanReadableNameNoneZ_err() -> CResult_HumanReadableNameNoneZ {
	CResult_HumanReadableNameNoneZ {
		contents: CResult_HumanReadableNameNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HumanReadableNameNoneZ_is_ok(o: &CResult_HumanReadableNameNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HumanReadableNameNoneZ.
pub extern "C" fn CResult_HumanReadableNameNoneZ_free(_res: CResult_HumanReadableNameNoneZ) { }
impl Drop for CResult_HumanReadableNameNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::dns_resolution::HumanReadableName, ()>> for CResult_HumanReadableNameNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::dns_resolution::HumanReadableName, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HumanReadableNameNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_HumanReadableNameNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HumanReadableNameNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HumanReadableNameNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::dns_resolution::HumanReadableName>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HumanReadableNameNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HumanReadableNameNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HumanReadableNameNoneZ_clone(orig: &CResult_HumanReadableNameNoneZ) -> CResult_HumanReadableNameNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HumanReadableNameDecodeErrorZ
pub union CResult_HumanReadableNameDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::dns_resolution::HumanReadableName,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HumanReadableNameDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::dns_resolution::HumanReadableName on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HumanReadableNameDecodeErrorZ {
	/// The contents of this CResult_HumanReadableNameDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HumanReadableNameDecodeErrorZPtr,
	/// Whether this CResult_HumanReadableNameDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HumanReadableNameDecodeErrorZ in the success state.
pub extern "C" fn CResult_HumanReadableNameDecodeErrorZ_ok(o: crate::lightning::onion_message::dns_resolution::HumanReadableName) -> CResult_HumanReadableNameDecodeErrorZ {
	CResult_HumanReadableNameDecodeErrorZ {
		contents: CResult_HumanReadableNameDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HumanReadableNameDecodeErrorZ in the error state.
pub extern "C" fn CResult_HumanReadableNameDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HumanReadableNameDecodeErrorZ {
	CResult_HumanReadableNameDecodeErrorZ {
		contents: CResult_HumanReadableNameDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HumanReadableNameDecodeErrorZ_is_ok(o: &CResult_HumanReadableNameDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HumanReadableNameDecodeErrorZ.
pub extern "C" fn CResult_HumanReadableNameDecodeErrorZ_free(_res: CResult_HumanReadableNameDecodeErrorZ) { }
impl Drop for CResult_HumanReadableNameDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::dns_resolution::HumanReadableName, crate::lightning::ln::msgs::DecodeError>> for CResult_HumanReadableNameDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::dns_resolution::HumanReadableName, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HumanReadableNameDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HumanReadableNameDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HumanReadableNameDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HumanReadableNameDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::dns_resolution::HumanReadableName>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HumanReadableNameDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HumanReadableNameDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HumanReadableNameDecodeErrorZ_clone(orig: &CResult_HumanReadableNameDecodeErrorZ) -> CResult_HumanReadableNameDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_DNSSECQueryDNSResolverContextZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::dns_resolution::DNSSECQuery,
	/// The element at position 1
	pub b: crate::lightning::blinded_path::message::DNSResolverContext,
}
impl From<(crate::lightning::onion_message::dns_resolution::DNSSECQuery, crate::lightning::blinded_path::message::DNSResolverContext)> for C2Tuple_DNSSECQueryDNSResolverContextZ {
	fn from (tup: (crate::lightning::onion_message::dns_resolution::DNSSECQuery, crate::lightning::blinded_path::message::DNSResolverContext)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_DNSSECQueryDNSResolverContextZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::dns_resolution::DNSSECQuery, crate::lightning::blinded_path::message::DNSResolverContext) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_DNSSECQueryDNSResolverContextZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_DNSSECQueryDNSResolverContextZ_clone(orig: &C2Tuple_DNSSECQueryDNSResolverContextZ) -> C2Tuple_DNSSECQueryDNSResolverContextZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_DNSSECQueryDNSResolverContextZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_DNSSECQueryDNSResolverContextZ_new(a: crate::lightning::onion_message::dns_resolution::DNSSECQuery, b: crate::lightning::blinded_path::message::DNSResolverContext) -> C2Tuple_DNSSECQueryDNSResolverContextZ {
	C2Tuple_DNSSECQueryDNSResolverContextZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_DNSSECQueryDNSResolverContextZ.
pub extern "C" fn C2Tuple_DNSSECQueryDNSResolverContextZ_free(_res: C2Tuple_DNSSECQueryDNSResolverContextZ) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ
pub union CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_DNSSECQueryDNSResolverContextZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_DNSSECQueryDNSResolverContextZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ {
	/// The contents of this CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZPtr,
	/// Whether this CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ in the success state.
pub extern "C" fn CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ_ok(o: crate::c_types::derived::C2Tuple_DNSSECQueryDNSResolverContextZ) -> CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ {
	CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ {
		contents: CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ in the error state.
pub extern "C" fn CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ_err() -> CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ {
	CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ {
		contents: CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ_is_ok(o: &CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ.
pub extern "C" fn CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ_free(_res: CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ) { }
impl Drop for CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_DNSSECQueryDNSResolverContextZ, ()>> for CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_DNSSECQueryDNSResolverContextZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_DNSSECQueryDNSResolverContextZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ_clone(orig: &CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ) -> CResult_C2Tuple_DNSSECQueryDNSResolverContextZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_HumanReadableNameThirtyTwoBytesZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::dns_resolution::HumanReadableName,
	/// The element at position 1
	pub b: crate::c_types::ThirtyTwoBytes,
}
impl From<(crate::lightning::onion_message::dns_resolution::HumanReadableName, crate::c_types::ThirtyTwoBytes)> for C2Tuple_HumanReadableNameThirtyTwoBytesZ {
	fn from (tup: (crate::lightning::onion_message::dns_resolution::HumanReadableName, crate::c_types::ThirtyTwoBytes)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_HumanReadableNameThirtyTwoBytesZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::dns_resolution::HumanReadableName, crate::c_types::ThirtyTwoBytes) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_HumanReadableNameThirtyTwoBytesZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_HumanReadableNameThirtyTwoBytesZ_clone(orig: &C2Tuple_HumanReadableNameThirtyTwoBytesZ) -> C2Tuple_HumanReadableNameThirtyTwoBytesZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_HumanReadableNameThirtyTwoBytesZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_HumanReadableNameThirtyTwoBytesZ_new(a: crate::lightning::onion_message::dns_resolution::HumanReadableName, b: crate::c_types::ThirtyTwoBytes) -> C2Tuple_HumanReadableNameThirtyTwoBytesZ {
	C2Tuple_HumanReadableNameThirtyTwoBytesZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_HumanReadableNameThirtyTwoBytesZ.
pub extern "C" fn C2Tuple_HumanReadableNameThirtyTwoBytesZ_free(_res: C2Tuple_HumanReadableNameThirtyTwoBytesZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_HumanReadableNameThirtyTwoBytesZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_HumanReadableNameThirtyTwoBytesZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_HumanReadableNameThirtyTwoBytesZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_HumanReadableNameThirtyTwoBytesZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_HumanReadableNameThirtyTwoBytesZ>> for CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_HumanReadableNameThirtyTwoBytesZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ_free(_res: CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ) { }
impl Drop for CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ {
	/// The element at position 0
	pub a: crate::c_types::derived::CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ,
	/// The element at position 1
	pub b: crate::lightning::offers::offer::Offer,
}
impl From<(crate::c_types::derived::CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ, crate::lightning::offers::offer::Offer)> for C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ {
	fn from (tup: (crate::c_types::derived::CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ, crate::lightning::offers::offer::Offer)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::derived::CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ, crate::lightning::offers::offer::Offer) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ_clone(orig: &C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ) -> C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ_new(a: crate::c_types::derived::CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ, b: crate::lightning::offers::offer::Offer) -> C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ {
	C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ.
pub extern "C" fn C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ_free(_res: C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ or not
pub enum COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ {
	/// When we're in this state, this COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ contains a crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ
	Some(crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ),
	/// When we're in this state, this COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ contains nothing
	None
}
impl COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ containing a crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ
pub extern "C" fn COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ_some(o: crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ) -> COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ {
	COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ containing nothing
pub extern "C" fn COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ_none() -> COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ {
	COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZ, if we are in the Some state
pub extern "C" fn COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ_free(_res: COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ_clone(orig: &COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ) -> COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZOfferZZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ {
	/// The element at position 0
	pub a: crate::c_types::derived::CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ,
	/// The element at position 1
	pub b: crate::c_types::Str,
}
impl From<(crate::c_types::derived::CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ, crate::c_types::Str)> for C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ {
	fn from (tup: (crate::c_types::derived::CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ, crate::c_types::Str)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::derived::CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ, crate::c_types::Str) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ_clone(orig: &C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ) -> C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ_new(a: crate::c_types::derived::CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZ, b: crate::c_types::Str) -> C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ {
	C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ.
pub extern "C" fn C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ_free(_res: C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ or not
pub enum COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ {
	/// When we're in this state, this COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ contains a crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ
	Some(crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ),
	/// When we're in this state, this COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ contains nothing
	None
}
impl COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ containing a crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ
pub extern "C" fn COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ_some(o: crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ) -> COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ {
	COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ containing nothing
pub extern "C" fn COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ_none() -> COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ {
	COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZ, if we are in the Some state
pub extern "C" fn COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ_free(_res: COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ_clone(orig: &COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ) -> COption_C2Tuple_CVec_C2Tuple_HumanReadableNameThirtyTwoBytesZZStrZZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ
pub union CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice::UnsignedBolt12Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice::UnsignedBolt12Invoice on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ {
	/// The contents of this CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZPtr,
	/// Whether this CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ_ok(o: crate::lightning::offers::invoice::UnsignedBolt12Invoice) -> CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ {
	CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ {
		contents: CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ {
	CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ {
		contents: CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ_is_ok(o: &CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ.
pub extern "C" fn CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ_free(_res: CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ) { }
impl Drop for CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice::UnsignedBolt12Invoice, crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice::UnsignedBolt12Invoice, crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice::UnsignedBolt12Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ_clone(orig: &CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ) -> CResult_UnsignedBolt12InvoiceBolt12SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt12InvoiceBolt12SemanticErrorZ
pub union CResult_Bolt12InvoiceBolt12SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice::Bolt12Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_Bolt12InvoiceBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice::Bolt12Invoice on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt12InvoiceBolt12SemanticErrorZ {
	/// The contents of this CResult_Bolt12InvoiceBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt12InvoiceBolt12SemanticErrorZPtr,
	/// Whether this CResult_Bolt12InvoiceBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_Bolt12InvoiceBolt12SemanticErrorZ_ok(o: crate::lightning::offers::invoice::Bolt12Invoice) -> CResult_Bolt12InvoiceBolt12SemanticErrorZ {
	CResult_Bolt12InvoiceBolt12SemanticErrorZ {
		contents: CResult_Bolt12InvoiceBolt12SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_Bolt12InvoiceBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_Bolt12InvoiceBolt12SemanticErrorZ {
	CResult_Bolt12InvoiceBolt12SemanticErrorZ {
		contents: CResult_Bolt12InvoiceBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt12InvoiceBolt12SemanticErrorZ_is_ok(o: &CResult_Bolt12InvoiceBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt12InvoiceBolt12SemanticErrorZ.
pub extern "C" fn CResult_Bolt12InvoiceBolt12SemanticErrorZ_free(_res: CResult_Bolt12InvoiceBolt12SemanticErrorZ) { }
impl Drop for CResult_Bolt12InvoiceBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice::Bolt12Invoice, crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_Bolt12InvoiceBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice::Bolt12Invoice, crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt12InvoiceBolt12SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt12InvoiceBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt12InvoiceBolt12SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt12InvoiceBolt12SemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice::Bolt12Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt12InvoiceBolt12SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceBolt12SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt12InvoiceBolt12SemanticErrorZ_clone(orig: &CResult_Bolt12InvoiceBolt12SemanticErrorZ) -> CResult_Bolt12InvoiceBolt12SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SchnorrSignatureNoneZ
pub union CResult_SchnorrSignatureNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::SchnorrSignature,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_SchnorrSignatureNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::SchnorrSignature on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SchnorrSignatureNoneZ {
	/// The contents of this CResult_SchnorrSignatureNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SchnorrSignatureNoneZPtr,
	/// Whether this CResult_SchnorrSignatureNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SchnorrSignatureNoneZ in the success state.
pub extern "C" fn CResult_SchnorrSignatureNoneZ_ok(o: crate::c_types::SchnorrSignature) -> CResult_SchnorrSignatureNoneZ {
	CResult_SchnorrSignatureNoneZ {
		contents: CResult_SchnorrSignatureNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SchnorrSignatureNoneZ in the error state.
pub extern "C" fn CResult_SchnorrSignatureNoneZ_err() -> CResult_SchnorrSignatureNoneZ {
	CResult_SchnorrSignatureNoneZ {
		contents: CResult_SchnorrSignatureNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SchnorrSignatureNoneZ_is_ok(o: &CResult_SchnorrSignatureNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SchnorrSignatureNoneZ.
pub extern "C" fn CResult_SchnorrSignatureNoneZ_free(_res: CResult_SchnorrSignatureNoneZ) { }
impl Drop for CResult_SchnorrSignatureNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::SchnorrSignature, ()>> for CResult_SchnorrSignatureNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::SchnorrSignature, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SchnorrSignatureNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_SchnorrSignatureNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SchnorrSignatureNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SchnorrSignatureNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::SchnorrSignature>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SchnorrSignatureNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SchnorrSignatureNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SchnorrSignatureNoneZ_clone(orig: &CResult_SchnorrSignatureNoneZ) -> CResult_SchnorrSignatureNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::blinded_path::payment::BlindedPaymentPaths of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_BlindedPaymentPathZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::blinded_path::payment::BlindedPaymentPath,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_BlindedPaymentPathZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::blinded_path::payment::BlindedPaymentPath> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::blinded_path::payment::BlindedPaymentPath] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::blinded_path::payment::BlindedPaymentPath>> for CVec_BlindedPaymentPathZ {
	fn from(v: Vec<crate::lightning::blinded_path::payment::BlindedPaymentPath>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_BlindedPaymentPathZ_free(_res: CVec_BlindedPaymentPathZ) { }
impl Drop for CVec_BlindedPaymentPathZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_BlindedPaymentPathZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::Strs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_StrZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::Str,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_StrZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::Str> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::Str] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::Str>> for CVec_StrZ {
	fn from(v: Vec<crate::c_types::Str>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_StrZ_free(_res: CVec_StrZ) { }
impl Drop for CVec_StrZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_StrZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ThirtyTwoBytesZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::ThirtyTwoBytes,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ThirtyTwoBytesZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::ThirtyTwoBytes> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::ThirtyTwoBytes] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::ThirtyTwoBytes>> for CVec_ThirtyTwoBytesZ {
	fn from(v: Vec<crate::c_types::ThirtyTwoBytes>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ThirtyTwoBytesZ_free(_res: CVec_ThirtyTwoBytesZ) { }
impl Drop for CVec_ThirtyTwoBytesZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ThirtyTwoBytesZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::CVec_ThirtyTwoBytesZ or not
pub enum COption_CVec_ThirtyTwoBytesZZ {
	/// When we're in this state, this COption_CVec_ThirtyTwoBytesZZ contains a crate::c_types::derived::CVec_ThirtyTwoBytesZ
	Some(crate::c_types::derived::CVec_ThirtyTwoBytesZ),
	/// When we're in this state, this COption_CVec_ThirtyTwoBytesZZ contains nothing
	None
}
impl COption_CVec_ThirtyTwoBytesZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::CVec_ThirtyTwoBytesZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_CVec_ThirtyTwoBytesZZ containing a crate::c_types::derived::CVec_ThirtyTwoBytesZ
pub extern "C" fn COption_CVec_ThirtyTwoBytesZZ_some(o: crate::c_types::derived::CVec_ThirtyTwoBytesZ) -> COption_CVec_ThirtyTwoBytesZZ {
	COption_CVec_ThirtyTwoBytesZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_CVec_ThirtyTwoBytesZZ containing nothing
pub extern "C" fn COption_CVec_ThirtyTwoBytesZZ_none() -> COption_CVec_ThirtyTwoBytesZZ {
	COption_CVec_ThirtyTwoBytesZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::CVec_ThirtyTwoBytesZ, if we are in the Some state
pub extern "C" fn COption_CVec_ThirtyTwoBytesZZ_free(_res: COption_CVec_ThirtyTwoBytesZZ) { }
#[no_mangle]
/// Creates a new COption_CVec_ThirtyTwoBytesZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_CVec_ThirtyTwoBytesZZ_clone(orig: &COption_CVec_ThirtyTwoBytesZZ) -> COption_CVec_ThirtyTwoBytesZZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::offers::offer::Amount or not
pub enum COption_AmountZ {
	/// When we're in this state, this COption_AmountZ contains a crate::lightning::offers::offer::Amount
	Some(crate::lightning::offers::offer::Amount),
	/// When we're in this state, this COption_AmountZ contains nothing
	None
}
impl COption_AmountZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::offers::offer::Amount {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_AmountZ containing a crate::lightning::offers::offer::Amount
pub extern "C" fn COption_AmountZ_some(o: crate::lightning::offers::offer::Amount) -> COption_AmountZ {
	COption_AmountZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_AmountZ containing nothing
pub extern "C" fn COption_AmountZ_none() -> COption_AmountZ {
	COption_AmountZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::offers::offer::Amount, if we are in the Some state
pub extern "C" fn COption_AmountZ_free(_res: COption_AmountZ) { }
#[no_mangle]
/// Creates a new COption_AmountZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_AmountZ_clone(orig: &COption_AmountZ) -> COption_AmountZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::offers::offer::Quantity or not
pub enum COption_QuantityZ {
	/// When we're in this state, this COption_QuantityZ contains a crate::lightning::offers::offer::Quantity
	Some(crate::lightning::offers::offer::Quantity),
	/// When we're in this state, this COption_QuantityZ contains nothing
	None
}
impl COption_QuantityZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::offers::offer::Quantity {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_QuantityZ containing a crate::lightning::offers::offer::Quantity
pub extern "C" fn COption_QuantityZ_some(o: crate::lightning::offers::offer::Quantity) -> COption_QuantityZ {
	COption_QuantityZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_QuantityZ containing nothing
pub extern "C" fn COption_QuantityZ_none() -> COption_QuantityZ {
	COption_QuantityZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::offers::offer::Quantity, if we are in the Some state
pub extern "C" fn COption_QuantityZ_free(_res: COption_QuantityZ) { }
#[no_mangle]
/// Creates a new COption_QuantityZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_QuantityZ_clone(orig: &COption_QuantityZ) -> COption_QuantityZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ThirtyTwoBytesNoneZ
pub union CResult_ThirtyTwoBytesNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::ThirtyTwoBytes,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_ThirtyTwoBytesNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ThirtyTwoBytesNoneZ {
	/// The contents of this CResult_ThirtyTwoBytesNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ThirtyTwoBytesNoneZPtr,
	/// Whether this CResult_ThirtyTwoBytesNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesNoneZ in the success state.
pub extern "C" fn CResult_ThirtyTwoBytesNoneZ_ok(o: crate::c_types::ThirtyTwoBytes) -> CResult_ThirtyTwoBytesNoneZ {
	CResult_ThirtyTwoBytesNoneZ {
		contents: CResult_ThirtyTwoBytesNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesNoneZ in the error state.
pub extern "C" fn CResult_ThirtyTwoBytesNoneZ_err() -> CResult_ThirtyTwoBytesNoneZ {
	CResult_ThirtyTwoBytesNoneZ {
		contents: CResult_ThirtyTwoBytesNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ThirtyTwoBytesNoneZ_is_ok(o: &CResult_ThirtyTwoBytesNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ThirtyTwoBytesNoneZ.
pub extern "C" fn CResult_ThirtyTwoBytesNoneZ_free(_res: CResult_ThirtyTwoBytesNoneZ) { }
impl Drop for CResult_ThirtyTwoBytesNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, ()>> for CResult_ThirtyTwoBytesNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ThirtyTwoBytesNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_ThirtyTwoBytesNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ThirtyTwoBytesNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ThirtyTwoBytesNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::ThirtyTwoBytes>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ThirtyTwoBytesNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ThirtyTwoBytesNoneZ_clone(orig: &CResult_ThirtyTwoBytesNoneZ) -> CResult_ThirtyTwoBytesNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt12InvoiceDecodeErrorZ
pub union CResult_Bolt12InvoiceDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice::Bolt12Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_Bolt12InvoiceDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice::Bolt12Invoice on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt12InvoiceDecodeErrorZ {
	/// The contents of this CResult_Bolt12InvoiceDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt12InvoiceDecodeErrorZPtr,
	/// Whether this CResult_Bolt12InvoiceDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceDecodeErrorZ in the success state.
pub extern "C" fn CResult_Bolt12InvoiceDecodeErrorZ_ok(o: crate::lightning::offers::invoice::Bolt12Invoice) -> CResult_Bolt12InvoiceDecodeErrorZ {
	CResult_Bolt12InvoiceDecodeErrorZ {
		contents: CResult_Bolt12InvoiceDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceDecodeErrorZ in the error state.
pub extern "C" fn CResult_Bolt12InvoiceDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_Bolt12InvoiceDecodeErrorZ {
	CResult_Bolt12InvoiceDecodeErrorZ {
		contents: CResult_Bolt12InvoiceDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt12InvoiceDecodeErrorZ_is_ok(o: &CResult_Bolt12InvoiceDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt12InvoiceDecodeErrorZ.
pub extern "C" fn CResult_Bolt12InvoiceDecodeErrorZ_free(_res: CResult_Bolt12InvoiceDecodeErrorZ) { }
impl Drop for CResult_Bolt12InvoiceDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice::Bolt12Invoice, crate::lightning::ln::msgs::DecodeError>> for CResult_Bolt12InvoiceDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice::Bolt12Invoice, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt12InvoiceDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt12InvoiceDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt12InvoiceDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt12InvoiceDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice::Bolt12Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt12InvoiceDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt12InvoiceDecodeErrorZ_clone(orig: &CResult_Bolt12InvoiceDecodeErrorZ) -> CResult_Bolt12InvoiceDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_DelayedPaymentOutputDescriptorDecodeErrorZ
pub union CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::DelayedPaymentOutputDescriptor,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::DelayedPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	/// The contents of this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr,
	/// Whether this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the success state.
pub extern "C" fn CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(o: crate::lightning::sign::DelayedPaymentOutputDescriptor) -> CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
		contents: CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the error state.
pub extern "C" fn CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
		contents: CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(o: &CResult_DelayedPaymentOutputDescriptorDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_DelayedPaymentOutputDescriptorDecodeErrorZ.
pub extern "C" fn CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(_res: CResult_DelayedPaymentOutputDescriptorDecodeErrorZ) { }
impl Drop for CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::DelayedPaymentOutputDescriptor, crate::lightning::ln::msgs::DecodeError>> for CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::DelayedPaymentOutputDescriptor, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::DelayedPaymentOutputDescriptor>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(orig: &CResult_DelayedPaymentOutputDescriptorDecodeErrorZ) -> CResult_DelayedPaymentOutputDescriptorDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_StaticPaymentOutputDescriptorDecodeErrorZ
pub union CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::StaticPaymentOutputDescriptor,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::StaticPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	/// The contents of this CResult_StaticPaymentOutputDescriptorDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr,
	/// Whether this CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the success state.
pub extern "C" fn CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(o: crate::lightning::sign::StaticPaymentOutputDescriptor) -> CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
		contents: CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the error state.
pub extern "C" fn CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
		contents: CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(o: &CResult_StaticPaymentOutputDescriptorDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_StaticPaymentOutputDescriptorDecodeErrorZ.
pub extern "C" fn CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(_res: CResult_StaticPaymentOutputDescriptorDecodeErrorZ) { }
impl Drop for CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::StaticPaymentOutputDescriptor, crate::lightning::ln::msgs::DecodeError>> for CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::StaticPaymentOutputDescriptor, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::StaticPaymentOutputDescriptor>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(orig: &CResult_StaticPaymentOutputDescriptorDecodeErrorZ) -> CResult_StaticPaymentOutputDescriptorDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SpendableOutputDescriptorDecodeErrorZ
pub union CResult_SpendableOutputDescriptorDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::SpendableOutputDescriptor,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_SpendableOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::SpendableOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SpendableOutputDescriptorDecodeErrorZ {
	/// The contents of this CResult_SpendableOutputDescriptorDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SpendableOutputDescriptorDecodeErrorZPtr,
	/// Whether this CResult_SpendableOutputDescriptorDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the success state.
pub extern "C" fn CResult_SpendableOutputDescriptorDecodeErrorZ_ok(o: crate::lightning::sign::SpendableOutputDescriptor) -> CResult_SpendableOutputDescriptorDecodeErrorZ {
	CResult_SpendableOutputDescriptorDecodeErrorZ {
		contents: CResult_SpendableOutputDescriptorDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the error state.
pub extern "C" fn CResult_SpendableOutputDescriptorDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_SpendableOutputDescriptorDecodeErrorZ {
	CResult_SpendableOutputDescriptorDecodeErrorZ {
		contents: CResult_SpendableOutputDescriptorDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(o: &CResult_SpendableOutputDescriptorDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SpendableOutputDescriptorDecodeErrorZ.
pub extern "C" fn CResult_SpendableOutputDescriptorDecodeErrorZ_free(_res: CResult_SpendableOutputDescriptorDecodeErrorZ) { }
impl Drop for CResult_SpendableOutputDescriptorDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::SpendableOutputDescriptor, crate::lightning::ln::msgs::DecodeError>> for CResult_SpendableOutputDescriptorDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::SpendableOutputDescriptor, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SpendableOutputDescriptorDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SpendableOutputDescriptorDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SpendableOutputDescriptorDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SpendableOutputDescriptorDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::SpendableOutputDescriptor>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SpendableOutputDescriptorDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SpendableOutputDescriptorDecodeErrorZ_clone(orig: &CResult_SpendableOutputDescriptorDecodeErrorZ) -> CResult_SpendableOutputDescriptorDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::sign::SpendableOutputDescriptors of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_SpendableOutputDescriptorZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::sign::SpendableOutputDescriptor,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_SpendableOutputDescriptorZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::sign::SpendableOutputDescriptor> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::sign::SpendableOutputDescriptor] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::sign::SpendableOutputDescriptor>> for CVec_SpendableOutputDescriptorZ {
	fn from(v: Vec<crate::lightning::sign::SpendableOutputDescriptor>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_SpendableOutputDescriptorZ_free(_res: CVec_SpendableOutputDescriptorZ) { }
impl Drop for CVec_SpendableOutputDescriptorZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_SpendableOutputDescriptorZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::TxOuts of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_TxOutZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::TxOut,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_TxOutZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::TxOut> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::TxOut] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::TxOut>> for CVec_TxOutZ {
	fn from(v: Vec<crate::c_types::TxOut>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_TxOutZ_free(_res: CVec_TxOutZ) { }
impl Drop for CVec_TxOutZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_TxOutZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a u32 or not
pub enum COption_u32Z {
	/// When we're in this state, this COption_u32Z contains a u32
	Some(u32),
	/// When we're in this state, this COption_u32Z contains nothing
	None
}
impl COption_u32Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> u32 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_u32Z containing a u32
pub extern "C" fn COption_u32Z_some(o: u32) -> COption_u32Z {
	COption_u32Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_u32Z containing nothing
pub extern "C" fn COption_u32Z_none() -> COption_u32Z {
	COption_u32Z::None
}
#[no_mangle]
/// Frees any resources associated with the u32, if we are in the Some state
pub extern "C" fn COption_u32Z_free(_res: COption_u32Z) { }
#[no_mangle]
/// Creates a new COption_u32Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_u32Z_clone(orig: &COption_u32Z) -> COption_u32Z { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_CVec_u8Zu64Z {
	/// The element at position 0
	pub a: crate::c_types::derived::CVec_u8Z,
	/// The element at position 1
	pub b: u64,
}
impl From<(crate::c_types::derived::CVec_u8Z, u64)> for C2Tuple_CVec_u8Zu64Z {
	fn from (tup: (crate::c_types::derived::CVec_u8Z, u64)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_CVec_u8Zu64Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::derived::CVec_u8Z, u64) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_CVec_u8Zu64Z {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_CVec_u8Zu64Z_clone(orig: &C2Tuple_CVec_u8Zu64Z) -> C2Tuple_CVec_u8Zu64Z { Clone::clone(&orig) }
/// Creates a new C2Tuple_CVec_u8Zu64Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_CVec_u8Zu64Z_new(a: crate::c_types::derived::CVec_u8Z, b: u64) -> C2Tuple_CVec_u8Zu64Z {
	C2Tuple_CVec_u8Zu64Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_CVec_u8Zu64Z.
pub extern "C" fn C2Tuple_CVec_u8Zu64Z_free(_res: C2Tuple_CVec_u8Zu64Z) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_CVec_u8Zu64ZNoneZ
pub union CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_CVec_u8Zu64Z,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_C2Tuple_CVec_u8Zu64ZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_CVec_u8Zu64Z on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	/// The contents of this CResult_C2Tuple_CVec_u8Zu64ZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr,
	/// Whether this CResult_C2Tuple_CVec_u8Zu64ZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_CVec_u8Zu64ZNoneZ in the success state.
pub extern "C" fn CResult_C2Tuple_CVec_u8Zu64ZNoneZ_ok(o: crate::c_types::derived::C2Tuple_CVec_u8Zu64Z) -> CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
		contents: CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_CVec_u8Zu64ZNoneZ in the error state.
pub extern "C" fn CResult_C2Tuple_CVec_u8Zu64ZNoneZ_err() -> CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
		contents: CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_CVec_u8Zu64ZNoneZ_is_ok(o: &CResult_C2Tuple_CVec_u8Zu64ZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_CVec_u8Zu64ZNoneZ.
pub extern "C" fn CResult_C2Tuple_CVec_u8Zu64ZNoneZ_free(_res: CResult_C2Tuple_CVec_u8Zu64ZNoneZ) { }
impl Drop for CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_CVec_u8Zu64Z, ()>> for CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_CVec_u8Zu64Z, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_CVec_u8Zu64Z>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_CVec_u8Zu64ZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_CVec_u8Zu64ZNoneZ_clone(orig: &CResult_C2Tuple_CVec_u8Zu64ZNoneZ) -> CResult_C2Tuple_CVec_u8Zu64ZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelDerivationParametersDecodeErrorZ
pub union CResult_ChannelDerivationParametersDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::ChannelDerivationParameters,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelDerivationParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::ChannelDerivationParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelDerivationParametersDecodeErrorZ {
	/// The contents of this CResult_ChannelDerivationParametersDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelDerivationParametersDecodeErrorZPtr,
	/// Whether this CResult_ChannelDerivationParametersDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelDerivationParametersDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelDerivationParametersDecodeErrorZ_ok(o: crate::lightning::sign::ChannelDerivationParameters) -> CResult_ChannelDerivationParametersDecodeErrorZ {
	CResult_ChannelDerivationParametersDecodeErrorZ {
		contents: CResult_ChannelDerivationParametersDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelDerivationParametersDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelDerivationParametersDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelDerivationParametersDecodeErrorZ {
	CResult_ChannelDerivationParametersDecodeErrorZ {
		contents: CResult_ChannelDerivationParametersDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelDerivationParametersDecodeErrorZ_is_ok(o: &CResult_ChannelDerivationParametersDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelDerivationParametersDecodeErrorZ.
pub extern "C" fn CResult_ChannelDerivationParametersDecodeErrorZ_free(_res: CResult_ChannelDerivationParametersDecodeErrorZ) { }
impl Drop for CResult_ChannelDerivationParametersDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::ChannelDerivationParameters, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelDerivationParametersDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::ChannelDerivationParameters, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelDerivationParametersDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelDerivationParametersDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelDerivationParametersDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelDerivationParametersDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::ChannelDerivationParameters>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelDerivationParametersDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelDerivationParametersDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelDerivationParametersDecodeErrorZ_clone(orig: &CResult_ChannelDerivationParametersDecodeErrorZ) -> CResult_ChannelDerivationParametersDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HTLCDescriptorDecodeErrorZ
pub union CResult_HTLCDescriptorDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::HTLCDescriptor,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HTLCDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::HTLCDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HTLCDescriptorDecodeErrorZ {
	/// The contents of this CResult_HTLCDescriptorDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HTLCDescriptorDecodeErrorZPtr,
	/// Whether this CResult_HTLCDescriptorDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HTLCDescriptorDecodeErrorZ in the success state.
pub extern "C" fn CResult_HTLCDescriptorDecodeErrorZ_ok(o: crate::lightning::sign::HTLCDescriptor) -> CResult_HTLCDescriptorDecodeErrorZ {
	CResult_HTLCDescriptorDecodeErrorZ {
		contents: CResult_HTLCDescriptorDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCDescriptorDecodeErrorZ in the error state.
pub extern "C" fn CResult_HTLCDescriptorDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HTLCDescriptorDecodeErrorZ {
	CResult_HTLCDescriptorDecodeErrorZ {
		contents: CResult_HTLCDescriptorDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HTLCDescriptorDecodeErrorZ_is_ok(o: &CResult_HTLCDescriptorDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HTLCDescriptorDecodeErrorZ.
pub extern "C" fn CResult_HTLCDescriptorDecodeErrorZ_free(_res: CResult_HTLCDescriptorDecodeErrorZ) { }
impl Drop for CResult_HTLCDescriptorDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::HTLCDescriptor, crate::lightning::ln::msgs::DecodeError>> for CResult_HTLCDescriptorDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::HTLCDescriptor, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HTLCDescriptorDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HTLCDescriptorDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HTLCDescriptorDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HTLCDescriptorDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::HTLCDescriptor>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HTLCDescriptorDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCDescriptorDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HTLCDescriptorDecodeErrorZ_clone(orig: &CResult_HTLCDescriptorDecodeErrorZ) -> CResult_HTLCDescriptorDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PublicKeyNoneZ
pub union CResult_PublicKeyNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::PublicKey,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_PublicKeyNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::PublicKey on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PublicKeyNoneZ {
	/// The contents of this CResult_PublicKeyNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PublicKeyNoneZPtr,
	/// Whether this CResult_PublicKeyNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PublicKeyNoneZ in the success state.
pub extern "C" fn CResult_PublicKeyNoneZ_ok(o: crate::c_types::PublicKey) -> CResult_PublicKeyNoneZ {
	CResult_PublicKeyNoneZ {
		contents: CResult_PublicKeyNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PublicKeyNoneZ in the error state.
pub extern "C" fn CResult_PublicKeyNoneZ_err() -> CResult_PublicKeyNoneZ {
	CResult_PublicKeyNoneZ {
		contents: CResult_PublicKeyNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PublicKeyNoneZ_is_ok(o: &CResult_PublicKeyNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PublicKeyNoneZ.
pub extern "C" fn CResult_PublicKeyNoneZ_free(_res: CResult_PublicKeyNoneZ) { }
impl Drop for CResult_PublicKeyNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::PublicKey, ()>> for CResult_PublicKeyNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::PublicKey, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PublicKeyNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_PublicKeyNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PublicKeyNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PublicKeyNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::PublicKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PublicKeyNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PublicKeyNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PublicKeyNoneZ_clone(orig: &CResult_PublicKeyNoneZ) -> CResult_PublicKeyNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult__u832NoneZ
pub union CResult__u832NoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::ThirtyTwoBytes,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult__u832NoneZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult__u832NoneZ {
	/// The contents of this CResult__u832NoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult__u832NoneZPtr,
	/// Whether this CResult__u832NoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult__u832NoneZ in the success state.
pub extern "C" fn CResult__u832NoneZ_ok(o: crate::c_types::ThirtyTwoBytes) -> CResult__u832NoneZ {
	CResult__u832NoneZ {
		contents: CResult__u832NoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult__u832NoneZ in the error state.
pub extern "C" fn CResult__u832NoneZ_err() -> CResult__u832NoneZ {
	CResult__u832NoneZ {
		contents: CResult__u832NoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult__u832NoneZ_is_ok(o: &CResult__u832NoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult__u832NoneZ.
pub extern "C" fn CResult__u832NoneZ_free(_res: CResult__u832NoneZ) { }
impl Drop for CResult__u832NoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, ()>> for CResult__u832NoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult__u832NoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult__u832NoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult__u832NoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult__u832NoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::ThirtyTwoBytes>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult__u832NoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult__u832NoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult__u832NoneZ_clone(orig: &CResult__u832NoneZ) -> CResult__u832NoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneNoneZ
pub union CResult_NoneNoneZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_NoneNoneZ represents the result of a fallible operation,
/// containing a () on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneNoneZ {
	/// The contents of this CResult_NoneNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneNoneZPtr,
	/// Whether this CResult_NoneNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneNoneZ in the success state.
pub extern "C" fn CResult_NoneNoneZ_ok() -> CResult_NoneNoneZ {
	CResult_NoneNoneZ {
		contents: CResult_NoneNoneZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneNoneZ in the error state.
pub extern "C" fn CResult_NoneNoneZ_err() -> CResult_NoneNoneZ {
	CResult_NoneNoneZ {
		contents: CResult_NoneNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneNoneZ_is_ok(o: &CResult_NoneNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneNoneZ.
pub extern "C" fn CResult_NoneNoneZ_free(_res: CResult_NoneNoneZ) { }
impl Drop for CResult_NoneNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<(), ()>> for CResult_NoneNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<(), ()>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneNoneZPtr { result: core::ptr::null_mut() }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_NoneNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneNoneZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneNoneZ_clone(orig: &CResult_NoneNoneZ) -> CResult_NoneNoneZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::BigEndianScalar or not
pub enum COption_BigEndianScalarZ {
	/// When we're in this state, this COption_BigEndianScalarZ contains a crate::c_types::BigEndianScalar
	Some(crate::c_types::BigEndianScalar),
	/// When we're in this state, this COption_BigEndianScalarZ contains nothing
	None
}
impl COption_BigEndianScalarZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::BigEndianScalar {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_BigEndianScalarZ containing a crate::c_types::BigEndianScalar
pub extern "C" fn COption_BigEndianScalarZ_some(o: crate::c_types::BigEndianScalar) -> COption_BigEndianScalarZ {
	COption_BigEndianScalarZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_BigEndianScalarZ containing nothing
pub extern "C" fn COption_BigEndianScalarZ_none() -> COption_BigEndianScalarZ {
	COption_BigEndianScalarZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::BigEndianScalar, if we are in the Some state
pub extern "C" fn COption_BigEndianScalarZ_free(_res: COption_BigEndianScalarZ) { }
#[no_mangle]
/// Creates a new COption_BigEndianScalarZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_BigEndianScalarZ_clone(orig: &COption_BigEndianScalarZ) -> COption_BigEndianScalarZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RecoverableSignatureNoneZ
pub union CResult_RecoverableSignatureNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::RecoverableSignature,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_RecoverableSignatureNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::RecoverableSignature on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RecoverableSignatureNoneZ {
	/// The contents of this CResult_RecoverableSignatureNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RecoverableSignatureNoneZPtr,
	/// Whether this CResult_RecoverableSignatureNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RecoverableSignatureNoneZ in the success state.
pub extern "C" fn CResult_RecoverableSignatureNoneZ_ok(o: crate::c_types::RecoverableSignature) -> CResult_RecoverableSignatureNoneZ {
	CResult_RecoverableSignatureNoneZ {
		contents: CResult_RecoverableSignatureNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RecoverableSignatureNoneZ in the error state.
pub extern "C" fn CResult_RecoverableSignatureNoneZ_err() -> CResult_RecoverableSignatureNoneZ {
	CResult_RecoverableSignatureNoneZ {
		contents: CResult_RecoverableSignatureNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RecoverableSignatureNoneZ_is_ok(o: &CResult_RecoverableSignatureNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RecoverableSignatureNoneZ.
pub extern "C" fn CResult_RecoverableSignatureNoneZ_free(_res: CResult_RecoverableSignatureNoneZ) { }
impl Drop for CResult_RecoverableSignatureNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::RecoverableSignature, ()>> for CResult_RecoverableSignatureNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::RecoverableSignature, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RecoverableSignatureNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_RecoverableSignatureNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RecoverableSignatureNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RecoverableSignatureNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::RecoverableSignature>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RecoverableSignatureNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RecoverableSignatureNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RecoverableSignatureNoneZ_clone(orig: &CResult_RecoverableSignatureNoneZ) -> CResult_RecoverableSignatureNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ECDSASignatureNoneZ
pub union CResult_ECDSASignatureNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::ECDSASignature,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_ECDSASignatureNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::ECDSASignature on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ECDSASignatureNoneZ {
	/// The contents of this CResult_ECDSASignatureNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ECDSASignatureNoneZPtr,
	/// Whether this CResult_ECDSASignatureNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ECDSASignatureNoneZ in the success state.
pub extern "C" fn CResult_ECDSASignatureNoneZ_ok(o: crate::c_types::ECDSASignature) -> CResult_ECDSASignatureNoneZ {
	CResult_ECDSASignatureNoneZ {
		contents: CResult_ECDSASignatureNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ECDSASignatureNoneZ in the error state.
pub extern "C" fn CResult_ECDSASignatureNoneZ_err() -> CResult_ECDSASignatureNoneZ {
	CResult_ECDSASignatureNoneZ {
		contents: CResult_ECDSASignatureNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ECDSASignatureNoneZ_is_ok(o: &CResult_ECDSASignatureNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ECDSASignatureNoneZ.
pub extern "C" fn CResult_ECDSASignatureNoneZ_free(_res: CResult_ECDSASignatureNoneZ) { }
impl Drop for CResult_ECDSASignatureNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::ECDSASignature, ()>> for CResult_ECDSASignatureNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::ECDSASignature, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ECDSASignatureNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_ECDSASignatureNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ECDSASignatureNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ECDSASignatureNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::ECDSASignature>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ECDSASignatureNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ECDSASignatureNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ECDSASignatureNoneZ_clone(orig: &CResult_ECDSASignatureNoneZ) -> CResult_ECDSASignatureNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TransactionNoneZ
pub union CResult_TransactionNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::Transaction,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_TransactionNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::Transaction on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TransactionNoneZ {
	/// The contents of this CResult_TransactionNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TransactionNoneZPtr,
	/// Whether this CResult_TransactionNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TransactionNoneZ in the success state.
pub extern "C" fn CResult_TransactionNoneZ_ok(o: crate::c_types::Transaction) -> CResult_TransactionNoneZ {
	CResult_TransactionNoneZ {
		contents: CResult_TransactionNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionNoneZ in the error state.
pub extern "C" fn CResult_TransactionNoneZ_err() -> CResult_TransactionNoneZ {
	CResult_TransactionNoneZ {
		contents: CResult_TransactionNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TransactionNoneZ_is_ok(o: &CResult_TransactionNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TransactionNoneZ.
pub extern "C" fn CResult_TransactionNoneZ_free(_res: CResult_TransactionNoneZ) { }
impl Drop for CResult_TransactionNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::Transaction, ()>> for CResult_TransactionNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::Transaction, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TransactionNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_TransactionNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TransactionNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TransactionNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::Transaction>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TransactionNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TransactionNoneZ_clone(orig: &CResult_TransactionNoneZ) -> CResult_TransactionNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_EcdsaChannelSignerDecodeErrorZ
pub union CResult_EcdsaChannelSignerDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::ecdsa::EcdsaChannelSigner,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_EcdsaChannelSignerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::ecdsa::EcdsaChannelSigner on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_EcdsaChannelSignerDecodeErrorZ {
	/// The contents of this CResult_EcdsaChannelSignerDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_EcdsaChannelSignerDecodeErrorZPtr,
	/// Whether this CResult_EcdsaChannelSignerDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_EcdsaChannelSignerDecodeErrorZ in the success state.
pub extern "C" fn CResult_EcdsaChannelSignerDecodeErrorZ_ok(o: crate::lightning::sign::ecdsa::EcdsaChannelSigner) -> CResult_EcdsaChannelSignerDecodeErrorZ {
	CResult_EcdsaChannelSignerDecodeErrorZ {
		contents: CResult_EcdsaChannelSignerDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_EcdsaChannelSignerDecodeErrorZ in the error state.
pub extern "C" fn CResult_EcdsaChannelSignerDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_EcdsaChannelSignerDecodeErrorZ {
	CResult_EcdsaChannelSignerDecodeErrorZ {
		contents: CResult_EcdsaChannelSignerDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_EcdsaChannelSignerDecodeErrorZ_is_ok(o: &CResult_EcdsaChannelSignerDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_EcdsaChannelSignerDecodeErrorZ.
pub extern "C" fn CResult_EcdsaChannelSignerDecodeErrorZ_free(_res: CResult_EcdsaChannelSignerDecodeErrorZ) { }
impl Drop for CResult_EcdsaChannelSignerDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::ecdsa::EcdsaChannelSigner, crate::lightning::ln::msgs::DecodeError>> for CResult_EcdsaChannelSignerDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::ecdsa::EcdsaChannelSigner, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_EcdsaChannelSignerDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_EcdsaChannelSignerDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_EcdsaChannelSignerDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_EcdsaChannelSignerDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::ecdsa::EcdsaChannelSigner>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_EcdsaChannelSignerDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_EcdsaChannelSignerDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_EcdsaChannelSignerDecodeErrorZ_clone(orig: &CResult_EcdsaChannelSignerDecodeErrorZ) -> CResult_EcdsaChannelSignerDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CVec_u8ZNoneZ
pub union CResult_CVec_u8ZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_u8Z,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CVec_u8ZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_u8Z on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_u8ZNoneZ {
	/// The contents of this CResult_CVec_u8ZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_u8ZNoneZPtr,
	/// Whether this CResult_CVec_u8ZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZNoneZ in the success state.
pub extern "C" fn CResult_CVec_u8ZNoneZ_ok(o: crate::c_types::derived::CVec_u8Z) -> CResult_CVec_u8ZNoneZ {
	CResult_CVec_u8ZNoneZ {
		contents: CResult_CVec_u8ZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZNoneZ in the error state.
pub extern "C" fn CResult_CVec_u8ZNoneZ_err() -> CResult_CVec_u8ZNoneZ {
	CResult_CVec_u8ZNoneZ {
		contents: CResult_CVec_u8ZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_u8ZNoneZ_is_ok(o: &CResult_CVec_u8ZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_u8ZNoneZ.
pub extern "C" fn CResult_CVec_u8ZNoneZ_free(_res: CResult_CVec_u8ZNoneZ) { }
impl Drop for CResult_CVec_u8ZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, ()>> for CResult_CVec_u8ZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_u8ZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CVec_u8ZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_u8ZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_u8ZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_u8Z>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_u8ZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_u8ZNoneZ_clone(orig: &CResult_CVec_u8ZNoneZ) -> CResult_CVec_u8ZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ShutdownScriptNoneZ
pub union CResult_ShutdownScriptNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::script::ShutdownScript,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_ShutdownScriptNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::script::ShutdownScript on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ShutdownScriptNoneZ {
	/// The contents of this CResult_ShutdownScriptNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ShutdownScriptNoneZPtr,
	/// Whether this CResult_ShutdownScriptNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptNoneZ in the success state.
pub extern "C" fn CResult_ShutdownScriptNoneZ_ok(o: crate::lightning::ln::script::ShutdownScript) -> CResult_ShutdownScriptNoneZ {
	CResult_ShutdownScriptNoneZ {
		contents: CResult_ShutdownScriptNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptNoneZ in the error state.
pub extern "C" fn CResult_ShutdownScriptNoneZ_err() -> CResult_ShutdownScriptNoneZ {
	CResult_ShutdownScriptNoneZ {
		contents: CResult_ShutdownScriptNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ShutdownScriptNoneZ_is_ok(o: &CResult_ShutdownScriptNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ShutdownScriptNoneZ.
pub extern "C" fn CResult_ShutdownScriptNoneZ_free(_res: CResult_ShutdownScriptNoneZ) { }
impl Drop for CResult_ShutdownScriptNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, ()>> for CResult_ShutdownScriptNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ShutdownScriptNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_ShutdownScriptNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ShutdownScriptNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ShutdownScriptNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::script::ShutdownScript>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ShutdownScriptNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ShutdownScriptNoneZ_clone(orig: &CResult_ShutdownScriptNoneZ) -> CResult_ShutdownScriptNoneZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a u16 or not
pub enum COption_u16Z {
	/// When we're in this state, this COption_u16Z contains a u16
	Some(u16),
	/// When we're in this state, this COption_u16Z contains nothing
	None
}
impl COption_u16Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> u16 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_u16Z containing a u16
pub extern "C" fn COption_u16Z_some(o: u16) -> COption_u16Z {
	COption_u16Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_u16Z containing nothing
pub extern "C" fn COption_u16Z_none() -> COption_u16Z {
	COption_u16Z::None
}
#[no_mangle]
/// Frees any resources associated with the u16, if we are in the Some state
pub extern "C" fn COption_u16Z_free(_res: COption_u16Z) { }
#[no_mangle]
/// Creates a new COption_u16Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_u16Z_clone(orig: &COption_u16Z) -> COption_u16Z { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a bool or not
pub enum COption_boolZ {
	/// When we're in this state, this COption_boolZ contains a bool
	Some(bool),
	/// When we're in this state, this COption_boolZ contains nothing
	None
}
impl COption_boolZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> bool {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_boolZ containing a bool
pub extern "C" fn COption_boolZ_some(o: bool) -> COption_boolZ {
	COption_boolZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_boolZ containing nothing
pub extern "C" fn COption_boolZ_none() -> COption_boolZ {
	COption_boolZ::None
}
#[no_mangle]
/// Frees any resources associated with the bool, if we are in the Some state
pub extern "C" fn COption_boolZ_free(_res: COption_boolZ) { }
#[no_mangle]
/// Creates a new COption_boolZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_boolZ_clone(orig: &COption_boolZ) -> COption_boolZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_WitnessNoneZ
pub union CResult_WitnessNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::Witness,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_WitnessNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::Witness on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_WitnessNoneZ {
	/// The contents of this CResult_WitnessNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_WitnessNoneZPtr,
	/// Whether this CResult_WitnessNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_WitnessNoneZ in the success state.
pub extern "C" fn CResult_WitnessNoneZ_ok(o: crate::c_types::Witness) -> CResult_WitnessNoneZ {
	CResult_WitnessNoneZ {
		contents: CResult_WitnessNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_WitnessNoneZ in the error state.
pub extern "C" fn CResult_WitnessNoneZ_err() -> CResult_WitnessNoneZ {
	CResult_WitnessNoneZ {
		contents: CResult_WitnessNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_WitnessNoneZ_is_ok(o: &CResult_WitnessNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_WitnessNoneZ.
pub extern "C" fn CResult_WitnessNoneZ_free(_res: CResult_WitnessNoneZ) { }
impl Drop for CResult_WitnessNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::Witness, ()>> for CResult_WitnessNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::Witness, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_WitnessNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_WitnessNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_WitnessNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_WitnessNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::Witness>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_WitnessNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_WitnessNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_WitnessNoneZ_clone(orig: &CResult_WitnessNoneZ) -> CResult_WitnessNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::ECDSASignatures of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ECDSASignatureZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::ECDSASignature,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ECDSASignatureZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::ECDSASignature> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::ECDSASignature] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::ECDSASignature>> for CVec_ECDSASignatureZ {
	fn from(v: Vec<crate::c_types::ECDSASignature>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ECDSASignatureZ_free(_res: CVec_ECDSASignatureZ) { }
impl Drop for CVec_ECDSASignatureZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ECDSASignatureZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
	/// The element at position 0
	pub a: crate::c_types::ECDSASignature,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_ECDSASignatureZ,
}
impl From<(crate::c_types::ECDSASignature, crate::c_types::derived::CVec_ECDSASignatureZ)> for C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
	fn from (tup: (crate::c_types::ECDSASignature, crate::c_types::derived::CVec_ECDSASignatureZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ECDSASignature, crate::c_types::derived::CVec_ECDSASignatureZ) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ_clone(orig: &C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ) -> C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ_new(a: crate::c_types::ECDSASignature, b: crate::c_types::derived::CVec_ECDSASignatureZ) -> C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
	C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ.
pub extern "C" fn C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ_free(_res: C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ
pub union CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	/// The contents of this CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr,
	/// Whether this CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ in the success state.
pub extern "C" fn CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_ok(o: crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ) -> CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
		contents: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ in the error state.
pub extern "C" fn CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_err() -> CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
		contents: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_is_ok(o: &CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ.
pub extern "C" fn CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_free(_res: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ) { }
impl Drop for CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ, ()>> for CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_clone(orig: &CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ) -> CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InMemorySignerDecodeErrorZ
pub union CResult_InMemorySignerDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::InMemorySigner,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InMemorySignerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::InMemorySigner on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InMemorySignerDecodeErrorZ {
	/// The contents of this CResult_InMemorySignerDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InMemorySignerDecodeErrorZPtr,
	/// Whether this CResult_InMemorySignerDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InMemorySignerDecodeErrorZ in the success state.
pub extern "C" fn CResult_InMemorySignerDecodeErrorZ_ok(o: crate::lightning::sign::InMemorySigner) -> CResult_InMemorySignerDecodeErrorZ {
	CResult_InMemorySignerDecodeErrorZ {
		contents: CResult_InMemorySignerDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InMemorySignerDecodeErrorZ in the error state.
pub extern "C" fn CResult_InMemorySignerDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InMemorySignerDecodeErrorZ {
	CResult_InMemorySignerDecodeErrorZ {
		contents: CResult_InMemorySignerDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InMemorySignerDecodeErrorZ_is_ok(o: &CResult_InMemorySignerDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InMemorySignerDecodeErrorZ.
pub extern "C" fn CResult_InMemorySignerDecodeErrorZ_free(_res: CResult_InMemorySignerDecodeErrorZ) { }
impl Drop for CResult_InMemorySignerDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::InMemorySigner, crate::lightning::ln::msgs::DecodeError>> for CResult_InMemorySignerDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::InMemorySigner, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InMemorySignerDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InMemorySignerDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InMemorySignerDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InMemorySignerDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::InMemorySigner>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InMemorySignerDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InMemorySignerDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InMemorySignerDecodeErrorZ_clone(orig: &CResult_InMemorySignerDecodeErrorZ) -> CResult_InMemorySignerDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// An enum which can either contain a crate::lightning::routing::scoring::WriteableScore or not
pub enum COption_WriteableScoreZ {
	/// When we're in this state, this COption_WriteableScoreZ contains a crate::lightning::routing::scoring::WriteableScore
	Some(crate::lightning::routing::scoring::WriteableScore),
	/// When we're in this state, this COption_WriteableScoreZ contains nothing
	None
}
impl COption_WriteableScoreZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::routing::scoring::WriteableScore {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_WriteableScoreZ containing a crate::lightning::routing::scoring::WriteableScore
pub extern "C" fn COption_WriteableScoreZ_some(o: crate::lightning::routing::scoring::WriteableScore) -> COption_WriteableScoreZ {
	COption_WriteableScoreZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_WriteableScoreZ containing nothing
pub extern "C" fn COption_WriteableScoreZ_none() -> COption_WriteableScoreZ {
	COption_WriteableScoreZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::routing::scoring::WriteableScore, if we are in the Some state
pub extern "C" fn COption_WriteableScoreZ_free(_res: COption_WriteableScoreZ) { }
#[repr(C)]
/// The contents of CResult_NoneIOErrorZ
pub union CResult_NoneIOErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_NoneIOErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneIOErrorZ {
	/// The contents of this CResult_NoneIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneIOErrorZPtr,
	/// Whether this CResult_NoneIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneIOErrorZ in the success state.
pub extern "C" fn CResult_NoneIOErrorZ_ok() -> CResult_NoneIOErrorZ {
	CResult_NoneIOErrorZ {
		contents: CResult_NoneIOErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneIOErrorZ in the error state.
pub extern "C" fn CResult_NoneIOErrorZ_err(e: crate::c_types::IOError) -> CResult_NoneIOErrorZ {
	CResult_NoneIOErrorZ {
		contents: CResult_NoneIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneIOErrorZ_is_ok(o: &CResult_NoneIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneIOErrorZ.
pub extern "C" fn CResult_NoneIOErrorZ_free(_res: CResult_NoneIOErrorZ) { }
impl Drop for CResult_NoneIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::c_types::IOError>> for CResult_NoneIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneIOErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneIOErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneIOErrorZ_clone(orig: &CResult_NoneIOErrorZ) -> CResult_NoneIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::lightning::ln::outbound_payment::RecipientOnionFields,
	/// The element at position 2
	pub c: crate::lightning::routing::router::RouteParameters,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::RecipientOnionFields, crate::lightning::routing::router::RouteParameters)> for C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::RecipientOnionFields, crate::lightning::routing::router::RouteParameters)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::RecipientOnionFields, crate::lightning::routing::router::RouteParameters) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ_clone(orig: &C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ) -> C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::lightning::ln::outbound_payment::RecipientOnionFields, c: crate::lightning::routing::router::RouteParameters) -> C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ {
	C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ.
pub extern "C" fn C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ_free(_res: C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ) { }
#[repr(C)]
/// The contents of CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ
pub union CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	/// The contents of this CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr,
	/// Whether this CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ in the success state.
pub extern "C" fn CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ_ok(o: crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ) -> CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
		contents: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ in the error state.
pub extern "C" fn CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ_err() -> CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
		contents: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ_is_ok(o: &CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ.
pub extern "C" fn CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ_free(_res: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ) { }
impl Drop for CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ, ()>> for CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ_clone(orig: &CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ) -> CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::channel_state::ChannelDetailss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ChannelDetailsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::channel_state::ChannelDetails,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ChannelDetailsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::channel_state::ChannelDetails> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::channel_state::ChannelDetails] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::channel_state::ChannelDetails>> for CVec_ChannelDetailsZ {
	fn from(v: Vec<crate::lightning::ln::channel_state::ChannelDetails>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ChannelDetailsZ_free(_res: CVec_ChannelDetailsZ) { }
impl Drop for CVec_ChannelDetailsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ChannelDetailsZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RouteLightningErrorZ
pub union CResult_RouteLightningErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::Route,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::LightningError,
}
#[repr(C)]
/// A CResult_RouteLightningErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::LightningError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteLightningErrorZ {
	/// The contents of this CResult_RouteLightningErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteLightningErrorZPtr,
	/// Whether this CResult_RouteLightningErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteLightningErrorZ in the success state.
pub extern "C" fn CResult_RouteLightningErrorZ_ok(o: crate::lightning::routing::router::Route) -> CResult_RouteLightningErrorZ {
	CResult_RouteLightningErrorZ {
		contents: CResult_RouteLightningErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteLightningErrorZ in the error state.
pub extern "C" fn CResult_RouteLightningErrorZ_err(e: crate::lightning::ln::msgs::LightningError) -> CResult_RouteLightningErrorZ {
	CResult_RouteLightningErrorZ {
		contents: CResult_RouteLightningErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteLightningErrorZ_is_ok(o: &CResult_RouteLightningErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteLightningErrorZ.
pub extern "C" fn CResult_RouteLightningErrorZ_free(_res: CResult_RouteLightningErrorZ) { }
impl Drop for CResult_RouteLightningErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::Route, crate::lightning::ln::msgs::LightningError>> for CResult_RouteLightningErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::Route, crate::lightning::ln::msgs::LightningError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteLightningErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteLightningErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteLightningErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteLightningErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::Route>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteLightningErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::LightningError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteLightningErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteLightningErrorZ_clone(orig: &CResult_RouteLightningErrorZ) -> CResult_RouteLightningErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CVec_BlindedPaymentPathZNoneZ
pub union CResult_CVec_BlindedPaymentPathZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_BlindedPaymentPathZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CVec_BlindedPaymentPathZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_BlindedPaymentPathZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_BlindedPaymentPathZNoneZ {
	/// The contents of this CResult_CVec_BlindedPaymentPathZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_BlindedPaymentPathZNoneZPtr,
	/// Whether this CResult_CVec_BlindedPaymentPathZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_BlindedPaymentPathZNoneZ in the success state.
pub extern "C" fn CResult_CVec_BlindedPaymentPathZNoneZ_ok(o: crate::c_types::derived::CVec_BlindedPaymentPathZ) -> CResult_CVec_BlindedPaymentPathZNoneZ {
	CResult_CVec_BlindedPaymentPathZNoneZ {
		contents: CResult_CVec_BlindedPaymentPathZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_BlindedPaymentPathZNoneZ in the error state.
pub extern "C" fn CResult_CVec_BlindedPaymentPathZNoneZ_err() -> CResult_CVec_BlindedPaymentPathZNoneZ {
	CResult_CVec_BlindedPaymentPathZNoneZ {
		contents: CResult_CVec_BlindedPaymentPathZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_BlindedPaymentPathZNoneZ_is_ok(o: &CResult_CVec_BlindedPaymentPathZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_BlindedPaymentPathZNoneZ.
pub extern "C" fn CResult_CVec_BlindedPaymentPathZNoneZ_free(_res: CResult_CVec_BlindedPaymentPathZNoneZ) { }
impl Drop for CResult_CVec_BlindedPaymentPathZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_BlindedPaymentPathZ, ()>> for CResult_CVec_BlindedPaymentPathZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_BlindedPaymentPathZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_BlindedPaymentPathZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CVec_BlindedPaymentPathZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_BlindedPaymentPathZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_BlindedPaymentPathZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_BlindedPaymentPathZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_BlindedPaymentPathZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_BlindedPaymentPathZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_BlindedPaymentPathZNoneZ_clone(orig: &CResult_CVec_BlindedPaymentPathZNoneZ) -> CResult_CVec_BlindedPaymentPathZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InFlightHtlcsDecodeErrorZ
pub union CResult_InFlightHtlcsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::InFlightHtlcs,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InFlightHtlcsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::InFlightHtlcs on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InFlightHtlcsDecodeErrorZ {
	/// The contents of this CResult_InFlightHtlcsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InFlightHtlcsDecodeErrorZPtr,
	/// Whether this CResult_InFlightHtlcsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InFlightHtlcsDecodeErrorZ in the success state.
pub extern "C" fn CResult_InFlightHtlcsDecodeErrorZ_ok(o: crate::lightning::routing::router::InFlightHtlcs) -> CResult_InFlightHtlcsDecodeErrorZ {
	CResult_InFlightHtlcsDecodeErrorZ {
		contents: CResult_InFlightHtlcsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InFlightHtlcsDecodeErrorZ in the error state.
pub extern "C" fn CResult_InFlightHtlcsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InFlightHtlcsDecodeErrorZ {
	CResult_InFlightHtlcsDecodeErrorZ {
		contents: CResult_InFlightHtlcsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InFlightHtlcsDecodeErrorZ_is_ok(o: &CResult_InFlightHtlcsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InFlightHtlcsDecodeErrorZ.
pub extern "C" fn CResult_InFlightHtlcsDecodeErrorZ_free(_res: CResult_InFlightHtlcsDecodeErrorZ) { }
impl Drop for CResult_InFlightHtlcsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::InFlightHtlcs, crate::lightning::ln::msgs::DecodeError>> for CResult_InFlightHtlcsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::InFlightHtlcs, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InFlightHtlcsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InFlightHtlcsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InFlightHtlcsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InFlightHtlcsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::InFlightHtlcs>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InFlightHtlcsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InFlightHtlcsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InFlightHtlcsDecodeErrorZ_clone(orig: &CResult_InFlightHtlcsDecodeErrorZ) -> CResult_InFlightHtlcsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RouteHopDecodeErrorZ
pub union CResult_RouteHopDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::RouteHop,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RouteHopDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::RouteHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteHopDecodeErrorZ {
	/// The contents of this CResult_RouteHopDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteHopDecodeErrorZPtr,
	/// Whether this CResult_RouteHopDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteHopDecodeErrorZ in the success state.
pub extern "C" fn CResult_RouteHopDecodeErrorZ_ok(o: crate::lightning::routing::router::RouteHop) -> CResult_RouteHopDecodeErrorZ {
	CResult_RouteHopDecodeErrorZ {
		contents: CResult_RouteHopDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHopDecodeErrorZ in the error state.
pub extern "C" fn CResult_RouteHopDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RouteHopDecodeErrorZ {
	CResult_RouteHopDecodeErrorZ {
		contents: CResult_RouteHopDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteHopDecodeErrorZ_is_ok(o: &CResult_RouteHopDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteHopDecodeErrorZ.
pub extern "C" fn CResult_RouteHopDecodeErrorZ_free(_res: CResult_RouteHopDecodeErrorZ) { }
impl Drop for CResult_RouteHopDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::RouteHop, crate::lightning::ln::msgs::DecodeError>> for CResult_RouteHopDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::RouteHop, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteHopDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteHopDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteHopDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteHopDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::RouteHop>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteHopDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHopDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteHopDecodeErrorZ_clone(orig: &CResult_RouteHopDecodeErrorZ) -> CResult_RouteHopDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::blinded_path::BlindedHops of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_BlindedHopZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::blinded_path::BlindedHop,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_BlindedHopZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::blinded_path::BlindedHop> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::blinded_path::BlindedHop] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::blinded_path::BlindedHop>> for CVec_BlindedHopZ {
	fn from(v: Vec<crate::lightning::blinded_path::BlindedHop>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_BlindedHopZ_free(_res: CVec_BlindedHopZ) { }
impl Drop for CVec_BlindedHopZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_BlindedHopZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_BlindedTailDecodeErrorZ
pub union CResult_BlindedTailDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::BlindedTail,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedTailDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::BlindedTail on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedTailDecodeErrorZ {
	/// The contents of this CResult_BlindedTailDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedTailDecodeErrorZPtr,
	/// Whether this CResult_BlindedTailDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedTailDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedTailDecodeErrorZ_ok(o: crate::lightning::routing::router::BlindedTail) -> CResult_BlindedTailDecodeErrorZ {
	CResult_BlindedTailDecodeErrorZ {
		contents: CResult_BlindedTailDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedTailDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedTailDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedTailDecodeErrorZ {
	CResult_BlindedTailDecodeErrorZ {
		contents: CResult_BlindedTailDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedTailDecodeErrorZ_is_ok(o: &CResult_BlindedTailDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedTailDecodeErrorZ.
pub extern "C" fn CResult_BlindedTailDecodeErrorZ_free(_res: CResult_BlindedTailDecodeErrorZ) { }
impl Drop for CResult_BlindedTailDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::BlindedTail, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedTailDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::BlindedTail, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedTailDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedTailDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedTailDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedTailDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::BlindedTail>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedTailDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedTailDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedTailDecodeErrorZ_clone(orig: &CResult_BlindedTailDecodeErrorZ) -> CResult_BlindedTailDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::routing::router::RouteHops of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_RouteHopZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::routing::router::RouteHop,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_RouteHopZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::routing::router::RouteHop> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::routing::router::RouteHop] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::routing::router::RouteHop>> for CVec_RouteHopZ {
	fn from(v: Vec<crate::lightning::routing::router::RouteHop>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_RouteHopZ_free(_res: CVec_RouteHopZ) { }
impl Drop for CVec_RouteHopZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_RouteHopZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::routing::router::Paths of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_PathZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::routing::router::Path,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_PathZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::routing::router::Path> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::routing::router::Path] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::routing::router::Path>> for CVec_PathZ {
	fn from(v: Vec<crate::lightning::routing::router::Path>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_PathZ_free(_res: CVec_PathZ) { }
impl Drop for CVec_PathZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_PathZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RouteDecodeErrorZ
pub union CResult_RouteDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::Route,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RouteDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteDecodeErrorZ {
	/// The contents of this CResult_RouteDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteDecodeErrorZPtr,
	/// Whether this CResult_RouteDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteDecodeErrorZ in the success state.
pub extern "C" fn CResult_RouteDecodeErrorZ_ok(o: crate::lightning::routing::router::Route) -> CResult_RouteDecodeErrorZ {
	CResult_RouteDecodeErrorZ {
		contents: CResult_RouteDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteDecodeErrorZ in the error state.
pub extern "C" fn CResult_RouteDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RouteDecodeErrorZ {
	CResult_RouteDecodeErrorZ {
		contents: CResult_RouteDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteDecodeErrorZ_is_ok(o: &CResult_RouteDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteDecodeErrorZ.
pub extern "C" fn CResult_RouteDecodeErrorZ_free(_res: CResult_RouteDecodeErrorZ) { }
impl Drop for CResult_RouteDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::Route, crate::lightning::ln::msgs::DecodeError>> for CResult_RouteDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::Route, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::Route>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteDecodeErrorZ_clone(orig: &CResult_RouteDecodeErrorZ) -> CResult_RouteDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RouteParametersDecodeErrorZ
pub union CResult_RouteParametersDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::RouteParameters,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RouteParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::RouteParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteParametersDecodeErrorZ {
	/// The contents of this CResult_RouteParametersDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteParametersDecodeErrorZPtr,
	/// Whether this CResult_RouteParametersDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteParametersDecodeErrorZ in the success state.
pub extern "C" fn CResult_RouteParametersDecodeErrorZ_ok(o: crate::lightning::routing::router::RouteParameters) -> CResult_RouteParametersDecodeErrorZ {
	CResult_RouteParametersDecodeErrorZ {
		contents: CResult_RouteParametersDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteParametersDecodeErrorZ in the error state.
pub extern "C" fn CResult_RouteParametersDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RouteParametersDecodeErrorZ {
	CResult_RouteParametersDecodeErrorZ {
		contents: CResult_RouteParametersDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteParametersDecodeErrorZ_is_ok(o: &CResult_RouteParametersDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteParametersDecodeErrorZ.
pub extern "C" fn CResult_RouteParametersDecodeErrorZ_free(_res: CResult_RouteParametersDecodeErrorZ) { }
impl Drop for CResult_RouteParametersDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::RouteParameters, crate::lightning::ln::msgs::DecodeError>> for CResult_RouteParametersDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::RouteParameters, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteParametersDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteParametersDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteParametersDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteParametersDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::RouteParameters>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteParametersDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteParametersDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteParametersDecodeErrorZ_clone(orig: &CResult_RouteParametersDecodeErrorZ) -> CResult_RouteParametersDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of u64s of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_u64Z {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut u64,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_u64Z {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<u64> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[u64] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<u64>> for CVec_u64Z {
	fn from(v: Vec<u64>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_u64Z_free(_res: CVec_u64Z) { }
impl Drop for CVec_u64Z {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_u64Z {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_PaymentParametersDecodeErrorZ
pub union CResult_PaymentParametersDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::PaymentParameters,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PaymentParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::PaymentParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PaymentParametersDecodeErrorZ {
	/// The contents of this CResult_PaymentParametersDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PaymentParametersDecodeErrorZPtr,
	/// Whether this CResult_PaymentParametersDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PaymentParametersDecodeErrorZ in the success state.
pub extern "C" fn CResult_PaymentParametersDecodeErrorZ_ok(o: crate::lightning::routing::router::PaymentParameters) -> CResult_PaymentParametersDecodeErrorZ {
	CResult_PaymentParametersDecodeErrorZ {
		contents: CResult_PaymentParametersDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentParametersDecodeErrorZ in the error state.
pub extern "C" fn CResult_PaymentParametersDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PaymentParametersDecodeErrorZ {
	CResult_PaymentParametersDecodeErrorZ {
		contents: CResult_PaymentParametersDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PaymentParametersDecodeErrorZ_is_ok(o: &CResult_PaymentParametersDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PaymentParametersDecodeErrorZ.
pub extern "C" fn CResult_PaymentParametersDecodeErrorZ_free(_res: CResult_PaymentParametersDecodeErrorZ) { }
impl Drop for CResult_PaymentParametersDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::PaymentParameters, crate::lightning::ln::msgs::DecodeError>> for CResult_PaymentParametersDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::PaymentParameters, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PaymentParametersDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PaymentParametersDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PaymentParametersDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PaymentParametersDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::PaymentParameters>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PaymentParametersDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentParametersDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PaymentParametersDecodeErrorZ_clone(orig: &CResult_PaymentParametersDecodeErrorZ) -> CResult_PaymentParametersDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning_types::routing::RouteHints of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_RouteHintZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning_types::routing::RouteHint,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_RouteHintZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning_types::routing::RouteHint> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning_types::routing::RouteHint] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning_types::routing::RouteHint>> for CVec_RouteHintZ {
	fn from(v: Vec<crate::lightning_types::routing::RouteHint>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_RouteHintZ_free(_res: CVec_RouteHintZ) { }
impl Drop for CVec_RouteHintZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_RouteHintZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RouteHintDecodeErrorZ
pub union CResult_RouteHintDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::routing::RouteHint,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RouteHintDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::routing::RouteHint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteHintDecodeErrorZ {
	/// The contents of this CResult_RouteHintDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteHintDecodeErrorZPtr,
	/// Whether this CResult_RouteHintDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteHintDecodeErrorZ in the success state.
pub extern "C" fn CResult_RouteHintDecodeErrorZ_ok(o: crate::lightning_types::routing::RouteHint) -> CResult_RouteHintDecodeErrorZ {
	CResult_RouteHintDecodeErrorZ {
		contents: CResult_RouteHintDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHintDecodeErrorZ in the error state.
pub extern "C" fn CResult_RouteHintDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RouteHintDecodeErrorZ {
	CResult_RouteHintDecodeErrorZ {
		contents: CResult_RouteHintDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteHintDecodeErrorZ_is_ok(o: &CResult_RouteHintDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteHintDecodeErrorZ.
pub extern "C" fn CResult_RouteHintDecodeErrorZ_free(_res: CResult_RouteHintDecodeErrorZ) { }
impl Drop for CResult_RouteHintDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::routing::RouteHint, crate::lightning::ln::msgs::DecodeError>> for CResult_RouteHintDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::routing::RouteHint, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteHintDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteHintDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteHintDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteHintDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::routing::RouteHint>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteHintDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHintDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteHintDecodeErrorZ_clone(orig: &CResult_RouteHintDecodeErrorZ) -> CResult_RouteHintDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RouteHintHopDecodeErrorZ
pub union CResult_RouteHintHopDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::routing::RouteHintHop,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RouteHintHopDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::routing::RouteHintHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteHintHopDecodeErrorZ {
	/// The contents of this CResult_RouteHintHopDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteHintHopDecodeErrorZPtr,
	/// Whether this CResult_RouteHintHopDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteHintHopDecodeErrorZ in the success state.
pub extern "C" fn CResult_RouteHintHopDecodeErrorZ_ok(o: crate::lightning_types::routing::RouteHintHop) -> CResult_RouteHintHopDecodeErrorZ {
	CResult_RouteHintHopDecodeErrorZ {
		contents: CResult_RouteHintHopDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHintHopDecodeErrorZ in the error state.
pub extern "C" fn CResult_RouteHintHopDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RouteHintHopDecodeErrorZ {
	CResult_RouteHintHopDecodeErrorZ {
		contents: CResult_RouteHintHopDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteHintHopDecodeErrorZ_is_ok(o: &CResult_RouteHintHopDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteHintHopDecodeErrorZ.
pub extern "C" fn CResult_RouteHintHopDecodeErrorZ_free(_res: CResult_RouteHintHopDecodeErrorZ) { }
impl Drop for CResult_RouteHintHopDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::routing::RouteHintHop, crate::lightning::ln::msgs::DecodeError>> for CResult_RouteHintHopDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::routing::RouteHintHop, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteHintHopDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteHintHopDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteHintHopDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteHintHopDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::routing::RouteHintHop>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteHintHopDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHintHopDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteHintHopDecodeErrorZ_clone(orig: &CResult_RouteHintHopDecodeErrorZ) -> CResult_RouteHintHopDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::PublicKeys of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_PublicKeyZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::PublicKey,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_PublicKeyZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::PublicKey> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::PublicKey] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::PublicKey>> for CVec_PublicKeyZ {
	fn from(v: Vec<crate::c_types::PublicKey>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_PublicKeyZ_free(_res: CVec_PublicKeyZ) { }
impl Drop for CVec_PublicKeyZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_PublicKeyZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_FixedPenaltyScorerDecodeErrorZ
pub union CResult_FixedPenaltyScorerDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::scoring::FixedPenaltyScorer,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_FixedPenaltyScorerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::scoring::FixedPenaltyScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_FixedPenaltyScorerDecodeErrorZ {
	/// The contents of this CResult_FixedPenaltyScorerDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_FixedPenaltyScorerDecodeErrorZPtr,
	/// Whether this CResult_FixedPenaltyScorerDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the success state.
pub extern "C" fn CResult_FixedPenaltyScorerDecodeErrorZ_ok(o: crate::lightning::routing::scoring::FixedPenaltyScorer) -> CResult_FixedPenaltyScorerDecodeErrorZ {
	CResult_FixedPenaltyScorerDecodeErrorZ {
		contents: CResult_FixedPenaltyScorerDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the error state.
pub extern "C" fn CResult_FixedPenaltyScorerDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_FixedPenaltyScorerDecodeErrorZ {
	CResult_FixedPenaltyScorerDecodeErrorZ {
		contents: CResult_FixedPenaltyScorerDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(o: &CResult_FixedPenaltyScorerDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_FixedPenaltyScorerDecodeErrorZ.
pub extern "C" fn CResult_FixedPenaltyScorerDecodeErrorZ_free(_res: CResult_FixedPenaltyScorerDecodeErrorZ) { }
impl Drop for CResult_FixedPenaltyScorerDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::scoring::FixedPenaltyScorer, crate::lightning::ln::msgs::DecodeError>> for CResult_FixedPenaltyScorerDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::scoring::FixedPenaltyScorer, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_FixedPenaltyScorerDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_FixedPenaltyScorerDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_FixedPenaltyScorerDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_FixedPenaltyScorerDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::scoring::FixedPenaltyScorer>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_FixedPenaltyScorerDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_FixedPenaltyScorerDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_FixedPenaltyScorerDecodeErrorZ_clone(orig: &CResult_FixedPenaltyScorerDecodeErrorZ) -> CResult_FixedPenaltyScorerDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::routing::gossip::NodeIds of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_NodeIdZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::routing::gossip::NodeId,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_NodeIdZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::routing::gossip::NodeId> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::routing::gossip::NodeId] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::routing::gossip::NodeId>> for CVec_NodeIdZ {
	fn from(v: Vec<crate::lightning::routing::gossip::NodeId>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_NodeIdZ_free(_res: CVec_NodeIdZ) { }
impl Drop for CVec_NodeIdZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_NodeIdZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_u64u64Z {
	/// The element at position 0
	pub a: u64,
	/// The element at position 1
	pub b: u64,
}
impl From<(u64, u64)> for C2Tuple_u64u64Z {
	fn from (tup: (u64, u64)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_u64u64Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (u64, u64) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_u64u64Z {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_u64u64Z_clone(orig: &C2Tuple_u64u64Z) -> C2Tuple_u64u64Z { Clone::clone(&orig) }
/// Creates a new C2Tuple_u64u64Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_u64u64Z_new(a: u64, b: u64) -> C2Tuple_u64u64Z {
	C2Tuple_u64u64Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_u64u64Z.
pub extern "C" fn C2Tuple_u64u64Z_free(_res: C2Tuple_u64u64Z) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_u64u64Z or not
pub enum COption_C2Tuple_u64u64ZZ {
	/// When we're in this state, this COption_C2Tuple_u64u64ZZ contains a crate::c_types::derived::C2Tuple_u64u64Z
	Some(crate::c_types::derived::C2Tuple_u64u64Z),
	/// When we're in this state, this COption_C2Tuple_u64u64ZZ contains nothing
	None
}
impl COption_C2Tuple_u64u64ZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_u64u64Z {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_u64u64ZZ containing a crate::c_types::derived::C2Tuple_u64u64Z
pub extern "C" fn COption_C2Tuple_u64u64ZZ_some(o: crate::c_types::derived::C2Tuple_u64u64Z) -> COption_C2Tuple_u64u64ZZ {
	COption_C2Tuple_u64u64ZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_u64u64ZZ containing nothing
pub extern "C" fn COption_C2Tuple_u64u64ZZ_none() -> COption_C2Tuple_u64u64ZZ {
	COption_C2Tuple_u64u64ZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_u64u64Z, if we are in the Some state
pub extern "C" fn COption_C2Tuple_u64u64ZZ_free(_res: COption_C2Tuple_u64u64ZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_u64u64ZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_u64u64ZZ_clone(orig: &COption_C2Tuple_u64u64ZZ) -> COption_C2Tuple_u64u64ZZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_Z {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoU16s,
	/// The element at position 1
	pub b: crate::c_types::ThirtyTwoU16s,
}
impl From<(crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s)> for C2Tuple_Z {
	fn from (tup: (crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s) {
		(self.a, self.b)
	}
}
/// Creates a new C2Tuple_Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_Z_new(a: crate::c_types::ThirtyTwoU16s, b: crate::c_types::ThirtyTwoU16s) -> C2Tuple_Z {
	C2Tuple_Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_Z.
pub extern "C" fn C2Tuple_Z_free(_res: C2Tuple_Z) { }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple__u1632_u1632Z {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoU16s,
	/// The element at position 1
	pub b: crate::c_types::ThirtyTwoU16s,
}
impl From<(crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s)> for C2Tuple__u1632_u1632Z {
	fn from (tup: (crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple__u1632_u1632Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s) {
		(self.a, self.b)
	}
}
/// Creates a new C2Tuple__u1632_u1632Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple__u1632_u1632Z_new(a: crate::c_types::ThirtyTwoU16s, b: crate::c_types::ThirtyTwoU16s) -> C2Tuple__u1632_u1632Z {
	C2Tuple__u1632_u1632Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple__u1632_u1632Z.
pub extern "C" fn C2Tuple__u1632_u1632Z_free(_res: C2Tuple__u1632_u1632Z) { }
#[repr(C)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple__u1632_u1632Z or not
pub enum COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ {
	/// When we're in this state, this COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ contains a crate::c_types::derived::C2Tuple__u1632_u1632Z
	Some(crate::c_types::derived::C2Tuple__u1632_u1632Z),
	/// When we're in this state, this COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ contains nothing
	None
}
impl COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple__u1632_u1632Z {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ containing a crate::c_types::derived::C2Tuple__u1632_u1632Z
pub extern "C" fn COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_some(o: crate::c_types::derived::C2Tuple__u1632_u1632Z) -> COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ {
	COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ containing nothing
pub extern "C" fn COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_none() -> COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ {
	COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple__u1632_u1632Z, if we are in the Some state
pub extern "C" fn COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_free(_res: COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a f64 or not
pub enum COption_f64Z {
	/// When we're in this state, this COption_f64Z contains a f64
	Some(f64),
	/// When we're in this state, this COption_f64Z contains nothing
	None
}
impl COption_f64Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> f64 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_f64Z containing a f64
pub extern "C" fn COption_f64Z_some(o: f64) -> COption_f64Z {
	COption_f64Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_f64Z containing nothing
pub extern "C" fn COption_f64Z_none() -> COption_f64Z {
	COption_f64Z::None
}
#[no_mangle]
/// Frees any resources associated with the f64, if we are in the Some state
pub extern "C" fn COption_f64Z_free(_res: COption_f64Z) { }
#[no_mangle]
/// Creates a new COption_f64Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_f64Z_clone(orig: &COption_f64Z) -> COption_f64Z { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ProbabilisticScorerDecodeErrorZ
pub union CResult_ProbabilisticScorerDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::scoring::ProbabilisticScorer,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ProbabilisticScorerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::scoring::ProbabilisticScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ProbabilisticScorerDecodeErrorZ {
	/// The contents of this CResult_ProbabilisticScorerDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ProbabilisticScorerDecodeErrorZPtr,
	/// Whether this CResult_ProbabilisticScorerDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the success state.
pub extern "C" fn CResult_ProbabilisticScorerDecodeErrorZ_ok(o: crate::lightning::routing::scoring::ProbabilisticScorer) -> CResult_ProbabilisticScorerDecodeErrorZ {
	CResult_ProbabilisticScorerDecodeErrorZ {
		contents: CResult_ProbabilisticScorerDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the error state.
pub extern "C" fn CResult_ProbabilisticScorerDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ProbabilisticScorerDecodeErrorZ {
	CResult_ProbabilisticScorerDecodeErrorZ {
		contents: CResult_ProbabilisticScorerDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ProbabilisticScorerDecodeErrorZ_is_ok(o: &CResult_ProbabilisticScorerDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ProbabilisticScorerDecodeErrorZ.
pub extern "C" fn CResult_ProbabilisticScorerDecodeErrorZ_free(_res: CResult_ProbabilisticScorerDecodeErrorZ) { }
impl Drop for CResult_ProbabilisticScorerDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::scoring::ProbabilisticScorer, crate::lightning::ln::msgs::DecodeError>> for CResult_ProbabilisticScorerDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::scoring::ProbabilisticScorer, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ProbabilisticScorerDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ProbabilisticScorerDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_BestBlockDecodeErrorZ
pub union CResult_BestBlockDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::BestBlock,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BestBlockDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::BestBlock on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BestBlockDecodeErrorZ {
	/// The contents of this CResult_BestBlockDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BestBlockDecodeErrorZPtr,
	/// Whether this CResult_BestBlockDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BestBlockDecodeErrorZ in the success state.
pub extern "C" fn CResult_BestBlockDecodeErrorZ_ok(o: crate::lightning::chain::BestBlock) -> CResult_BestBlockDecodeErrorZ {
	CResult_BestBlockDecodeErrorZ {
		contents: CResult_BestBlockDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BestBlockDecodeErrorZ in the error state.
pub extern "C" fn CResult_BestBlockDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BestBlockDecodeErrorZ {
	CResult_BestBlockDecodeErrorZ {
		contents: CResult_BestBlockDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BestBlockDecodeErrorZ_is_ok(o: &CResult_BestBlockDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BestBlockDecodeErrorZ.
pub extern "C" fn CResult_BestBlockDecodeErrorZ_free(_res: CResult_BestBlockDecodeErrorZ) { }
impl Drop for CResult_BestBlockDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::BestBlock, crate::lightning::ln::msgs::DecodeError>> for CResult_BestBlockDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::BestBlock, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BestBlockDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BestBlockDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BestBlockDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BestBlockDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::chain::BestBlock>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BestBlockDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BestBlockDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BestBlockDecodeErrorZ_clone(orig: &CResult_BestBlockDecodeErrorZ) -> CResult_BestBlockDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_usizeTransactionZ {
	/// The element at position 0
	pub a: usize,
	/// The element at position 1
	pub b: crate::c_types::Transaction,
}
impl From<(usize, crate::c_types::Transaction)> for C2Tuple_usizeTransactionZ {
	fn from (tup: (usize, crate::c_types::Transaction)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_usizeTransactionZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (usize, crate::c_types::Transaction) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_usizeTransactionZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_usizeTransactionZ_clone(orig: &C2Tuple_usizeTransactionZ) -> C2Tuple_usizeTransactionZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_usizeTransactionZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_usizeTransactionZ_new(a: usize, b: crate::c_types::Transaction) -> C2Tuple_usizeTransactionZ {
	C2Tuple_usizeTransactionZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_usizeTransactionZ.
pub extern "C" fn C2Tuple_usizeTransactionZ_free(_res: C2Tuple_usizeTransactionZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_usizeTransactionZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_usizeTransactionZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_usizeTransactionZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_usizeTransactionZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_usizeTransactionZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_usizeTransactionZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_usizeTransactionZ>> for CVec_C2Tuple_usizeTransactionZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_usizeTransactionZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_usizeTransactionZZ_free(_res: CVec_C2Tuple_usizeTransactionZZ) { }
impl Drop for CVec_C2Tuple_usizeTransactionZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_usizeTransactionZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: u32,
	/// The element at position 2
	pub c: crate::c_types::derived::COption_ThirtyTwoBytesZ,
}
impl From<(crate::c_types::ThirtyTwoBytes, u32, crate::c_types::derived::COption_ThirtyTwoBytesZ)> for C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, u32, crate::c_types::derived::COption_ThirtyTwoBytesZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, u32, crate::c_types::derived::COption_ThirtyTwoBytesZ) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ_clone(orig: &C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ) -> C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ_new(a: crate::c_types::ThirtyTwoBytes, b: u32, c: crate::c_types::derived::COption_ThirtyTwoBytesZ) -> C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ {
	C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ.
pub extern "C" fn C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ_free(_res: C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ>> for CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	fn from(v: Vec<crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ_free(_res: CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ) { }
impl Drop for CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_ChannelMonitorUpdateStatusNoneZ
pub union CResult_ChannelMonitorUpdateStatusNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::ChannelMonitorUpdateStatus,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_ChannelMonitorUpdateStatusNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::ChannelMonitorUpdateStatus on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelMonitorUpdateStatusNoneZ {
	/// The contents of this CResult_ChannelMonitorUpdateStatusNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelMonitorUpdateStatusNoneZPtr,
	/// Whether this CResult_ChannelMonitorUpdateStatusNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateStatusNoneZ in the success state.
pub extern "C" fn CResult_ChannelMonitorUpdateStatusNoneZ_ok(o: crate::lightning::chain::ChannelMonitorUpdateStatus) -> CResult_ChannelMonitorUpdateStatusNoneZ {
	CResult_ChannelMonitorUpdateStatusNoneZ {
		contents: CResult_ChannelMonitorUpdateStatusNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateStatusNoneZ in the error state.
pub extern "C" fn CResult_ChannelMonitorUpdateStatusNoneZ_err() -> CResult_ChannelMonitorUpdateStatusNoneZ {
	CResult_ChannelMonitorUpdateStatusNoneZ {
		contents: CResult_ChannelMonitorUpdateStatusNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelMonitorUpdateStatusNoneZ_is_ok(o: &CResult_ChannelMonitorUpdateStatusNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelMonitorUpdateStatusNoneZ.
pub extern "C" fn CResult_ChannelMonitorUpdateStatusNoneZ_free(_res: CResult_ChannelMonitorUpdateStatusNoneZ) { }
impl Drop for CResult_ChannelMonitorUpdateStatusNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::ChannelMonitorUpdateStatus, ()>> for CResult_ChannelMonitorUpdateStatusNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::ChannelMonitorUpdateStatus, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelMonitorUpdateStatusNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_ChannelMonitorUpdateStatusNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelMonitorUpdateStatusNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelMonitorUpdateStatusNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::chain::ChannelMonitorUpdateStatus>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelMonitorUpdateStatusNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateStatusNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelMonitorUpdateStatusNoneZ_clone(orig: &CResult_ChannelMonitorUpdateStatusNoneZ) -> CResult_ChannelMonitorUpdateStatusNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::chain::channelmonitor::MonitorEvents of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_MonitorEventZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::chain::channelmonitor::MonitorEvent,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_MonitorEventZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::chain::channelmonitor::MonitorEvent> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::chain::channelmonitor::MonitorEvent] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::chain::channelmonitor::MonitorEvent>> for CVec_MonitorEventZ {
	fn from(v: Vec<crate::lightning::chain::channelmonitor::MonitorEvent>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_MonitorEventZ_free(_res: CVec_MonitorEventZ) { }
impl Drop for CVec_MonitorEventZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_MonitorEventZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 4 elements. See the individual fields for the types contained.
pub struct C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ {
	/// The element at position 0
	pub a: crate::lightning::chain::transaction::OutPoint,
	/// The element at position 1
	pub b: crate::lightning::ln::types::ChannelId,
	/// The element at position 2
	pub c: crate::c_types::derived::CVec_MonitorEventZ,
	/// The element at position 3
	pub d: crate::c_types::PublicKey,
}
impl From<(crate::lightning::chain::transaction::OutPoint, crate::lightning::ln::types::ChannelId, crate::c_types::derived::CVec_MonitorEventZ, crate::c_types::PublicKey)> for C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ {
	fn from (tup: (crate::lightning::chain::transaction::OutPoint, crate::lightning::ln::types::ChannelId, crate::c_types::derived::CVec_MonitorEventZ, crate::c_types::PublicKey)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
			d: tup.3,
		}
	}
}
impl C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::chain::transaction::OutPoint, crate::lightning::ln::types::ChannelId, crate::c_types::derived::CVec_MonitorEventZ, crate::c_types::PublicKey) {
		(self.a, self.b, self.c, self.d)
	}
}
impl Clone for C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
			d: Clone::clone(&self.d),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ_clone(orig: &C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ) -> C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ { Clone::clone(&orig) }
/// Creates a new C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ from the contained elements.
#[no_mangle]
pub extern "C" fn C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ_new(a: crate::lightning::chain::transaction::OutPoint, b: crate::lightning::ln::types::ChannelId, c: crate::c_types::derived::CVec_MonitorEventZ, d: crate::c_types::PublicKey) -> C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ {
	C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ { a, b, c, d, }
}

#[no_mangle]
/// Frees any resources used by the C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ.
pub extern "C" fn C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ_free(_res: C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ>> for CVec_C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZZ {
	fn from(v: Vec<crate::c_types::derived::C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZZ_free(_res: CVec_C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZZ) { }
impl Drop for CVec_C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_OfferIdDecodeErrorZ
pub union CResult_OfferIdDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::offer::OfferId,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OfferIdDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::offer::OfferId on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OfferIdDecodeErrorZ {
	/// The contents of this CResult_OfferIdDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OfferIdDecodeErrorZPtr,
	/// Whether this CResult_OfferIdDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OfferIdDecodeErrorZ in the success state.
pub extern "C" fn CResult_OfferIdDecodeErrorZ_ok(o: crate::lightning::offers::offer::OfferId) -> CResult_OfferIdDecodeErrorZ {
	CResult_OfferIdDecodeErrorZ {
		contents: CResult_OfferIdDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OfferIdDecodeErrorZ in the error state.
pub extern "C" fn CResult_OfferIdDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OfferIdDecodeErrorZ {
	CResult_OfferIdDecodeErrorZ {
		contents: CResult_OfferIdDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OfferIdDecodeErrorZ_is_ok(o: &CResult_OfferIdDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OfferIdDecodeErrorZ.
pub extern "C" fn CResult_OfferIdDecodeErrorZ_free(_res: CResult_OfferIdDecodeErrorZ) { }
impl Drop for CResult_OfferIdDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::offer::OfferId, crate::lightning::ln::msgs::DecodeError>> for CResult_OfferIdDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::offer::OfferId, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OfferIdDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OfferIdDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OfferIdDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OfferIdDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::offer::OfferId>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OfferIdDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OfferIdDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OfferIdDecodeErrorZ_clone(orig: &CResult_OfferIdDecodeErrorZ) -> CResult_OfferIdDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneBolt12SemanticErrorZ
pub union CResult_NoneBolt12SemanticErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_NoneBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneBolt12SemanticErrorZ {
	/// The contents of this CResult_NoneBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneBolt12SemanticErrorZPtr,
	/// Whether this CResult_NoneBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_NoneBolt12SemanticErrorZ_ok() -> CResult_NoneBolt12SemanticErrorZ {
	CResult_NoneBolt12SemanticErrorZ {
		contents: CResult_NoneBolt12SemanticErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_NoneBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_NoneBolt12SemanticErrorZ {
	CResult_NoneBolt12SemanticErrorZ {
		contents: CResult_NoneBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneBolt12SemanticErrorZ_is_ok(o: &CResult_NoneBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneBolt12SemanticErrorZ.
pub extern "C" fn CResult_NoneBolt12SemanticErrorZ_free(_res: CResult_NoneBolt12SemanticErrorZ) { }
impl Drop for CResult_NoneBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_NoneBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneBolt12SemanticErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneBolt12SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneBolt12SemanticErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneBolt12SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneBolt12SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneBolt12SemanticErrorZ_clone(orig: &CResult_NoneBolt12SemanticErrorZ) -> CResult_NoneBolt12SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OfferBolt12SemanticErrorZ
pub union CResult_OfferBolt12SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::offer::Offer,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_OfferBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::offer::Offer on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OfferBolt12SemanticErrorZ {
	/// The contents of this CResult_OfferBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OfferBolt12SemanticErrorZPtr,
	/// Whether this CResult_OfferBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OfferBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_OfferBolt12SemanticErrorZ_ok(o: crate::lightning::offers::offer::Offer) -> CResult_OfferBolt12SemanticErrorZ {
	CResult_OfferBolt12SemanticErrorZ {
		contents: CResult_OfferBolt12SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OfferBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_OfferBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_OfferBolt12SemanticErrorZ {
	CResult_OfferBolt12SemanticErrorZ {
		contents: CResult_OfferBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OfferBolt12SemanticErrorZ_is_ok(o: &CResult_OfferBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OfferBolt12SemanticErrorZ.
pub extern "C" fn CResult_OfferBolt12SemanticErrorZ_free(_res: CResult_OfferBolt12SemanticErrorZ) { }
impl Drop for CResult_OfferBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::offer::Offer, crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_OfferBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::offer::Offer, crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OfferBolt12SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OfferBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OfferBolt12SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OfferBolt12SemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::offer::Offer>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OfferBolt12SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OfferBolt12SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OfferBolt12SemanticErrorZ_clone(orig: &CResult_OfferBolt12SemanticErrorZ) -> CResult_OfferBolt12SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ
pub union CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice_request::InvoiceRequestWithDerivedPayerSigningPubkeyBuilder,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice_request::InvoiceRequestWithDerivedPayerSigningPubkeyBuilder on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ {
	/// The contents of this CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZPtr,
	/// Whether this CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ_ok(o: crate::lightning::offers::invoice_request::InvoiceRequestWithDerivedPayerSigningPubkeyBuilder) -> CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ {
	CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ {
		contents: CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ {
	CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ {
		contents: CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ_is_ok(o: &CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ.
pub extern "C" fn CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ_free(_res: CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ) { }
impl Drop for CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::InvoiceRequestWithDerivedPayerSigningPubkeyBuilder, crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::InvoiceRequestWithDerivedPayerSigningPubkeyBuilder, crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InvoiceRequestWithDerivedPayerSigningPubkeyBuilderBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_OfferDecodeErrorZ
pub union CResult_OfferDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::offer::Offer,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OfferDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::offer::Offer on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OfferDecodeErrorZ {
	/// The contents of this CResult_OfferDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OfferDecodeErrorZPtr,
	/// Whether this CResult_OfferDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OfferDecodeErrorZ in the success state.
pub extern "C" fn CResult_OfferDecodeErrorZ_ok(o: crate::lightning::offers::offer::Offer) -> CResult_OfferDecodeErrorZ {
	CResult_OfferDecodeErrorZ {
		contents: CResult_OfferDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OfferDecodeErrorZ in the error state.
pub extern "C" fn CResult_OfferDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OfferDecodeErrorZ {
	CResult_OfferDecodeErrorZ {
		contents: CResult_OfferDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OfferDecodeErrorZ_is_ok(o: &CResult_OfferDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OfferDecodeErrorZ.
pub extern "C" fn CResult_OfferDecodeErrorZ_free(_res: CResult_OfferDecodeErrorZ) { }
impl Drop for CResult_OfferDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::offer::Offer, crate::lightning::ln::msgs::DecodeError>> for CResult_OfferDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::offer::Offer, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OfferDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OfferDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OfferDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OfferDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::offer::Offer>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OfferDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OfferDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OfferDecodeErrorZ_clone(orig: &CResult_OfferDecodeErrorZ) -> CResult_OfferDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OfferBolt12ParseErrorZ
pub union CResult_OfferBolt12ParseErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::offer::Offer,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12ParseError,
}
#[repr(C)]
/// A CResult_OfferBolt12ParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::offer::Offer on success and a crate::lightning::offers::parse::Bolt12ParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OfferBolt12ParseErrorZ {
	/// The contents of this CResult_OfferBolt12ParseErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OfferBolt12ParseErrorZPtr,
	/// Whether this CResult_OfferBolt12ParseErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OfferBolt12ParseErrorZ in the success state.
pub extern "C" fn CResult_OfferBolt12ParseErrorZ_ok(o: crate::lightning::offers::offer::Offer) -> CResult_OfferBolt12ParseErrorZ {
	CResult_OfferBolt12ParseErrorZ {
		contents: CResult_OfferBolt12ParseErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OfferBolt12ParseErrorZ in the error state.
pub extern "C" fn CResult_OfferBolt12ParseErrorZ_err(e: crate::lightning::offers::parse::Bolt12ParseError) -> CResult_OfferBolt12ParseErrorZ {
	CResult_OfferBolt12ParseErrorZ {
		contents: CResult_OfferBolt12ParseErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OfferBolt12ParseErrorZ_is_ok(o: &CResult_OfferBolt12ParseErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OfferBolt12ParseErrorZ.
pub extern "C" fn CResult_OfferBolt12ParseErrorZ_free(_res: CResult_OfferBolt12ParseErrorZ) { }
impl Drop for CResult_OfferBolt12ParseErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::offer::Offer, crate::lightning::offers::parse::Bolt12ParseError>> for CResult_OfferBolt12ParseErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::offer::Offer, crate::lightning::offers::parse::Bolt12ParseError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OfferBolt12ParseErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OfferBolt12ParseErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OfferBolt12ParseErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OfferBolt12ParseErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::offer::Offer>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OfferBolt12ParseErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12ParseError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OfferBolt12ParseErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OfferBolt12ParseErrorZ_clone(orig: &CResult_OfferBolt12ParseErrorZ) -> CResult_OfferBolt12ParseErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NodeIdDecodeErrorZ
pub union CResult_NodeIdDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::NodeId,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeIdDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeId on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeIdDecodeErrorZ {
	/// The contents of this CResult_NodeIdDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeIdDecodeErrorZPtr,
	/// Whether this CResult_NodeIdDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeIdDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeIdDecodeErrorZ_ok(o: crate::lightning::routing::gossip::NodeId) -> CResult_NodeIdDecodeErrorZ {
	CResult_NodeIdDecodeErrorZ {
		contents: CResult_NodeIdDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeIdDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeIdDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeIdDecodeErrorZ {
	CResult_NodeIdDecodeErrorZ {
		contents: CResult_NodeIdDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeIdDecodeErrorZ_is_ok(o: &CResult_NodeIdDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeIdDecodeErrorZ.
pub extern "C" fn CResult_NodeIdDecodeErrorZ_free(_res: CResult_NodeIdDecodeErrorZ) { }
impl Drop for CResult_NodeIdDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeId, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeIdDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeId, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeIdDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeIdDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeIdDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeIdDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::NodeId>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeIdDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeIdDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeIdDecodeErrorZ_clone(orig: &CResult_NodeIdDecodeErrorZ) -> CResult_NodeIdDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PublicKeySecp256k1ErrorZ
pub union CResult_PublicKeySecp256k1ErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::PublicKey,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::Secp256k1Error,
}
#[repr(C)]
/// A CResult_PublicKeySecp256k1ErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::PublicKey on success and a crate::c_types::Secp256k1Error on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PublicKeySecp256k1ErrorZ {
	/// The contents of this CResult_PublicKeySecp256k1ErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PublicKeySecp256k1ErrorZPtr,
	/// Whether this CResult_PublicKeySecp256k1ErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PublicKeySecp256k1ErrorZ in the success state.
pub extern "C" fn CResult_PublicKeySecp256k1ErrorZ_ok(o: crate::c_types::PublicKey) -> CResult_PublicKeySecp256k1ErrorZ {
	CResult_PublicKeySecp256k1ErrorZ {
		contents: CResult_PublicKeySecp256k1ErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PublicKeySecp256k1ErrorZ in the error state.
pub extern "C" fn CResult_PublicKeySecp256k1ErrorZ_err(e: crate::c_types::Secp256k1Error) -> CResult_PublicKeySecp256k1ErrorZ {
	CResult_PublicKeySecp256k1ErrorZ {
		contents: CResult_PublicKeySecp256k1ErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PublicKeySecp256k1ErrorZ_is_ok(o: &CResult_PublicKeySecp256k1ErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PublicKeySecp256k1ErrorZ.
pub extern "C" fn CResult_PublicKeySecp256k1ErrorZ_free(_res: CResult_PublicKeySecp256k1ErrorZ) { }
impl Drop for CResult_PublicKeySecp256k1ErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::PublicKey, crate::c_types::Secp256k1Error>> for CResult_PublicKeySecp256k1ErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::PublicKey, crate::c_types::Secp256k1Error>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PublicKeySecp256k1ErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PublicKeySecp256k1ErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PublicKeySecp256k1ErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PublicKeySecp256k1ErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::PublicKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PublicKeySecp256k1ErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::Secp256k1Error>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PublicKeySecp256k1ErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PublicKeySecp256k1ErrorZ_clone(orig: &CResult_PublicKeySecp256k1ErrorZ) -> CResult_PublicKeySecp256k1ErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::routing::gossip::NetworkUpdate or not
pub enum COption_NetworkUpdateZ {
	/// When we're in this state, this COption_NetworkUpdateZ contains a crate::lightning::routing::gossip::NetworkUpdate
	Some(crate::lightning::routing::gossip::NetworkUpdate),
	/// When we're in this state, this COption_NetworkUpdateZ contains nothing
	None
}
impl COption_NetworkUpdateZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::routing::gossip::NetworkUpdate {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_NetworkUpdateZ containing a crate::lightning::routing::gossip::NetworkUpdate
pub extern "C" fn COption_NetworkUpdateZ_some(o: crate::lightning::routing::gossip::NetworkUpdate) -> COption_NetworkUpdateZ {
	COption_NetworkUpdateZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_NetworkUpdateZ containing nothing
pub extern "C" fn COption_NetworkUpdateZ_none() -> COption_NetworkUpdateZ {
	COption_NetworkUpdateZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::routing::gossip::NetworkUpdate, if we are in the Some state
pub extern "C" fn COption_NetworkUpdateZ_free(_res: COption_NetworkUpdateZ) { }
#[no_mangle]
/// Creates a new COption_NetworkUpdateZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_NetworkUpdateZ_clone(orig: &COption_NetworkUpdateZ) -> COption_NetworkUpdateZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_NetworkUpdateZDecodeErrorZ
pub union CResult_COption_NetworkUpdateZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_NetworkUpdateZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_NetworkUpdateZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_NetworkUpdateZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_NetworkUpdateZDecodeErrorZ {
	/// The contents of this CResult_COption_NetworkUpdateZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_NetworkUpdateZDecodeErrorZPtr,
	/// Whether this CResult_COption_NetworkUpdateZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_NetworkUpdateZDecodeErrorZ_ok(o: crate::c_types::derived::COption_NetworkUpdateZ) -> CResult_COption_NetworkUpdateZDecodeErrorZ {
	CResult_COption_NetworkUpdateZDecodeErrorZ {
		contents: CResult_COption_NetworkUpdateZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_NetworkUpdateZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_NetworkUpdateZDecodeErrorZ {
	CResult_COption_NetworkUpdateZDecodeErrorZ {
		contents: CResult_COption_NetworkUpdateZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(o: &CResult_COption_NetworkUpdateZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_NetworkUpdateZDecodeErrorZ.
pub extern "C" fn CResult_COption_NetworkUpdateZDecodeErrorZ_free(_res: CResult_COption_NetworkUpdateZDecodeErrorZ) { }
impl Drop for CResult_COption_NetworkUpdateZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_NetworkUpdateZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_NetworkUpdateZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_NetworkUpdateZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_NetworkUpdateZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_NetworkUpdateZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_NetworkUpdateZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_NetworkUpdateZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_NetworkUpdateZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_NetworkUpdateZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_NetworkUpdateZDecodeErrorZ_clone(orig: &CResult_COption_NetworkUpdateZDecodeErrorZ) -> CResult_COption_NetworkUpdateZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// An enum which can either contain a crate::lightning::routing::utxo::UtxoLookup or not
pub enum COption_UtxoLookupZ {
	/// When we're in this state, this COption_UtxoLookupZ contains a crate::lightning::routing::utxo::UtxoLookup
	Some(crate::lightning::routing::utxo::UtxoLookup),
	/// When we're in this state, this COption_UtxoLookupZ contains nothing
	None
}
impl COption_UtxoLookupZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::routing::utxo::UtxoLookup {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_UtxoLookupZ containing a crate::lightning::routing::utxo::UtxoLookup
pub extern "C" fn COption_UtxoLookupZ_some(o: crate::lightning::routing::utxo::UtxoLookup) -> COption_UtxoLookupZ {
	COption_UtxoLookupZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_UtxoLookupZ containing nothing
pub extern "C" fn COption_UtxoLookupZ_none() -> COption_UtxoLookupZ {
	COption_UtxoLookupZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::routing::utxo::UtxoLookup, if we are in the Some state
pub extern "C" fn COption_UtxoLookupZ_free(_res: COption_UtxoLookupZ) { }
#[repr(C)]
/// The contents of CResult_NoneLightningErrorZ
pub union CResult_NoneLightningErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::LightningError,
}
#[repr(C)]
/// A CResult_NoneLightningErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::msgs::LightningError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneLightningErrorZ {
	/// The contents of this CResult_NoneLightningErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneLightningErrorZPtr,
	/// Whether this CResult_NoneLightningErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneLightningErrorZ in the success state.
pub extern "C" fn CResult_NoneLightningErrorZ_ok() -> CResult_NoneLightningErrorZ {
	CResult_NoneLightningErrorZ {
		contents: CResult_NoneLightningErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneLightningErrorZ in the error state.
pub extern "C" fn CResult_NoneLightningErrorZ_err(e: crate::lightning::ln::msgs::LightningError) -> CResult_NoneLightningErrorZ {
	CResult_NoneLightningErrorZ {
		contents: CResult_NoneLightningErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneLightningErrorZ_is_ok(o: &CResult_NoneLightningErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneLightningErrorZ.
pub extern "C" fn CResult_NoneLightningErrorZ_free(_res: CResult_NoneLightningErrorZ) { }
impl Drop for CResult_NoneLightningErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::ln::msgs::LightningError>> for CResult_NoneLightningErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::ln::msgs::LightningError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneLightningErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneLightningErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneLightningErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneLightningErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneLightningErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::LightningError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneLightningErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneLightningErrorZ_clone(orig: &CResult_NoneLightningErrorZ) -> CResult_NoneLightningErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_boolLightningErrorZ
pub union CResult_boolLightningErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut bool,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::LightningError,
}
#[repr(C)]
/// A CResult_boolLightningErrorZ represents the result of a fallible operation,
/// containing a bool on success and a crate::lightning::ln::msgs::LightningError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_boolLightningErrorZ {
	/// The contents of this CResult_boolLightningErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_boolLightningErrorZPtr,
	/// Whether this CResult_boolLightningErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_boolLightningErrorZ in the success state.
pub extern "C" fn CResult_boolLightningErrorZ_ok(o: bool) -> CResult_boolLightningErrorZ {
	CResult_boolLightningErrorZ {
		contents: CResult_boolLightningErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_boolLightningErrorZ in the error state.
pub extern "C" fn CResult_boolLightningErrorZ_err(e: crate::lightning::ln::msgs::LightningError) -> CResult_boolLightningErrorZ {
	CResult_boolLightningErrorZ {
		contents: CResult_boolLightningErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_boolLightningErrorZ_is_ok(o: &CResult_boolLightningErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_boolLightningErrorZ.
pub extern "C" fn CResult_boolLightningErrorZ_free(_res: CResult_boolLightningErrorZ) { }
impl Drop for CResult_boolLightningErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<bool, crate::lightning::ln::msgs::LightningError>> for CResult_boolLightningErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<bool, crate::lightning::ln::msgs::LightningError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_boolLightningErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_boolLightningErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_boolLightningErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_boolLightningErrorZPtr {
				result: Box::into_raw(Box::new(<bool>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_boolLightningErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::LightningError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_boolLightningErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_boolLightningErrorZ_clone(orig: &CResult_boolLightningErrorZ) -> CResult_boolLightningErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
	/// The element at position 0
	pub a: crate::lightning::ln::msgs::ChannelAnnouncement,
	/// The element at position 1
	pub b: crate::lightning::ln::msgs::ChannelUpdate,
	/// The element at position 2
	pub c: crate::lightning::ln::msgs::ChannelUpdate,
}
impl From<(crate::lightning::ln::msgs::ChannelAnnouncement, crate::lightning::ln::msgs::ChannelUpdate, crate::lightning::ln::msgs::ChannelUpdate)> for C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
	fn from (tup: (crate::lightning::ln::msgs::ChannelAnnouncement, crate::lightning::ln::msgs::ChannelUpdate, crate::lightning::ln::msgs::ChannelUpdate)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::ln::msgs::ChannelAnnouncement, crate::lightning::ln::msgs::ChannelUpdate, crate::lightning::ln::msgs::ChannelUpdate) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(orig: &C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ) -> C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(a: crate::lightning::ln::msgs::ChannelAnnouncement, b: crate::lightning::ln::msgs::ChannelUpdate, c: crate::lightning::ln::msgs::ChannelUpdate) -> C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
	C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.
pub extern "C" fn C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(_res: C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ or not
pub enum COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	/// When we're in this state, this COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ contains a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
	Some(crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ),
	/// When we're in this state, this COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ contains nothing
	None
}
impl COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ containing a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
pub extern "C" fn COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_some(o: crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ) -> COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ containing nothing
pub extern "C" fn COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_none() -> COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ, if we are in the Some state
pub extern "C" fn COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(_res: COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ) { }
#[no_mangle]
/// Creates a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone(orig: &COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ) -> COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::events::MessageSendEvents of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_MessageSendEventZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::events::MessageSendEvent,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_MessageSendEventZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::events::MessageSendEvent> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::events::MessageSendEvent] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::events::MessageSendEvent>> for CVec_MessageSendEventZ {
	fn from(v: Vec<crate::lightning::events::MessageSendEvent>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_MessageSendEventZ_free(_res: CVec_MessageSendEventZ) { }
impl Drop for CVec_MessageSendEventZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_MessageSendEventZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_ChannelUpdateInfoDecodeErrorZ
pub union CResult_ChannelUpdateInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::ChannelUpdateInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelUpdateInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::ChannelUpdateInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelUpdateInfoDecodeErrorZ {
	/// The contents of this CResult_ChannelUpdateInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelUpdateInfoDecodeErrorZPtr,
	/// Whether this CResult_ChannelUpdateInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelUpdateInfoDecodeErrorZ_ok(o: crate::lightning::routing::gossip::ChannelUpdateInfo) -> CResult_ChannelUpdateInfoDecodeErrorZ {
	CResult_ChannelUpdateInfoDecodeErrorZ {
		contents: CResult_ChannelUpdateInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelUpdateInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelUpdateInfoDecodeErrorZ {
	CResult_ChannelUpdateInfoDecodeErrorZ {
		contents: CResult_ChannelUpdateInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(o: &CResult_ChannelUpdateInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelUpdateInfoDecodeErrorZ.
pub extern "C" fn CResult_ChannelUpdateInfoDecodeErrorZ_free(_res: CResult_ChannelUpdateInfoDecodeErrorZ) { }
impl Drop for CResult_ChannelUpdateInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::ChannelUpdateInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelUpdateInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::ChannelUpdateInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelUpdateInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelUpdateInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelUpdateInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelUpdateInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::ChannelUpdateInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelUpdateInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelUpdateInfoDecodeErrorZ_clone(orig: &CResult_ChannelUpdateInfoDecodeErrorZ) -> CResult_ChannelUpdateInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelInfoDecodeErrorZ
pub union CResult_ChannelInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::ChannelInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::ChannelInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelInfoDecodeErrorZ {
	/// The contents of this CResult_ChannelInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelInfoDecodeErrorZPtr,
	/// Whether this CResult_ChannelInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelInfoDecodeErrorZ_ok(o: crate::lightning::routing::gossip::ChannelInfo) -> CResult_ChannelInfoDecodeErrorZ {
	CResult_ChannelInfoDecodeErrorZ {
		contents: CResult_ChannelInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelInfoDecodeErrorZ {
	CResult_ChannelInfoDecodeErrorZ {
		contents: CResult_ChannelInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelInfoDecodeErrorZ_is_ok(o: &CResult_ChannelInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelInfoDecodeErrorZ.
pub extern "C" fn CResult_ChannelInfoDecodeErrorZ_free(_res: CResult_ChannelInfoDecodeErrorZ) { }
impl Drop for CResult_ChannelInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::ChannelInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::ChannelInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::ChannelInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelInfoDecodeErrorZ_clone(orig: &CResult_ChannelInfoDecodeErrorZ) -> CResult_ChannelInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RoutingFeesDecodeErrorZ
pub union CResult_RoutingFeesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::routing::RoutingFees,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RoutingFeesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::routing::RoutingFees on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RoutingFeesDecodeErrorZ {
	/// The contents of this CResult_RoutingFeesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RoutingFeesDecodeErrorZPtr,
	/// Whether this CResult_RoutingFeesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RoutingFeesDecodeErrorZ in the success state.
pub extern "C" fn CResult_RoutingFeesDecodeErrorZ_ok(o: crate::lightning_types::routing::RoutingFees) -> CResult_RoutingFeesDecodeErrorZ {
	CResult_RoutingFeesDecodeErrorZ {
		contents: CResult_RoutingFeesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RoutingFeesDecodeErrorZ in the error state.
pub extern "C" fn CResult_RoutingFeesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RoutingFeesDecodeErrorZ {
	CResult_RoutingFeesDecodeErrorZ {
		contents: CResult_RoutingFeesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RoutingFeesDecodeErrorZ_is_ok(o: &CResult_RoutingFeesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RoutingFeesDecodeErrorZ.
pub extern "C" fn CResult_RoutingFeesDecodeErrorZ_free(_res: CResult_RoutingFeesDecodeErrorZ) { }
impl Drop for CResult_RoutingFeesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::routing::RoutingFees, crate::lightning::ln::msgs::DecodeError>> for CResult_RoutingFeesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::routing::RoutingFees, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RoutingFeesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RoutingFeesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RoutingFeesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RoutingFeesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::routing::RoutingFees>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RoutingFeesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RoutingFeesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RoutingFeesDecodeErrorZ_clone(orig: &CResult_RoutingFeesDecodeErrorZ) -> CResult_RoutingFeesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::msgs::SocketAddresss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_SocketAddressZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::msgs::SocketAddress,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_SocketAddressZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::msgs::SocketAddress> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::msgs::SocketAddress] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::msgs::SocketAddress>> for CVec_SocketAddressZ {
	fn from(v: Vec<crate::lightning::ln::msgs::SocketAddress>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_SocketAddressZ_free(_res: CVec_SocketAddressZ) { }
impl Drop for CVec_SocketAddressZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_SocketAddressZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_NodeAnnouncementInfoDecodeErrorZ
pub union CResult_NodeAnnouncementInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::NodeAnnouncementInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeAnnouncementInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeAnnouncementInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeAnnouncementInfoDecodeErrorZ {
	/// The contents of this CResult_NodeAnnouncementInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeAnnouncementInfoDecodeErrorZPtr,
	/// Whether this CResult_NodeAnnouncementInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeAnnouncementInfoDecodeErrorZ_ok(o: crate::lightning::routing::gossip::NodeAnnouncementInfo) -> CResult_NodeAnnouncementInfoDecodeErrorZ {
	CResult_NodeAnnouncementInfoDecodeErrorZ {
		contents: CResult_NodeAnnouncementInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeAnnouncementInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeAnnouncementInfoDecodeErrorZ {
	CResult_NodeAnnouncementInfoDecodeErrorZ {
		contents: CResult_NodeAnnouncementInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(o: &CResult_NodeAnnouncementInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeAnnouncementInfoDecodeErrorZ.
pub extern "C" fn CResult_NodeAnnouncementInfoDecodeErrorZ_free(_res: CResult_NodeAnnouncementInfoDecodeErrorZ) { }
impl Drop for CResult_NodeAnnouncementInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeAnnouncementInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeAnnouncementInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeAnnouncementInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeAnnouncementInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeAnnouncementInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeAnnouncementInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeAnnouncementInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::NodeAnnouncementInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeAnnouncementInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeAnnouncementInfoDecodeErrorZ_clone(orig: &CResult_NodeAnnouncementInfoDecodeErrorZ) -> CResult_NodeAnnouncementInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NodeAliasDecodeErrorZ
pub union CResult_NodeAliasDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::NodeAlias,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeAliasDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeAlias on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeAliasDecodeErrorZ {
	/// The contents of this CResult_NodeAliasDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeAliasDecodeErrorZPtr,
	/// Whether this CResult_NodeAliasDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeAliasDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeAliasDecodeErrorZ_ok(o: crate::lightning::routing::gossip::NodeAlias) -> CResult_NodeAliasDecodeErrorZ {
	CResult_NodeAliasDecodeErrorZ {
		contents: CResult_NodeAliasDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAliasDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeAliasDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeAliasDecodeErrorZ {
	CResult_NodeAliasDecodeErrorZ {
		contents: CResult_NodeAliasDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeAliasDecodeErrorZ_is_ok(o: &CResult_NodeAliasDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeAliasDecodeErrorZ.
pub extern "C" fn CResult_NodeAliasDecodeErrorZ_free(_res: CResult_NodeAliasDecodeErrorZ) { }
impl Drop for CResult_NodeAliasDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeAlias, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeAliasDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeAlias, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeAliasDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeAliasDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeAliasDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeAliasDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::NodeAlias>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeAliasDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAliasDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeAliasDecodeErrorZ_clone(orig: &CResult_NodeAliasDecodeErrorZ) -> CResult_NodeAliasDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::routing::gossip::NodeAnnouncementInfo or not
pub enum COption_NodeAnnouncementInfoZ {
	/// When we're in this state, this COption_NodeAnnouncementInfoZ contains a crate::lightning::routing::gossip::NodeAnnouncementInfo
	Some(crate::lightning::routing::gossip::NodeAnnouncementInfo),
	/// When we're in this state, this COption_NodeAnnouncementInfoZ contains nothing
	None
}
impl COption_NodeAnnouncementInfoZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::routing::gossip::NodeAnnouncementInfo {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_NodeAnnouncementInfoZ containing a crate::lightning::routing::gossip::NodeAnnouncementInfo
pub extern "C" fn COption_NodeAnnouncementInfoZ_some(o: crate::lightning::routing::gossip::NodeAnnouncementInfo) -> COption_NodeAnnouncementInfoZ {
	COption_NodeAnnouncementInfoZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_NodeAnnouncementInfoZ containing nothing
pub extern "C" fn COption_NodeAnnouncementInfoZ_none() -> COption_NodeAnnouncementInfoZ {
	COption_NodeAnnouncementInfoZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::routing::gossip::NodeAnnouncementInfo, if we are in the Some state
pub extern "C" fn COption_NodeAnnouncementInfoZ_free(_res: COption_NodeAnnouncementInfoZ) { }
#[no_mangle]
/// Creates a new COption_NodeAnnouncementInfoZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_NodeAnnouncementInfoZ_clone(orig: &COption_NodeAnnouncementInfoZ) -> COption_NodeAnnouncementInfoZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NodeInfoDecodeErrorZ
pub union CResult_NodeInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::NodeInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeInfoDecodeErrorZ {
	/// The contents of this CResult_NodeInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeInfoDecodeErrorZPtr,
	/// Whether this CResult_NodeInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeInfoDecodeErrorZ_ok(o: crate::lightning::routing::gossip::NodeInfo) -> CResult_NodeInfoDecodeErrorZ {
	CResult_NodeInfoDecodeErrorZ {
		contents: CResult_NodeInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeInfoDecodeErrorZ {
	CResult_NodeInfoDecodeErrorZ {
		contents: CResult_NodeInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeInfoDecodeErrorZ_is_ok(o: &CResult_NodeInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeInfoDecodeErrorZ.
pub extern "C" fn CResult_NodeInfoDecodeErrorZ_free(_res: CResult_NodeInfoDecodeErrorZ) { }
impl Drop for CResult_NodeInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::NodeInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeInfoDecodeErrorZ_clone(orig: &CResult_NodeInfoDecodeErrorZ) -> CResult_NodeInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NetworkGraphDecodeErrorZ
pub union CResult_NetworkGraphDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::NetworkGraph,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NetworkGraphDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NetworkGraph on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NetworkGraphDecodeErrorZ {
	/// The contents of this CResult_NetworkGraphDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NetworkGraphDecodeErrorZPtr,
	/// Whether this CResult_NetworkGraphDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NetworkGraphDecodeErrorZ in the success state.
pub extern "C" fn CResult_NetworkGraphDecodeErrorZ_ok(o: crate::lightning::routing::gossip::NetworkGraph) -> CResult_NetworkGraphDecodeErrorZ {
	CResult_NetworkGraphDecodeErrorZ {
		contents: CResult_NetworkGraphDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NetworkGraphDecodeErrorZ in the error state.
pub extern "C" fn CResult_NetworkGraphDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NetworkGraphDecodeErrorZ {
	CResult_NetworkGraphDecodeErrorZ {
		contents: CResult_NetworkGraphDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NetworkGraphDecodeErrorZ_is_ok(o: &CResult_NetworkGraphDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NetworkGraphDecodeErrorZ.
pub extern "C" fn CResult_NetworkGraphDecodeErrorZ_free(_res: CResult_NetworkGraphDecodeErrorZ) { }
impl Drop for CResult_NetworkGraphDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::NetworkGraph, crate::lightning::ln::msgs::DecodeError>> for CResult_NetworkGraphDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::NetworkGraph, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NetworkGraphDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NetworkGraphDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::CVec_SocketAddressZ or not
pub enum COption_CVec_SocketAddressZZ {
	/// When we're in this state, this COption_CVec_SocketAddressZZ contains a crate::c_types::derived::CVec_SocketAddressZ
	Some(crate::c_types::derived::CVec_SocketAddressZ),
	/// When we're in this state, this COption_CVec_SocketAddressZZ contains nothing
	None
}
impl COption_CVec_SocketAddressZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::CVec_SocketAddressZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_CVec_SocketAddressZZ containing a crate::c_types::derived::CVec_SocketAddressZ
pub extern "C" fn COption_CVec_SocketAddressZZ_some(o: crate::c_types::derived::CVec_SocketAddressZ) -> COption_CVec_SocketAddressZZ {
	COption_CVec_SocketAddressZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_CVec_SocketAddressZZ containing nothing
pub extern "C" fn COption_CVec_SocketAddressZZ_none() -> COption_CVec_SocketAddressZZ {
	COption_CVec_SocketAddressZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::CVec_SocketAddressZ, if we are in the Some state
pub extern "C" fn COption_CVec_SocketAddressZZ_free(_res: COption_CVec_SocketAddressZZ) { }
#[no_mangle]
/// Creates a new COption_CVec_SocketAddressZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_CVec_SocketAddressZZ_clone(orig: &COption_CVec_SocketAddressZZ) -> COption_CVec_SocketAddressZZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_u64ShortChannelIdErrorZ
pub union CResult_u64ShortChannelIdErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut u64,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::util::scid_utils::ShortChannelIdError,
}
#[repr(C)]
/// A CResult_u64ShortChannelIdErrorZ represents the result of a fallible operation,
/// containing a u64 on success and a crate::lightning::util::scid_utils::ShortChannelIdError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_u64ShortChannelIdErrorZ {
	/// The contents of this CResult_u64ShortChannelIdErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_u64ShortChannelIdErrorZPtr,
	/// Whether this CResult_u64ShortChannelIdErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_u64ShortChannelIdErrorZ in the success state.
pub extern "C" fn CResult_u64ShortChannelIdErrorZ_ok(o: u64) -> CResult_u64ShortChannelIdErrorZ {
	CResult_u64ShortChannelIdErrorZ {
		contents: CResult_u64ShortChannelIdErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_u64ShortChannelIdErrorZ in the error state.
pub extern "C" fn CResult_u64ShortChannelIdErrorZ_err(e: crate::lightning::util::scid_utils::ShortChannelIdError) -> CResult_u64ShortChannelIdErrorZ {
	CResult_u64ShortChannelIdErrorZ {
		contents: CResult_u64ShortChannelIdErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_u64ShortChannelIdErrorZ_is_ok(o: &CResult_u64ShortChannelIdErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_u64ShortChannelIdErrorZ.
pub extern "C" fn CResult_u64ShortChannelIdErrorZ_free(_res: CResult_u64ShortChannelIdErrorZ) { }
impl Drop for CResult_u64ShortChannelIdErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<u64, crate::lightning::util::scid_utils::ShortChannelIdError>> for CResult_u64ShortChannelIdErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<u64, crate::lightning::util::scid_utils::ShortChannelIdError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_u64ShortChannelIdErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_u64ShortChannelIdErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_PendingHTLCInfoInboundHTLCErrZ
pub union CResult_PendingHTLCInfoInboundHTLCErrZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::PendingHTLCInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::onion_payment::InboundHTLCErr,
}
#[repr(C)]
/// A CResult_PendingHTLCInfoInboundHTLCErrZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::PendingHTLCInfo on success and a crate::lightning::ln::onion_payment::InboundHTLCErr on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PendingHTLCInfoInboundHTLCErrZ {
	/// The contents of this CResult_PendingHTLCInfoInboundHTLCErrZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PendingHTLCInfoInboundHTLCErrZPtr,
	/// Whether this CResult_PendingHTLCInfoInboundHTLCErrZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoInboundHTLCErrZ in the success state.
pub extern "C" fn CResult_PendingHTLCInfoInboundHTLCErrZ_ok(o: crate::lightning::ln::channelmanager::PendingHTLCInfo) -> CResult_PendingHTLCInfoInboundHTLCErrZ {
	CResult_PendingHTLCInfoInboundHTLCErrZ {
		contents: CResult_PendingHTLCInfoInboundHTLCErrZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoInboundHTLCErrZ in the error state.
pub extern "C" fn CResult_PendingHTLCInfoInboundHTLCErrZ_err(e: crate::lightning::ln::onion_payment::InboundHTLCErr) -> CResult_PendingHTLCInfoInboundHTLCErrZ {
	CResult_PendingHTLCInfoInboundHTLCErrZ {
		contents: CResult_PendingHTLCInfoInboundHTLCErrZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PendingHTLCInfoInboundHTLCErrZ_is_ok(o: &CResult_PendingHTLCInfoInboundHTLCErrZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PendingHTLCInfoInboundHTLCErrZ.
pub extern "C" fn CResult_PendingHTLCInfoInboundHTLCErrZ_free(_res: CResult_PendingHTLCInfoInboundHTLCErrZ) { }
impl Drop for CResult_PendingHTLCInfoInboundHTLCErrZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCInfo, crate::lightning::ln::onion_payment::InboundHTLCErr>> for CResult_PendingHTLCInfoInboundHTLCErrZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCInfo, crate::lightning::ln::onion_payment::InboundHTLCErr>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PendingHTLCInfoInboundHTLCErrZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PendingHTLCInfoInboundHTLCErrZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PendingHTLCInfoInboundHTLCErrZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PendingHTLCInfoInboundHTLCErrZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::PendingHTLCInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PendingHTLCInfoInboundHTLCErrZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::onion_payment::InboundHTLCErr>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoInboundHTLCErrZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PendingHTLCInfoInboundHTLCErrZ_clone(orig: &CResult_PendingHTLCInfoInboundHTLCErrZ) -> CResult_PendingHTLCInfoInboundHTLCErrZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::chan_utils::HTLCOutputInCommitments of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_HTLCOutputInCommitmentZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::chan_utils::HTLCOutputInCommitment,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_HTLCOutputInCommitmentZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::chan_utils::HTLCOutputInCommitment> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::chan_utils::HTLCOutputInCommitment] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::chan_utils::HTLCOutputInCommitment>> for CVec_HTLCOutputInCommitmentZ {
	fn from(v: Vec<crate::lightning::ln::chan_utils::HTLCOutputInCommitment>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_HTLCOutputInCommitmentZ_free(_res: CVec_HTLCOutputInCommitmentZ) { }
impl Drop for CVec_HTLCOutputInCommitmentZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_HTLCOutputInCommitmentZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::sign::HTLCDescriptors of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_HTLCDescriptorZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::sign::HTLCDescriptor,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_HTLCDescriptorZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::sign::HTLCDescriptor> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::sign::HTLCDescriptor] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::sign::HTLCDescriptor>> for CVec_HTLCDescriptorZ {
	fn from(v: Vec<crate::lightning::sign::HTLCDescriptor>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_HTLCDescriptorZ_free(_res: CVec_HTLCDescriptorZ) { }
impl Drop for CVec_HTLCDescriptorZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_HTLCDescriptorZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::events::bump_transaction::Utxos of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_UtxoZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::events::bump_transaction::Utxo,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_UtxoZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::events::bump_transaction::Utxo> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::events::bump_transaction::Utxo] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::events::bump_transaction::Utxo>> for CVec_UtxoZ {
	fn from(v: Vec<crate::lightning::events::bump_transaction::Utxo>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_UtxoZ_free(_res: CVec_UtxoZ) { }
impl Drop for CVec_UtxoZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_UtxoZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::TxOut or not
pub enum COption_TxOutZ {
	/// When we're in this state, this COption_TxOutZ contains a crate::c_types::TxOut
	Some(crate::c_types::TxOut),
	/// When we're in this state, this COption_TxOutZ contains nothing
	None
}
impl COption_TxOutZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::TxOut {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_TxOutZ containing a crate::c_types::TxOut
pub extern "C" fn COption_TxOutZ_some(o: crate::c_types::TxOut) -> COption_TxOutZ {
	COption_TxOutZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_TxOutZ containing nothing
pub extern "C" fn COption_TxOutZ_none() -> COption_TxOutZ {
	COption_TxOutZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::TxOut, if we are in the Some state
pub extern "C" fn COption_TxOutZ_free(_res: COption_TxOutZ) { }
#[no_mangle]
/// Creates a new COption_TxOutZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_TxOutZ_clone(orig: &COption_TxOutZ) -> COption_TxOutZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::events::bump_transaction::Inputs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_InputZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::events::bump_transaction::Input,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_InputZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::events::bump_transaction::Input> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::events::bump_transaction::Input] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::events::bump_transaction::Input>> for CVec_InputZ {
	fn from(v: Vec<crate::lightning::events::bump_transaction::Input>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_InputZ_free(_res: CVec_InputZ) { }
impl Drop for CVec_InputZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_InputZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CoinSelectionNoneZ
pub union CResult_CoinSelectionNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::events::bump_transaction::CoinSelection,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CoinSelectionNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::events::bump_transaction::CoinSelection on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CoinSelectionNoneZ {
	/// The contents of this CResult_CoinSelectionNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CoinSelectionNoneZPtr,
	/// Whether this CResult_CoinSelectionNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CoinSelectionNoneZ in the success state.
pub extern "C" fn CResult_CoinSelectionNoneZ_ok(o: crate::lightning::events::bump_transaction::CoinSelection) -> CResult_CoinSelectionNoneZ {
	CResult_CoinSelectionNoneZ {
		contents: CResult_CoinSelectionNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CoinSelectionNoneZ in the error state.
pub extern "C" fn CResult_CoinSelectionNoneZ_err() -> CResult_CoinSelectionNoneZ {
	CResult_CoinSelectionNoneZ {
		contents: CResult_CoinSelectionNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CoinSelectionNoneZ_is_ok(o: &CResult_CoinSelectionNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CoinSelectionNoneZ.
pub extern "C" fn CResult_CoinSelectionNoneZ_free(_res: CResult_CoinSelectionNoneZ) { }
impl Drop for CResult_CoinSelectionNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::events::bump_transaction::CoinSelection, ()>> for CResult_CoinSelectionNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::events::bump_transaction::CoinSelection, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CoinSelectionNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CoinSelectionNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CoinSelectionNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CoinSelectionNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::events::bump_transaction::CoinSelection>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CoinSelectionNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CoinSelectionNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CoinSelectionNoneZ_clone(orig: &CResult_CoinSelectionNoneZ) -> CResult_CoinSelectionNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CVec_UtxoZNoneZ
pub union CResult_CVec_UtxoZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_UtxoZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CVec_UtxoZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_UtxoZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_UtxoZNoneZ {
	/// The contents of this CResult_CVec_UtxoZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_UtxoZNoneZPtr,
	/// Whether this CResult_CVec_UtxoZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_UtxoZNoneZ in the success state.
pub extern "C" fn CResult_CVec_UtxoZNoneZ_ok(o: crate::c_types::derived::CVec_UtxoZ) -> CResult_CVec_UtxoZNoneZ {
	CResult_CVec_UtxoZNoneZ {
		contents: CResult_CVec_UtxoZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_UtxoZNoneZ in the error state.
pub extern "C" fn CResult_CVec_UtxoZNoneZ_err() -> CResult_CVec_UtxoZNoneZ {
	CResult_CVec_UtxoZNoneZ {
		contents: CResult_CVec_UtxoZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_UtxoZNoneZ_is_ok(o: &CResult_CVec_UtxoZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_UtxoZNoneZ.
pub extern "C" fn CResult_CVec_UtxoZNoneZ_free(_res: CResult_CVec_UtxoZNoneZ) { }
impl Drop for CResult_CVec_UtxoZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_UtxoZ, ()>> for CResult_CVec_UtxoZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_UtxoZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_UtxoZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CVec_UtxoZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_UtxoZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_UtxoZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_UtxoZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_UtxoZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_UtxoZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_UtxoZNoneZ_clone(orig: &CResult_CVec_UtxoZNoneZ) -> CResult_CVec_UtxoZNoneZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::blinded_path::payment::PaymentContext or not
pub enum COption_PaymentContextZ {
	/// When we're in this state, this COption_PaymentContextZ contains a crate::lightning::blinded_path::payment::PaymentContext
	Some(crate::lightning::blinded_path::payment::PaymentContext),
	/// When we're in this state, this COption_PaymentContextZ contains nothing
	None
}
impl COption_PaymentContextZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::blinded_path::payment::PaymentContext {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_PaymentContextZ containing a crate::lightning::blinded_path::payment::PaymentContext
pub extern "C" fn COption_PaymentContextZ_some(o: crate::lightning::blinded_path::payment::PaymentContext) -> COption_PaymentContextZ {
	COption_PaymentContextZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_PaymentContextZ containing nothing
pub extern "C" fn COption_PaymentContextZ_none() -> COption_PaymentContextZ {
	COption_PaymentContextZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::blinded_path::payment::PaymentContext, if we are in the Some state
pub extern "C" fn COption_PaymentContextZ_free(_res: COption_PaymentContextZ) { }
#[no_mangle]
/// Creates a new COption_PaymentContextZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_PaymentContextZ_clone(orig: &COption_PaymentContextZ) -> COption_PaymentContextZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_u64u16Z {
	/// The element at position 0
	pub a: u64,
	/// The element at position 1
	pub b: u16,
}
impl From<(u64, u16)> for C2Tuple_u64u16Z {
	fn from (tup: (u64, u16)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_u64u16Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (u64, u16) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_u64u16Z {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_u64u16Z_clone(orig: &C2Tuple_u64u16Z) -> C2Tuple_u64u16Z { Clone::clone(&orig) }
/// Creates a new C2Tuple_u64u16Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_u64u16Z_new(a: u64, b: u16) -> C2Tuple_u64u16Z {
	C2Tuple_u64u16Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_u64u16Z.
pub extern "C" fn C2Tuple_u64u16Z_free(_res: C2Tuple_u64u16Z) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_u64u16Z or not
pub enum COption_C2Tuple_u64u16ZZ {
	/// When we're in this state, this COption_C2Tuple_u64u16ZZ contains a crate::c_types::derived::C2Tuple_u64u16Z
	Some(crate::c_types::derived::C2Tuple_u64u16Z),
	/// When we're in this state, this COption_C2Tuple_u64u16ZZ contains nothing
	None
}
impl COption_C2Tuple_u64u16ZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_u64u16Z {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_u64u16ZZ containing a crate::c_types::derived::C2Tuple_u64u16Z
pub extern "C" fn COption_C2Tuple_u64u16ZZ_some(o: crate::c_types::derived::C2Tuple_u64u16Z) -> COption_C2Tuple_u64u16ZZ {
	COption_C2Tuple_u64u16ZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_u64u16ZZ containing nothing
pub extern "C" fn COption_C2Tuple_u64u16ZZ_none() -> COption_C2Tuple_u64u16ZZ {
	COption_C2Tuple_u64u16ZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_u64u16Z, if we are in the Some state
pub extern "C" fn COption_C2Tuple_u64u16ZZ_free(_res: COption_C2Tuple_u64u16ZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_u64u16ZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_u64u16ZZ_clone(orig: &COption_C2Tuple_u64u16ZZ) -> COption_C2Tuple_u64u16ZZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelIdAPIErrorZ
pub union CResult_ChannelIdAPIErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::types::ChannelId,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::util::errors::APIError,
}
#[repr(C)]
/// A CResult_ChannelIdAPIErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::types::ChannelId on success and a crate::lightning::util::errors::APIError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelIdAPIErrorZ {
	/// The contents of this CResult_ChannelIdAPIErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelIdAPIErrorZPtr,
	/// Whether this CResult_ChannelIdAPIErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelIdAPIErrorZ in the success state.
pub extern "C" fn CResult_ChannelIdAPIErrorZ_ok(o: crate::lightning::ln::types::ChannelId) -> CResult_ChannelIdAPIErrorZ {
	CResult_ChannelIdAPIErrorZ {
		contents: CResult_ChannelIdAPIErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelIdAPIErrorZ in the error state.
pub extern "C" fn CResult_ChannelIdAPIErrorZ_err(e: crate::lightning::util::errors::APIError) -> CResult_ChannelIdAPIErrorZ {
	CResult_ChannelIdAPIErrorZ {
		contents: CResult_ChannelIdAPIErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelIdAPIErrorZ_is_ok(o: &CResult_ChannelIdAPIErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelIdAPIErrorZ.
pub extern "C" fn CResult_ChannelIdAPIErrorZ_free(_res: CResult_ChannelIdAPIErrorZ) { }
impl Drop for CResult_ChannelIdAPIErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::types::ChannelId, crate::lightning::util::errors::APIError>> for CResult_ChannelIdAPIErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::types::ChannelId, crate::lightning::util::errors::APIError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelIdAPIErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelIdAPIErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelIdAPIErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelIdAPIErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::types::ChannelId>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelIdAPIErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::util::errors::APIError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelIdAPIErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelIdAPIErrorZ_clone(orig: &CResult_ChannelIdAPIErrorZ) -> CResult_ChannelIdAPIErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::channelmanager::RecentPaymentDetailss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_RecentPaymentDetailsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::channelmanager::RecentPaymentDetails,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_RecentPaymentDetailsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::channelmanager::RecentPaymentDetails> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::channelmanager::RecentPaymentDetails] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::channelmanager::RecentPaymentDetails>> for CVec_RecentPaymentDetailsZ {
	fn from(v: Vec<crate::lightning::ln::channelmanager::RecentPaymentDetails>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_RecentPaymentDetailsZ_free(_res: CVec_RecentPaymentDetailsZ) { }
impl Drop for CVec_RecentPaymentDetailsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
#[repr(C)]
/// The contents of CResult_NoneAPIErrorZ
pub union CResult_NoneAPIErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::util::errors::APIError,
}
#[repr(C)]
/// A CResult_NoneAPIErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::util::errors::APIError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneAPIErrorZ {
	/// The contents of this CResult_NoneAPIErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneAPIErrorZPtr,
	/// Whether this CResult_NoneAPIErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneAPIErrorZ in the success state.
pub extern "C" fn CResult_NoneAPIErrorZ_ok() -> CResult_NoneAPIErrorZ {
	CResult_NoneAPIErrorZ {
		contents: CResult_NoneAPIErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneAPIErrorZ in the error state.
pub extern "C" fn CResult_NoneAPIErrorZ_err(e: crate::lightning::util::errors::APIError) -> CResult_NoneAPIErrorZ {
	CResult_NoneAPIErrorZ {
		contents: CResult_NoneAPIErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneAPIErrorZ_is_ok(o: &CResult_NoneAPIErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneAPIErrorZ.
pub extern "C" fn CResult_NoneAPIErrorZ_free(_res: CResult_NoneAPIErrorZ) { }
impl Drop for CResult_NoneAPIErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::util::errors::APIError>> for CResult_NoneAPIErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::util::errors::APIError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneAPIErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneAPIErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneAPIErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneAPIErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneAPIErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::util::errors::APIError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneAPIErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneAPIErrorZ_clone(orig: &CResult_NoneAPIErrorZ) -> CResult_NoneAPIErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneRetryableSendFailureZ
pub union CResult_NoneRetryableSendFailureZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::RetryableSendFailure,
}
#[repr(C)]
/// A CResult_NoneRetryableSendFailureZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::outbound_payment::RetryableSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneRetryableSendFailureZ {
	/// The contents of this CResult_NoneRetryableSendFailureZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneRetryableSendFailureZPtr,
	/// Whether this CResult_NoneRetryableSendFailureZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneRetryableSendFailureZ in the success state.
pub extern "C" fn CResult_NoneRetryableSendFailureZ_ok() -> CResult_NoneRetryableSendFailureZ {
	CResult_NoneRetryableSendFailureZ {
		contents: CResult_NoneRetryableSendFailureZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneRetryableSendFailureZ in the error state.
pub extern "C" fn CResult_NoneRetryableSendFailureZ_err(e: crate::lightning::ln::outbound_payment::RetryableSendFailure) -> CResult_NoneRetryableSendFailureZ {
	CResult_NoneRetryableSendFailureZ {
		contents: CResult_NoneRetryableSendFailureZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneRetryableSendFailureZ_is_ok(o: &CResult_NoneRetryableSendFailureZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneRetryableSendFailureZ.
pub extern "C" fn CResult_NoneRetryableSendFailureZ_free(_res: CResult_NoneRetryableSendFailureZ) { }
impl Drop for CResult_NoneRetryableSendFailureZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::ln::outbound_payment::RetryableSendFailure>> for CResult_NoneRetryableSendFailureZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::ln::outbound_payment::RetryableSendFailure>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneRetryableSendFailureZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneRetryableSendFailureZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneRetryableSendFailureZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneRetryableSendFailureZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneRetryableSendFailureZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::RetryableSendFailure>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneRetryableSendFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneRetryableSendFailureZ_clone(orig: &CResult_NoneRetryableSendFailureZ) -> CResult_NoneRetryableSendFailureZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::blinded_path::message::OffersContext or not
pub enum COption_OffersContextZ {
	/// When we're in this state, this COption_OffersContextZ contains a crate::lightning::blinded_path::message::OffersContext
	Some(crate::lightning::blinded_path::message::OffersContext),
	/// When we're in this state, this COption_OffersContextZ contains nothing
	None
}
impl COption_OffersContextZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::blinded_path::message::OffersContext {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_OffersContextZ containing a crate::lightning::blinded_path::message::OffersContext
pub extern "C" fn COption_OffersContextZ_some(o: crate::lightning::blinded_path::message::OffersContext) -> COption_OffersContextZ {
	COption_OffersContextZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_OffersContextZ containing nothing
pub extern "C" fn COption_OffersContextZ_none() -> COption_OffersContextZ {
	COption_OffersContextZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::blinded_path::message::OffersContext, if we are in the Some state
pub extern "C" fn COption_OffersContextZ_free(_res: COption_OffersContextZ) { }
#[no_mangle]
/// Creates a new COption_OffersContextZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_OffersContextZ_clone(orig: &COption_OffersContextZ) -> COption_OffersContextZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneBolt12PaymentErrorZ
pub union CResult_NoneBolt12PaymentErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::Bolt12PaymentError,
}
#[repr(C)]
/// A CResult_NoneBolt12PaymentErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::outbound_payment::Bolt12PaymentError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneBolt12PaymentErrorZ {
	/// The contents of this CResult_NoneBolt12PaymentErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneBolt12PaymentErrorZPtr,
	/// Whether this CResult_NoneBolt12PaymentErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneBolt12PaymentErrorZ in the success state.
pub extern "C" fn CResult_NoneBolt12PaymentErrorZ_ok() -> CResult_NoneBolt12PaymentErrorZ {
	CResult_NoneBolt12PaymentErrorZ {
		contents: CResult_NoneBolt12PaymentErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneBolt12PaymentErrorZ in the error state.
pub extern "C" fn CResult_NoneBolt12PaymentErrorZ_err(e: crate::lightning::ln::outbound_payment::Bolt12PaymentError) -> CResult_NoneBolt12PaymentErrorZ {
	CResult_NoneBolt12PaymentErrorZ {
		contents: CResult_NoneBolt12PaymentErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneBolt12PaymentErrorZ_is_ok(o: &CResult_NoneBolt12PaymentErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneBolt12PaymentErrorZ.
pub extern "C" fn CResult_NoneBolt12PaymentErrorZ_free(_res: CResult_NoneBolt12PaymentErrorZ) { }
impl Drop for CResult_NoneBolt12PaymentErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::ln::outbound_payment::Bolt12PaymentError>> for CResult_NoneBolt12PaymentErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::ln::outbound_payment::Bolt12PaymentError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneBolt12PaymentErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneBolt12PaymentErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneBolt12PaymentErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneBolt12PaymentErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneBolt12PaymentErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::Bolt12PaymentError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneBolt12PaymentErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneBolt12PaymentErrorZ_clone(orig: &CResult_NoneBolt12PaymentErrorZ) -> CResult_NoneBolt12PaymentErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ThirtyTwoBytesRetryableSendFailureZ
pub union CResult_ThirtyTwoBytesRetryableSendFailureZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::ThirtyTwoBytes,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::RetryableSendFailure,
}
#[repr(C)]
/// A CResult_ThirtyTwoBytesRetryableSendFailureZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::ln::outbound_payment::RetryableSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ThirtyTwoBytesRetryableSendFailureZ {
	/// The contents of this CResult_ThirtyTwoBytesRetryableSendFailureZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ThirtyTwoBytesRetryableSendFailureZPtr,
	/// Whether this CResult_ThirtyTwoBytesRetryableSendFailureZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesRetryableSendFailureZ in the success state.
pub extern "C" fn CResult_ThirtyTwoBytesRetryableSendFailureZ_ok(o: crate::c_types::ThirtyTwoBytes) -> CResult_ThirtyTwoBytesRetryableSendFailureZ {
	CResult_ThirtyTwoBytesRetryableSendFailureZ {
		contents: CResult_ThirtyTwoBytesRetryableSendFailureZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesRetryableSendFailureZ in the error state.
pub extern "C" fn CResult_ThirtyTwoBytesRetryableSendFailureZ_err(e: crate::lightning::ln::outbound_payment::RetryableSendFailure) -> CResult_ThirtyTwoBytesRetryableSendFailureZ {
	CResult_ThirtyTwoBytesRetryableSendFailureZ {
		contents: CResult_ThirtyTwoBytesRetryableSendFailureZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ThirtyTwoBytesRetryableSendFailureZ_is_ok(o: &CResult_ThirtyTwoBytesRetryableSendFailureZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ThirtyTwoBytesRetryableSendFailureZ.
pub extern "C" fn CResult_ThirtyTwoBytesRetryableSendFailureZ_free(_res: CResult_ThirtyTwoBytesRetryableSendFailureZ) { }
impl Drop for CResult_ThirtyTwoBytesRetryableSendFailureZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::RetryableSendFailure>> for CResult_ThirtyTwoBytesRetryableSendFailureZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::RetryableSendFailure>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ThirtyTwoBytesRetryableSendFailureZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ThirtyTwoBytesRetryableSendFailureZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ThirtyTwoBytesRetryableSendFailureZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ThirtyTwoBytesRetryableSendFailureZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::ThirtyTwoBytes>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ThirtyTwoBytesRetryableSendFailureZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::RetryableSendFailure>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesRetryableSendFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ThirtyTwoBytesRetryableSendFailureZ_clone(orig: &CResult_ThirtyTwoBytesRetryableSendFailureZ) -> CResult_ThirtyTwoBytesRetryableSendFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::c_types::ThirtyTwoBytes,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::c_types::ThirtyTwoBytes)> for C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::c_types::ThirtyTwoBytes)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::c_types::ThirtyTwoBytes) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ_clone(orig: &C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ) -> C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::c_types::ThirtyTwoBytes) -> C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
	C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ_free(_res: C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ
pub union CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::ProbeSendFailure,
}
#[repr(C)]
/// A CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ on success and a crate::lightning::ln::outbound_payment::ProbeSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ {
	/// The contents of this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZPtr,
	/// Whether this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ in the success state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ_ok(o: crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ) -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ {
	CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ in the error state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ_err(e: crate::lightning::ln::outbound_payment::ProbeSendFailure) -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ {
	CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ_is_ok(o: &CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ_free(_res: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ) { }
impl Drop for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ, crate::lightning::ln::outbound_payment::ProbeSendFailure>> for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ, crate::lightning::ln::outbound_payment::ProbeSendFailure>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::ProbeSendFailure>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ_clone(orig: &CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ) -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZProbeSendFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ>> for CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ_free(_res: CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ) { }
impl Drop for CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ
pub union CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::ProbeSendFailure,
}
#[repr(C)]
/// A CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ on success and a crate::lightning::ln::outbound_payment::ProbeSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	/// The contents of this CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr,
	/// Whether this CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ in the success state.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_ok(o: crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ) -> CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
		contents: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ in the error state.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_err(e: crate::lightning::ln::outbound_payment::ProbeSendFailure) -> CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
		contents: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_is_ok(o: &CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_free(_res: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ) { }
impl Drop for CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ, crate::lightning::ln::outbound_payment::ProbeSendFailure>> for CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ, crate::lightning::ln::outbound_payment::ProbeSendFailure>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::ProbeSendFailure>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_clone(orig: &CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ) -> CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ChannelIdPublicKeyZ {
	/// The element at position 0
	pub a: crate::lightning::ln::types::ChannelId,
	/// The element at position 1
	pub b: crate::c_types::PublicKey,
}
impl From<(crate::lightning::ln::types::ChannelId, crate::c_types::PublicKey)> for C2Tuple_ChannelIdPublicKeyZ {
	fn from (tup: (crate::lightning::ln::types::ChannelId, crate::c_types::PublicKey)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ChannelIdPublicKeyZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::ln::types::ChannelId, crate::c_types::PublicKey) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ChannelIdPublicKeyZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ChannelIdPublicKeyZ_clone(orig: &C2Tuple_ChannelIdPublicKeyZ) -> C2Tuple_ChannelIdPublicKeyZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ChannelIdPublicKeyZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ChannelIdPublicKeyZ_new(a: crate::lightning::ln::types::ChannelId, b: crate::c_types::PublicKey) -> C2Tuple_ChannelIdPublicKeyZ {
	C2Tuple_ChannelIdPublicKeyZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ChannelIdPublicKeyZ.
pub extern "C" fn C2Tuple_ChannelIdPublicKeyZ_free(_res: C2Tuple_ChannelIdPublicKeyZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_ChannelIdPublicKeyZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_ChannelIdPublicKeyZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_ChannelIdPublicKeyZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_ChannelIdPublicKeyZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_ChannelIdPublicKeyZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_ChannelIdPublicKeyZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_ChannelIdPublicKeyZ>> for CVec_C2Tuple_ChannelIdPublicKeyZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_ChannelIdPublicKeyZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_ChannelIdPublicKeyZZ_free(_res: CVec_C2Tuple_ChannelIdPublicKeyZZ) { }
impl Drop for CVec_C2Tuple_ChannelIdPublicKeyZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_ChannelIdPublicKeyZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::types::ChannelIds of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ChannelIdZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::types::ChannelId,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ChannelIdZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::types::ChannelId> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::types::ChannelId] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::types::ChannelId>> for CVec_ChannelIdZ {
	fn from(v: Vec<crate::lightning::ln::types::ChannelId>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ChannelIdZ_free(_res: CVec_ChannelIdZ) { }
impl Drop for CVec_ChannelIdZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ChannelIdZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_PublicKeyChannelIdZ {
	/// The element at position 0
	pub a: crate::c_types::PublicKey,
	/// The element at position 1
	pub b: crate::lightning::ln::types::ChannelId,
}
impl From<(crate::c_types::PublicKey, crate::lightning::ln::types::ChannelId)> for C2Tuple_PublicKeyChannelIdZ {
	fn from (tup: (crate::c_types::PublicKey, crate::lightning::ln::types::ChannelId)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_PublicKeyChannelIdZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::PublicKey, crate::lightning::ln::types::ChannelId) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_PublicKeyChannelIdZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_PublicKeyChannelIdZ_clone(orig: &C2Tuple_PublicKeyChannelIdZ) -> C2Tuple_PublicKeyChannelIdZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_PublicKeyChannelIdZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_PublicKeyChannelIdZ_new(a: crate::c_types::PublicKey, b: crate::lightning::ln::types::ChannelId) -> C2Tuple_PublicKeyChannelIdZ {
	C2Tuple_PublicKeyChannelIdZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_PublicKeyChannelIdZ.
pub extern "C" fn C2Tuple_PublicKeyChannelIdZ_free(_res: C2Tuple_PublicKeyChannelIdZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_PublicKeyChannelIdZ or not
pub enum COption_C2Tuple_PublicKeyChannelIdZZ {
	/// When we're in this state, this COption_C2Tuple_PublicKeyChannelIdZZ contains a crate::c_types::derived::C2Tuple_PublicKeyChannelIdZ
	Some(crate::c_types::derived::C2Tuple_PublicKeyChannelIdZ),
	/// When we're in this state, this COption_C2Tuple_PublicKeyChannelIdZZ contains nothing
	None
}
impl COption_C2Tuple_PublicKeyChannelIdZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_PublicKeyChannelIdZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_PublicKeyChannelIdZZ containing a crate::c_types::derived::C2Tuple_PublicKeyChannelIdZ
pub extern "C" fn COption_C2Tuple_PublicKeyChannelIdZZ_some(o: crate::c_types::derived::C2Tuple_PublicKeyChannelIdZ) -> COption_C2Tuple_PublicKeyChannelIdZZ {
	COption_C2Tuple_PublicKeyChannelIdZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_PublicKeyChannelIdZZ containing nothing
pub extern "C" fn COption_C2Tuple_PublicKeyChannelIdZZ_none() -> COption_C2Tuple_PublicKeyChannelIdZZ {
	COption_C2Tuple_PublicKeyChannelIdZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_PublicKeyChannelIdZ, if we are in the Some state
pub extern "C" fn COption_C2Tuple_PublicKeyChannelIdZZ_free(_res: COption_C2Tuple_PublicKeyChannelIdZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_PublicKeyChannelIdZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_PublicKeyChannelIdZZ_clone(orig: &COption_C2Tuple_PublicKeyChannelIdZZ) -> COption_C2Tuple_PublicKeyChannelIdZZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt11InvoiceSignOrCreationErrorZ
pub union CResult_Bolt11InvoiceSignOrCreationErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::Bolt11Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::SignOrCreationError,
}
#[repr(C)]
/// A CResult_Bolt11InvoiceSignOrCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Bolt11Invoice on success and a crate::lightning_invoice::SignOrCreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt11InvoiceSignOrCreationErrorZ {
	/// The contents of this CResult_Bolt11InvoiceSignOrCreationErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt11InvoiceSignOrCreationErrorZPtr,
	/// Whether this CResult_Bolt11InvoiceSignOrCreationErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceSignOrCreationErrorZ in the success state.
pub extern "C" fn CResult_Bolt11InvoiceSignOrCreationErrorZ_ok(o: crate::lightning_invoice::Bolt11Invoice) -> CResult_Bolt11InvoiceSignOrCreationErrorZ {
	CResult_Bolt11InvoiceSignOrCreationErrorZ {
		contents: CResult_Bolt11InvoiceSignOrCreationErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceSignOrCreationErrorZ in the error state.
pub extern "C" fn CResult_Bolt11InvoiceSignOrCreationErrorZ_err(e: crate::lightning_invoice::SignOrCreationError) -> CResult_Bolt11InvoiceSignOrCreationErrorZ {
	CResult_Bolt11InvoiceSignOrCreationErrorZ {
		contents: CResult_Bolt11InvoiceSignOrCreationErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt11InvoiceSignOrCreationErrorZ_is_ok(o: &CResult_Bolt11InvoiceSignOrCreationErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt11InvoiceSignOrCreationErrorZ.
pub extern "C" fn CResult_Bolt11InvoiceSignOrCreationErrorZ_free(_res: CResult_Bolt11InvoiceSignOrCreationErrorZ) { }
impl Drop for CResult_Bolt11InvoiceSignOrCreationErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::SignOrCreationError>> for CResult_Bolt11InvoiceSignOrCreationErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::SignOrCreationError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt11InvoiceSignOrCreationErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt11InvoiceSignOrCreationErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt11InvoiceSignOrCreationErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt11InvoiceSignOrCreationErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt11InvoiceSignOrCreationErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::SignOrCreationError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceSignOrCreationErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt11InvoiceSignOrCreationErrorZ_clone(orig: &CResult_Bolt11InvoiceSignOrCreationErrorZ) -> CResult_Bolt11InvoiceSignOrCreationErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ
pub union CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::offer::OfferWithDerivedMetadataBuilder,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::offer::OfferWithDerivedMetadataBuilder on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	/// The contents of this CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZPtr,
	/// Whether this CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ_ok(o: crate::lightning::offers::offer::OfferWithDerivedMetadataBuilder) -> CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ {
		contents: CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ {
		contents: CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ_is_ok(o: &CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ.
pub extern "C" fn CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ_free(_res: CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ) { }
impl Drop for CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::offer::OfferWithDerivedMetadataBuilder, crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::offer::OfferWithDerivedMetadataBuilder, crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::offer::OfferWithDerivedMetadataBuilder>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ_clone(orig: &CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ) -> CResult_OfferWithDerivedMetadataBuilderBolt12SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::Str or not
pub enum COption_StrZ {
	/// When we're in this state, this COption_StrZ contains a crate::c_types::Str
	Some(crate::c_types::Str),
	/// When we're in this state, this COption_StrZ contains nothing
	None
}
impl COption_StrZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::Str {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_StrZ containing a crate::c_types::Str
pub extern "C" fn COption_StrZ_some(o: crate::c_types::Str) -> COption_StrZ {
	COption_StrZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_StrZ containing nothing
pub extern "C" fn COption_StrZ_none() -> COption_StrZ {
	COption_StrZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::Str, if we are in the Some state
pub extern "C" fn COption_StrZ_free(_res: COption_StrZ) { }
#[no_mangle]
/// Creates a new COption_StrZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_StrZ_clone(orig: &COption_StrZ) -> COption_StrZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::onion_message::messenger::Destinations of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_DestinationZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::onion_message::messenger::Destination,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_DestinationZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::onion_message::messenger::Destination> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::onion_message::messenger::Destination] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::onion_message::messenger::Destination>> for CVec_DestinationZ {
	fn from(v: Vec<crate::lightning::onion_message::messenger::Destination>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_DestinationZ_free(_res: CVec_DestinationZ) { }
impl Drop for CVec_DestinationZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_DestinationZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ
pub union CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	/// The contents of this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr,
	/// Whether this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ in the success state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_ok(o: crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ) -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ in the error state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_err() -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_is_ok(o: &CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_free(_res: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ) { }
impl Drop for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ, ()>> for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_clone(orig: &CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ) -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ThirtyTwoBytesAPIErrorZ
pub union CResult_ThirtyTwoBytesAPIErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::ThirtyTwoBytes,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::util::errors::APIError,
}
#[repr(C)]
/// A CResult_ThirtyTwoBytesAPIErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ThirtyTwoBytesAPIErrorZ {
	/// The contents of this CResult_ThirtyTwoBytesAPIErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ThirtyTwoBytesAPIErrorZPtr,
	/// Whether this CResult_ThirtyTwoBytesAPIErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesAPIErrorZ in the success state.
pub extern "C" fn CResult_ThirtyTwoBytesAPIErrorZ_ok(o: crate::c_types::ThirtyTwoBytes) -> CResult_ThirtyTwoBytesAPIErrorZ {
	CResult_ThirtyTwoBytesAPIErrorZ {
		contents: CResult_ThirtyTwoBytesAPIErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesAPIErrorZ in the error state.
pub extern "C" fn CResult_ThirtyTwoBytesAPIErrorZ_err(e: crate::lightning::util::errors::APIError) -> CResult_ThirtyTwoBytesAPIErrorZ {
	CResult_ThirtyTwoBytesAPIErrorZ {
		contents: CResult_ThirtyTwoBytesAPIErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ThirtyTwoBytesAPIErrorZ_is_ok(o: &CResult_ThirtyTwoBytesAPIErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ThirtyTwoBytesAPIErrorZ.
pub extern "C" fn CResult_ThirtyTwoBytesAPIErrorZ_free(_res: CResult_ThirtyTwoBytesAPIErrorZ) { }
impl Drop for CResult_ThirtyTwoBytesAPIErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, crate::lightning::util::errors::APIError>> for CResult_ThirtyTwoBytesAPIErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, crate::lightning::util::errors::APIError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ThirtyTwoBytesAPIErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ThirtyTwoBytesAPIErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ThirtyTwoBytesAPIErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ThirtyTwoBytesAPIErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::ThirtyTwoBytes>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ThirtyTwoBytesAPIErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::util::errors::APIError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesAPIErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ThirtyTwoBytesAPIErrorZ_clone(orig: &CResult_ThirtyTwoBytesAPIErrorZ) -> CResult_ThirtyTwoBytesAPIErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_OffersMessageResponseInstructionZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::offers::OffersMessage,
	/// The element at position 1
	pub b: crate::lightning::onion_message::messenger::ResponseInstruction,
}
impl From<(crate::lightning::onion_message::offers::OffersMessage, crate::lightning::onion_message::messenger::ResponseInstruction)> for C2Tuple_OffersMessageResponseInstructionZ {
	fn from (tup: (crate::lightning::onion_message::offers::OffersMessage, crate::lightning::onion_message::messenger::ResponseInstruction)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_OffersMessageResponseInstructionZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::offers::OffersMessage, crate::lightning::onion_message::messenger::ResponseInstruction) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_OffersMessageResponseInstructionZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_OffersMessageResponseInstructionZ_clone(orig: &C2Tuple_OffersMessageResponseInstructionZ) -> C2Tuple_OffersMessageResponseInstructionZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_OffersMessageResponseInstructionZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_OffersMessageResponseInstructionZ_new(a: crate::lightning::onion_message::offers::OffersMessage, b: crate::lightning::onion_message::messenger::ResponseInstruction) -> C2Tuple_OffersMessageResponseInstructionZ {
	C2Tuple_OffersMessageResponseInstructionZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_OffersMessageResponseInstructionZ.
pub extern "C" fn C2Tuple_OffersMessageResponseInstructionZ_free(_res: C2Tuple_OffersMessageResponseInstructionZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_OffersMessageResponseInstructionZ or not
pub enum COption_C2Tuple_OffersMessageResponseInstructionZZ {
	/// When we're in this state, this COption_C2Tuple_OffersMessageResponseInstructionZZ contains a crate::c_types::derived::C2Tuple_OffersMessageResponseInstructionZ
	Some(crate::c_types::derived::C2Tuple_OffersMessageResponseInstructionZ),
	/// When we're in this state, this COption_C2Tuple_OffersMessageResponseInstructionZZ contains nothing
	None
}
impl COption_C2Tuple_OffersMessageResponseInstructionZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_OffersMessageResponseInstructionZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_OffersMessageResponseInstructionZZ containing a crate::c_types::derived::C2Tuple_OffersMessageResponseInstructionZ
pub extern "C" fn COption_C2Tuple_OffersMessageResponseInstructionZZ_some(o: crate::c_types::derived::C2Tuple_OffersMessageResponseInstructionZ) -> COption_C2Tuple_OffersMessageResponseInstructionZZ {
	COption_C2Tuple_OffersMessageResponseInstructionZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_OffersMessageResponseInstructionZZ containing nothing
pub extern "C" fn COption_C2Tuple_OffersMessageResponseInstructionZZ_none() -> COption_C2Tuple_OffersMessageResponseInstructionZZ {
	COption_C2Tuple_OffersMessageResponseInstructionZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_OffersMessageResponseInstructionZ, if we are in the Some state
pub extern "C" fn COption_C2Tuple_OffersMessageResponseInstructionZZ_free(_res: COption_C2Tuple_OffersMessageResponseInstructionZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_OffersMessageResponseInstructionZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_OffersMessageResponseInstructionZZ_clone(orig: &COption_C2Tuple_OffersMessageResponseInstructionZZ) -> COption_C2Tuple_OffersMessageResponseInstructionZZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_OffersMessageMessageSendInstructionsZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::offers::OffersMessage,
	/// The element at position 1
	pub b: crate::lightning::onion_message::messenger::MessageSendInstructions,
}
impl From<(crate::lightning::onion_message::offers::OffersMessage, crate::lightning::onion_message::messenger::MessageSendInstructions)> for C2Tuple_OffersMessageMessageSendInstructionsZ {
	fn from (tup: (crate::lightning::onion_message::offers::OffersMessage, crate::lightning::onion_message::messenger::MessageSendInstructions)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_OffersMessageMessageSendInstructionsZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::offers::OffersMessage, crate::lightning::onion_message::messenger::MessageSendInstructions) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_OffersMessageMessageSendInstructionsZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_OffersMessageMessageSendInstructionsZ_clone(orig: &C2Tuple_OffersMessageMessageSendInstructionsZ) -> C2Tuple_OffersMessageMessageSendInstructionsZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_OffersMessageMessageSendInstructionsZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_OffersMessageMessageSendInstructionsZ_new(a: crate::lightning::onion_message::offers::OffersMessage, b: crate::lightning::onion_message::messenger::MessageSendInstructions) -> C2Tuple_OffersMessageMessageSendInstructionsZ {
	C2Tuple_OffersMessageMessageSendInstructionsZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_OffersMessageMessageSendInstructionsZ.
pub extern "C" fn C2Tuple_OffersMessageMessageSendInstructionsZ_free(_res: C2Tuple_OffersMessageMessageSendInstructionsZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_OffersMessageMessageSendInstructionsZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_OffersMessageMessageSendInstructionsZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_OffersMessageMessageSendInstructionsZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_OffersMessageMessageSendInstructionsZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_OffersMessageMessageSendInstructionsZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_OffersMessageMessageSendInstructionsZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_OffersMessageMessageSendInstructionsZ>> for CVec_C2Tuple_OffersMessageMessageSendInstructionsZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_OffersMessageMessageSendInstructionsZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_OffersMessageMessageSendInstructionsZZ_free(_res: CVec_C2Tuple_OffersMessageMessageSendInstructionsZZ) { }
impl Drop for CVec_C2Tuple_OffersMessageMessageSendInstructionsZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_OffersMessageMessageSendInstructionsZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ReleaseHeldHtlcResponseInstructionZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::async_payments::ReleaseHeldHtlc,
	/// The element at position 1
	pub b: crate::lightning::onion_message::messenger::ResponseInstruction,
}
impl From<(crate::lightning::onion_message::async_payments::ReleaseHeldHtlc, crate::lightning::onion_message::messenger::ResponseInstruction)> for C2Tuple_ReleaseHeldHtlcResponseInstructionZ {
	fn from (tup: (crate::lightning::onion_message::async_payments::ReleaseHeldHtlc, crate::lightning::onion_message::messenger::ResponseInstruction)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ReleaseHeldHtlcResponseInstructionZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::async_payments::ReleaseHeldHtlc, crate::lightning::onion_message::messenger::ResponseInstruction) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ReleaseHeldHtlcResponseInstructionZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ReleaseHeldHtlcResponseInstructionZ_clone(orig: &C2Tuple_ReleaseHeldHtlcResponseInstructionZ) -> C2Tuple_ReleaseHeldHtlcResponseInstructionZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ReleaseHeldHtlcResponseInstructionZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ReleaseHeldHtlcResponseInstructionZ_new(a: crate::lightning::onion_message::async_payments::ReleaseHeldHtlc, b: crate::lightning::onion_message::messenger::ResponseInstruction) -> C2Tuple_ReleaseHeldHtlcResponseInstructionZ {
	C2Tuple_ReleaseHeldHtlcResponseInstructionZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ReleaseHeldHtlcResponseInstructionZ.
pub extern "C" fn C2Tuple_ReleaseHeldHtlcResponseInstructionZ_free(_res: C2Tuple_ReleaseHeldHtlcResponseInstructionZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_ReleaseHeldHtlcResponseInstructionZ or not
pub enum COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ {
	/// When we're in this state, this COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ contains a crate::c_types::derived::C2Tuple_ReleaseHeldHtlcResponseInstructionZ
	Some(crate::c_types::derived::C2Tuple_ReleaseHeldHtlcResponseInstructionZ),
	/// When we're in this state, this COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ contains nothing
	None
}
impl COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_ReleaseHeldHtlcResponseInstructionZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ containing a crate::c_types::derived::C2Tuple_ReleaseHeldHtlcResponseInstructionZ
pub extern "C" fn COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ_some(o: crate::c_types::derived::C2Tuple_ReleaseHeldHtlcResponseInstructionZ) -> COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ {
	COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ containing nothing
pub extern "C" fn COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ_none() -> COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ {
	COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_ReleaseHeldHtlcResponseInstructionZ, if we are in the Some state
pub extern "C" fn COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ_free(_res: COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ_clone(orig: &COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ) -> COption_C2Tuple_ReleaseHeldHtlcResponseInstructionZZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::async_payments::AsyncPaymentsMessage,
	/// The element at position 1
	pub b: crate::lightning::onion_message::messenger::MessageSendInstructions,
}
impl From<(crate::lightning::onion_message::async_payments::AsyncPaymentsMessage, crate::lightning::onion_message::messenger::MessageSendInstructions)> for C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ {
	fn from (tup: (crate::lightning::onion_message::async_payments::AsyncPaymentsMessage, crate::lightning::onion_message::messenger::MessageSendInstructions)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::async_payments::AsyncPaymentsMessage, crate::lightning::onion_message::messenger::MessageSendInstructions) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ_clone(orig: &C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ) -> C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ_new(a: crate::lightning::onion_message::async_payments::AsyncPaymentsMessage, b: crate::lightning::onion_message::messenger::MessageSendInstructions) -> C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ {
	C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ.
pub extern "C" fn C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ_free(_res: C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ>> for CVec_C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZZ_free(_res: CVec_C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZZ) { }
impl Drop for CVec_C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_AsyncPaymentsMessageMessageSendInstructionsZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_PhantomRouteHintsDecodeErrorZ
pub union CResult_PhantomRouteHintsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::PhantomRouteHints,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PhantomRouteHintsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::PhantomRouteHints on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PhantomRouteHintsDecodeErrorZ {
	/// The contents of this CResult_PhantomRouteHintsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PhantomRouteHintsDecodeErrorZPtr,
	/// Whether this CResult_PhantomRouteHintsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the success state.
pub extern "C" fn CResult_PhantomRouteHintsDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::PhantomRouteHints) -> CResult_PhantomRouteHintsDecodeErrorZ {
	CResult_PhantomRouteHintsDecodeErrorZ {
		contents: CResult_PhantomRouteHintsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the error state.
pub extern "C" fn CResult_PhantomRouteHintsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PhantomRouteHintsDecodeErrorZ {
	CResult_PhantomRouteHintsDecodeErrorZ {
		contents: CResult_PhantomRouteHintsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PhantomRouteHintsDecodeErrorZ_is_ok(o: &CResult_PhantomRouteHintsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PhantomRouteHintsDecodeErrorZ.
pub extern "C" fn CResult_PhantomRouteHintsDecodeErrorZ_free(_res: CResult_PhantomRouteHintsDecodeErrorZ) { }
impl Drop for CResult_PhantomRouteHintsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PhantomRouteHints, crate::lightning::ln::msgs::DecodeError>> for CResult_PhantomRouteHintsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PhantomRouteHints, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PhantomRouteHintsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PhantomRouteHintsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PhantomRouteHintsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PhantomRouteHintsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::PhantomRouteHints>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PhantomRouteHintsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PhantomRouteHintsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PhantomRouteHintsDecodeErrorZ_clone(orig: &CResult_PhantomRouteHintsDecodeErrorZ) -> CResult_PhantomRouteHintsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedForwardDecodeErrorZ
pub union CResult_BlindedForwardDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::BlindedForward,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedForwardDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::BlindedForward on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedForwardDecodeErrorZ {
	/// The contents of this CResult_BlindedForwardDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedForwardDecodeErrorZPtr,
	/// Whether this CResult_BlindedForwardDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedForwardDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedForwardDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::BlindedForward) -> CResult_BlindedForwardDecodeErrorZ {
	CResult_BlindedForwardDecodeErrorZ {
		contents: CResult_BlindedForwardDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedForwardDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedForwardDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedForwardDecodeErrorZ {
	CResult_BlindedForwardDecodeErrorZ {
		contents: CResult_BlindedForwardDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedForwardDecodeErrorZ_is_ok(o: &CResult_BlindedForwardDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedForwardDecodeErrorZ.
pub extern "C" fn CResult_BlindedForwardDecodeErrorZ_free(_res: CResult_BlindedForwardDecodeErrorZ) { }
impl Drop for CResult_BlindedForwardDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::BlindedForward, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedForwardDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::BlindedForward, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedForwardDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedForwardDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedForwardDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedForwardDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::BlindedForward>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedForwardDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedForwardDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedForwardDecodeErrorZ_clone(orig: &CResult_BlindedForwardDecodeErrorZ) -> CResult_BlindedForwardDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PendingHTLCRoutingDecodeErrorZ
pub union CResult_PendingHTLCRoutingDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::PendingHTLCRouting,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PendingHTLCRoutingDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::PendingHTLCRouting on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PendingHTLCRoutingDecodeErrorZ {
	/// The contents of this CResult_PendingHTLCRoutingDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PendingHTLCRoutingDecodeErrorZPtr,
	/// Whether this CResult_PendingHTLCRoutingDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCRoutingDecodeErrorZ in the success state.
pub extern "C" fn CResult_PendingHTLCRoutingDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::PendingHTLCRouting) -> CResult_PendingHTLCRoutingDecodeErrorZ {
	CResult_PendingHTLCRoutingDecodeErrorZ {
		contents: CResult_PendingHTLCRoutingDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCRoutingDecodeErrorZ in the error state.
pub extern "C" fn CResult_PendingHTLCRoutingDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PendingHTLCRoutingDecodeErrorZ {
	CResult_PendingHTLCRoutingDecodeErrorZ {
		contents: CResult_PendingHTLCRoutingDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PendingHTLCRoutingDecodeErrorZ_is_ok(o: &CResult_PendingHTLCRoutingDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PendingHTLCRoutingDecodeErrorZ.
pub extern "C" fn CResult_PendingHTLCRoutingDecodeErrorZ_free(_res: CResult_PendingHTLCRoutingDecodeErrorZ) { }
impl Drop for CResult_PendingHTLCRoutingDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCRouting, crate::lightning::ln::msgs::DecodeError>> for CResult_PendingHTLCRoutingDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCRouting, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PendingHTLCRoutingDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PendingHTLCRoutingDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PendingHTLCRoutingDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PendingHTLCRoutingDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::PendingHTLCRouting>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PendingHTLCRoutingDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCRoutingDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PendingHTLCRoutingDecodeErrorZ_clone(orig: &CResult_PendingHTLCRoutingDecodeErrorZ) -> CResult_PendingHTLCRoutingDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PendingHTLCInfoDecodeErrorZ
pub union CResult_PendingHTLCInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::PendingHTLCInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PendingHTLCInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::PendingHTLCInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PendingHTLCInfoDecodeErrorZ {
	/// The contents of this CResult_PendingHTLCInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PendingHTLCInfoDecodeErrorZPtr,
	/// Whether this CResult_PendingHTLCInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_PendingHTLCInfoDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::PendingHTLCInfo) -> CResult_PendingHTLCInfoDecodeErrorZ {
	CResult_PendingHTLCInfoDecodeErrorZ {
		contents: CResult_PendingHTLCInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_PendingHTLCInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PendingHTLCInfoDecodeErrorZ {
	CResult_PendingHTLCInfoDecodeErrorZ {
		contents: CResult_PendingHTLCInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PendingHTLCInfoDecodeErrorZ_is_ok(o: &CResult_PendingHTLCInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PendingHTLCInfoDecodeErrorZ.
pub extern "C" fn CResult_PendingHTLCInfoDecodeErrorZ_free(_res: CResult_PendingHTLCInfoDecodeErrorZ) { }
impl Drop for CResult_PendingHTLCInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_PendingHTLCInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PendingHTLCInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PendingHTLCInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PendingHTLCInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PendingHTLCInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::PendingHTLCInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PendingHTLCInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PendingHTLCInfoDecodeErrorZ_clone(orig: &CResult_PendingHTLCInfoDecodeErrorZ) -> CResult_PendingHTLCInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedFailureDecodeErrorZ
pub union CResult_BlindedFailureDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::BlindedFailure,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedFailureDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::BlindedFailure on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedFailureDecodeErrorZ {
	/// The contents of this CResult_BlindedFailureDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedFailureDecodeErrorZPtr,
	/// Whether this CResult_BlindedFailureDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedFailureDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedFailureDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::BlindedFailure) -> CResult_BlindedFailureDecodeErrorZ {
	CResult_BlindedFailureDecodeErrorZ {
		contents: CResult_BlindedFailureDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedFailureDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedFailureDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedFailureDecodeErrorZ {
	CResult_BlindedFailureDecodeErrorZ {
		contents: CResult_BlindedFailureDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedFailureDecodeErrorZ_is_ok(o: &CResult_BlindedFailureDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedFailureDecodeErrorZ.
pub extern "C" fn CResult_BlindedFailureDecodeErrorZ_free(_res: CResult_BlindedFailureDecodeErrorZ) { }
impl Drop for CResult_BlindedFailureDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::BlindedFailure, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedFailureDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::BlindedFailure, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedFailureDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedFailureDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedFailureDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedFailureDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::BlindedFailure>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedFailureDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedFailureDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedFailureDecodeErrorZ_clone(orig: &CResult_BlindedFailureDecodeErrorZ) -> CResult_BlindedFailureDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::chain::channelmonitor::ChannelMonitors of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ChannelMonitorZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::chain::channelmonitor::ChannelMonitor,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ChannelMonitorZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::chain::channelmonitor::ChannelMonitor> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::chain::channelmonitor::ChannelMonitor] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::chain::channelmonitor::ChannelMonitor>> for CVec_ChannelMonitorZ {
	fn from(v: Vec<crate::lightning::chain::channelmonitor::ChannelMonitor>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ChannelMonitorZ_free(_res: CVec_ChannelMonitorZ) { }
impl Drop for CVec_ChannelMonitorZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ChannelMonitorZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesChannelManagerZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::lightning::ln::channelmanager::ChannelManager,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::lightning::ln::channelmanager::ChannelManager)> for C2Tuple_ThirtyTwoBytesChannelManagerZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::lightning::ln::channelmanager::ChannelManager)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesChannelManagerZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::lightning::ln::channelmanager::ChannelManager) {
		(self.a, self.b)
	}
}
/// Creates a new C2Tuple_ThirtyTwoBytesChannelManagerZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelManagerZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::lightning::ln::channelmanager::ChannelManager) -> C2Tuple_ThirtyTwoBytesChannelManagerZ {
	C2Tuple_ThirtyTwoBytesChannelManagerZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesChannelManagerZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelManagerZ_free(_res: C2Tuple_ThirtyTwoBytesChannelManagerZ) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ
pub union CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	/// The contents of this CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr,
	/// Whether this CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ in the success state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_ok(o: crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ) -> CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ in the error state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_is_ok(o: &CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_free(_res: CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ) { }
impl Drop for CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ, crate::lightning::ln::msgs::DecodeError>> for CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_MaxDustHTLCExposureDecodeErrorZ
pub union CResult_MaxDustHTLCExposureDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::config::MaxDustHTLCExposure,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_MaxDustHTLCExposureDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::config::MaxDustHTLCExposure on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_MaxDustHTLCExposureDecodeErrorZ {
	/// The contents of this CResult_MaxDustHTLCExposureDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_MaxDustHTLCExposureDecodeErrorZPtr,
	/// Whether this CResult_MaxDustHTLCExposureDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_MaxDustHTLCExposureDecodeErrorZ in the success state.
pub extern "C" fn CResult_MaxDustHTLCExposureDecodeErrorZ_ok(o: crate::lightning::util::config::MaxDustHTLCExposure) -> CResult_MaxDustHTLCExposureDecodeErrorZ {
	CResult_MaxDustHTLCExposureDecodeErrorZ {
		contents: CResult_MaxDustHTLCExposureDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_MaxDustHTLCExposureDecodeErrorZ in the error state.
pub extern "C" fn CResult_MaxDustHTLCExposureDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_MaxDustHTLCExposureDecodeErrorZ {
	CResult_MaxDustHTLCExposureDecodeErrorZ {
		contents: CResult_MaxDustHTLCExposureDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_MaxDustHTLCExposureDecodeErrorZ_is_ok(o: &CResult_MaxDustHTLCExposureDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_MaxDustHTLCExposureDecodeErrorZ.
pub extern "C" fn CResult_MaxDustHTLCExposureDecodeErrorZ_free(_res: CResult_MaxDustHTLCExposureDecodeErrorZ) { }
impl Drop for CResult_MaxDustHTLCExposureDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::config::MaxDustHTLCExposure, crate::lightning::ln::msgs::DecodeError>> for CResult_MaxDustHTLCExposureDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::config::MaxDustHTLCExposure, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_MaxDustHTLCExposureDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_MaxDustHTLCExposureDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_MaxDustHTLCExposureDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_MaxDustHTLCExposureDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::config::MaxDustHTLCExposure>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_MaxDustHTLCExposureDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_MaxDustHTLCExposureDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_MaxDustHTLCExposureDecodeErrorZ_clone(orig: &CResult_MaxDustHTLCExposureDecodeErrorZ) -> CResult_MaxDustHTLCExposureDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelConfigDecodeErrorZ
pub union CResult_ChannelConfigDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::config::ChannelConfig,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelConfigDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::config::ChannelConfig on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelConfigDecodeErrorZ {
	/// The contents of this CResult_ChannelConfigDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelConfigDecodeErrorZPtr,
	/// Whether this CResult_ChannelConfigDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelConfigDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelConfigDecodeErrorZ_ok(o: crate::lightning::util::config::ChannelConfig) -> CResult_ChannelConfigDecodeErrorZ {
	CResult_ChannelConfigDecodeErrorZ {
		contents: CResult_ChannelConfigDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelConfigDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelConfigDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelConfigDecodeErrorZ {
	CResult_ChannelConfigDecodeErrorZ {
		contents: CResult_ChannelConfigDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelConfigDecodeErrorZ_is_ok(o: &CResult_ChannelConfigDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelConfigDecodeErrorZ.
pub extern "C" fn CResult_ChannelConfigDecodeErrorZ_free(_res: CResult_ChannelConfigDecodeErrorZ) { }
impl Drop for CResult_ChannelConfigDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::config::ChannelConfig, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelConfigDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::config::ChannelConfig, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelConfigDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelConfigDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelConfigDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelConfigDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::config::ChannelConfig>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelConfigDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelConfigDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelConfigDecodeErrorZ_clone(orig: &CResult_ChannelConfigDecodeErrorZ) -> CResult_ChannelConfigDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::util::config::MaxDustHTLCExposure or not
pub enum COption_MaxDustHTLCExposureZ {
	/// When we're in this state, this COption_MaxDustHTLCExposureZ contains a crate::lightning::util::config::MaxDustHTLCExposure
	Some(crate::lightning::util::config::MaxDustHTLCExposure),
	/// When we're in this state, this COption_MaxDustHTLCExposureZ contains nothing
	None
}
impl COption_MaxDustHTLCExposureZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::util::config::MaxDustHTLCExposure {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_MaxDustHTLCExposureZ containing a crate::lightning::util::config::MaxDustHTLCExposure
pub extern "C" fn COption_MaxDustHTLCExposureZ_some(o: crate::lightning::util::config::MaxDustHTLCExposure) -> COption_MaxDustHTLCExposureZ {
	COption_MaxDustHTLCExposureZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_MaxDustHTLCExposureZ containing nothing
pub extern "C" fn COption_MaxDustHTLCExposureZ_none() -> COption_MaxDustHTLCExposureZ {
	COption_MaxDustHTLCExposureZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::util::config::MaxDustHTLCExposure, if we are in the Some state
pub extern "C" fn COption_MaxDustHTLCExposureZ_free(_res: COption_MaxDustHTLCExposureZ) { }
#[no_mangle]
/// Creates a new COption_MaxDustHTLCExposureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_MaxDustHTLCExposureZ_clone(orig: &COption_MaxDustHTLCExposureZ) -> COption_MaxDustHTLCExposureZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::util::errors::APIError or not
pub enum COption_APIErrorZ {
	/// When we're in this state, this COption_APIErrorZ contains a crate::lightning::util::errors::APIError
	Some(crate::lightning::util::errors::APIError),
	/// When we're in this state, this COption_APIErrorZ contains nothing
	None
}
impl COption_APIErrorZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::util::errors::APIError {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_APIErrorZ containing a crate::lightning::util::errors::APIError
pub extern "C" fn COption_APIErrorZ_some(o: crate::lightning::util::errors::APIError) -> COption_APIErrorZ {
	COption_APIErrorZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_APIErrorZ containing nothing
pub extern "C" fn COption_APIErrorZ_none() -> COption_APIErrorZ {
	COption_APIErrorZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::util::errors::APIError, if we are in the Some state
pub extern "C" fn COption_APIErrorZ_free(_res: COption_APIErrorZ) { }
#[no_mangle]
/// Creates a new COption_APIErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_APIErrorZ_clone(orig: &COption_APIErrorZ) -> COption_APIErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_APIErrorZDecodeErrorZ
pub union CResult_COption_APIErrorZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_APIErrorZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_APIErrorZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_APIErrorZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_APIErrorZDecodeErrorZ {
	/// The contents of this CResult_COption_APIErrorZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_APIErrorZDecodeErrorZPtr,
	/// Whether this CResult_COption_APIErrorZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_APIErrorZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_APIErrorZDecodeErrorZ_ok(o: crate::c_types::derived::COption_APIErrorZ) -> CResult_COption_APIErrorZDecodeErrorZ {
	CResult_COption_APIErrorZDecodeErrorZ {
		contents: CResult_COption_APIErrorZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_APIErrorZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_APIErrorZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_APIErrorZDecodeErrorZ {
	CResult_COption_APIErrorZDecodeErrorZ {
		contents: CResult_COption_APIErrorZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_APIErrorZDecodeErrorZ_is_ok(o: &CResult_COption_APIErrorZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_APIErrorZDecodeErrorZ.
pub extern "C" fn CResult_COption_APIErrorZDecodeErrorZ_free(_res: CResult_COption_APIErrorZDecodeErrorZ) { }
impl Drop for CResult_COption_APIErrorZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_APIErrorZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_APIErrorZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_APIErrorZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_APIErrorZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_APIErrorZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_APIErrorZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_APIErrorZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_APIErrorZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_APIErrorZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_APIErrorZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_APIErrorZDecodeErrorZ_clone(orig: &CResult_COption_APIErrorZDecodeErrorZ) -> CResult_COption_APIErrorZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelMonitorUpdateDecodeErrorZ
pub union CResult_ChannelMonitorUpdateDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::channelmonitor::ChannelMonitorUpdate,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelMonitorUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::channelmonitor::ChannelMonitorUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelMonitorUpdateDecodeErrorZ {
	/// The contents of this CResult_ChannelMonitorUpdateDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelMonitorUpdateDecodeErrorZPtr,
	/// Whether this CResult_ChannelMonitorUpdateDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelMonitorUpdateDecodeErrorZ_ok(o: crate::lightning::chain::channelmonitor::ChannelMonitorUpdate) -> CResult_ChannelMonitorUpdateDecodeErrorZ {
	CResult_ChannelMonitorUpdateDecodeErrorZ {
		contents: CResult_ChannelMonitorUpdateDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelMonitorUpdateDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelMonitorUpdateDecodeErrorZ {
	CResult_ChannelMonitorUpdateDecodeErrorZ {
		contents: CResult_ChannelMonitorUpdateDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(o: &CResult_ChannelMonitorUpdateDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelMonitorUpdateDecodeErrorZ.
pub extern "C" fn CResult_ChannelMonitorUpdateDecodeErrorZ_free(_res: CResult_ChannelMonitorUpdateDecodeErrorZ) { }
impl Drop for CResult_ChannelMonitorUpdateDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::channelmonitor::ChannelMonitorUpdate, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelMonitorUpdateDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::channelmonitor::ChannelMonitorUpdate, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelMonitorUpdateDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelMonitorUpdateDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelMonitorUpdateDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelMonitorUpdateDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::chain::channelmonitor::ChannelMonitorUpdate>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelMonitorUpdateDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelMonitorUpdateDecodeErrorZ_clone(orig: &CResult_ChannelMonitorUpdateDecodeErrorZ) -> CResult_ChannelMonitorUpdateDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::chain::channelmonitor::MonitorEvent or not
pub enum COption_MonitorEventZ {
	/// When we're in this state, this COption_MonitorEventZ contains a crate::lightning::chain::channelmonitor::MonitorEvent
	Some(crate::lightning::chain::channelmonitor::MonitorEvent),
	/// When we're in this state, this COption_MonitorEventZ contains nothing
	None
}
impl COption_MonitorEventZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::chain::channelmonitor::MonitorEvent {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_MonitorEventZ containing a crate::lightning::chain::channelmonitor::MonitorEvent
pub extern "C" fn COption_MonitorEventZ_some(o: crate::lightning::chain::channelmonitor::MonitorEvent) -> COption_MonitorEventZ {
	COption_MonitorEventZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_MonitorEventZ containing nothing
pub extern "C" fn COption_MonitorEventZ_none() -> COption_MonitorEventZ {
	COption_MonitorEventZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::chain::channelmonitor::MonitorEvent, if we are in the Some state
pub extern "C" fn COption_MonitorEventZ_free(_res: COption_MonitorEventZ) { }
#[no_mangle]
/// Creates a new COption_MonitorEventZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_MonitorEventZ_clone(orig: &COption_MonitorEventZ) -> COption_MonitorEventZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_MonitorEventZDecodeErrorZ
pub union CResult_COption_MonitorEventZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_MonitorEventZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_MonitorEventZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_MonitorEventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_MonitorEventZDecodeErrorZ {
	/// The contents of this CResult_COption_MonitorEventZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_MonitorEventZDecodeErrorZPtr,
	/// Whether this CResult_COption_MonitorEventZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_MonitorEventZDecodeErrorZ_ok(o: crate::c_types::derived::COption_MonitorEventZ) -> CResult_COption_MonitorEventZDecodeErrorZ {
	CResult_COption_MonitorEventZDecodeErrorZ {
		contents: CResult_COption_MonitorEventZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_MonitorEventZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_MonitorEventZDecodeErrorZ {
	CResult_COption_MonitorEventZDecodeErrorZ {
		contents: CResult_COption_MonitorEventZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_MonitorEventZDecodeErrorZ_is_ok(o: &CResult_COption_MonitorEventZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_MonitorEventZDecodeErrorZ.
pub extern "C" fn CResult_COption_MonitorEventZDecodeErrorZ_free(_res: CResult_COption_MonitorEventZDecodeErrorZ) { }
impl Drop for CResult_COption_MonitorEventZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_MonitorEventZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_MonitorEventZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_MonitorEventZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_MonitorEventZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_MonitorEventZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_MonitorEventZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_MonitorEventZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_MonitorEventZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_MonitorEventZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_MonitorEventZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_MonitorEventZDecodeErrorZ_clone(orig: &CResult_COption_MonitorEventZDecodeErrorZ) -> CResult_COption_MonitorEventZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HTLCUpdateDecodeErrorZ
pub union CResult_HTLCUpdateDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::channelmonitor::HTLCUpdate,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HTLCUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::channelmonitor::HTLCUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HTLCUpdateDecodeErrorZ {
	/// The contents of this CResult_HTLCUpdateDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HTLCUpdateDecodeErrorZPtr,
	/// Whether this CResult_HTLCUpdateDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HTLCUpdateDecodeErrorZ in the success state.
pub extern "C" fn CResult_HTLCUpdateDecodeErrorZ_ok(o: crate::lightning::chain::channelmonitor::HTLCUpdate) -> CResult_HTLCUpdateDecodeErrorZ {
	CResult_HTLCUpdateDecodeErrorZ {
		contents: CResult_HTLCUpdateDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCUpdateDecodeErrorZ in the error state.
pub extern "C" fn CResult_HTLCUpdateDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HTLCUpdateDecodeErrorZ {
	CResult_HTLCUpdateDecodeErrorZ {
		contents: CResult_HTLCUpdateDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HTLCUpdateDecodeErrorZ_is_ok(o: &CResult_HTLCUpdateDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HTLCUpdateDecodeErrorZ.
pub extern "C" fn CResult_HTLCUpdateDecodeErrorZ_free(_res: CResult_HTLCUpdateDecodeErrorZ) { }
impl Drop for CResult_HTLCUpdateDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::channelmonitor::HTLCUpdate, crate::lightning::ln::msgs::DecodeError>> for CResult_HTLCUpdateDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::channelmonitor::HTLCUpdate, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HTLCUpdateDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HTLCUpdateDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HTLCUpdateDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HTLCUpdateDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::chain::channelmonitor::HTLCUpdate>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HTLCUpdateDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCUpdateDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HTLCUpdateDecodeErrorZ_clone(orig: &CResult_HTLCUpdateDecodeErrorZ) -> CResult_HTLCUpdateDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_OutPointCVec_u8ZZ {
	/// The element at position 0
	pub a: crate::lightning::chain::transaction::OutPoint,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_u8Z,
}
impl From<(crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_u8Z)> for C2Tuple_OutPointCVec_u8ZZ {
	fn from (tup: (crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_u8Z)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_OutPointCVec_u8ZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_u8Z) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_OutPointCVec_u8ZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_OutPointCVec_u8ZZ_clone(orig: &C2Tuple_OutPointCVec_u8ZZ) -> C2Tuple_OutPointCVec_u8ZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_OutPointCVec_u8ZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_OutPointCVec_u8ZZ_new(a: crate::lightning::chain::transaction::OutPoint, b: crate::c_types::derived::CVec_u8Z) -> C2Tuple_OutPointCVec_u8ZZ {
	C2Tuple_OutPointCVec_u8ZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_OutPointCVec_u8ZZ.
pub extern "C" fn C2Tuple_OutPointCVec_u8ZZ_free(_res: C2Tuple_OutPointCVec_u8ZZ) { }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_u32CVec_u8ZZ {
	/// The element at position 0
	pub a: u32,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_u8Z,
}
impl From<(u32, crate::c_types::derived::CVec_u8Z)> for C2Tuple_u32CVec_u8ZZ {
	fn from (tup: (u32, crate::c_types::derived::CVec_u8Z)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_u32CVec_u8ZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (u32, crate::c_types::derived::CVec_u8Z) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_u32CVec_u8ZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_u32CVec_u8ZZ_clone(orig: &C2Tuple_u32CVec_u8ZZ) -> C2Tuple_u32CVec_u8ZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_u32CVec_u8ZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_u32CVec_u8ZZ_new(a: u32, b: crate::c_types::derived::CVec_u8Z) -> C2Tuple_u32CVec_u8ZZ {
	C2Tuple_u32CVec_u8ZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_u32CVec_u8ZZ.
pub extern "C" fn C2Tuple_u32CVec_u8ZZ_free(_res: C2Tuple_u32CVec_u8ZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32CVec_u8ZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_u32CVec_u8ZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_u32CVec_u8ZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_u32CVec_u8ZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_u32CVec_u8ZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_u32CVec_u8ZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_u32CVec_u8ZZ>> for CVec_C2Tuple_u32CVec_u8ZZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_u32CVec_u8ZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_u32CVec_u8ZZZ_free(_res: CVec_C2Tuple_u32CVec_u8ZZZ) { }
impl Drop for CVec_C2Tuple_u32CVec_u8ZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_u32CVec_u8ZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_C2Tuple_u32CVec_u8ZZZ,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32CVec_u8ZZZ)> for C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32CVec_u8ZZZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32CVec_u8ZZZ) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ_clone(orig: &C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ) -> C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::c_types::derived::CVec_C2Tuple_u32CVec_u8ZZZ) -> C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
	C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ_free(_res: C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ>> for CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ_free(_res: CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ) { }
impl Drop for CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_NoneReplayEventZ
pub union CResult_NoneReplayEventZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::events::ReplayEvent,
}
#[repr(C)]
/// A CResult_NoneReplayEventZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::events::ReplayEvent on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneReplayEventZ {
	/// The contents of this CResult_NoneReplayEventZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneReplayEventZPtr,
	/// Whether this CResult_NoneReplayEventZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneReplayEventZ in the success state.
pub extern "C" fn CResult_NoneReplayEventZ_ok() -> CResult_NoneReplayEventZ {
	CResult_NoneReplayEventZ {
		contents: CResult_NoneReplayEventZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneReplayEventZ in the error state.
pub extern "C" fn CResult_NoneReplayEventZ_err(e: crate::lightning::events::ReplayEvent) -> CResult_NoneReplayEventZ {
	CResult_NoneReplayEventZ {
		contents: CResult_NoneReplayEventZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneReplayEventZ_is_ok(o: &CResult_NoneReplayEventZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneReplayEventZ.
pub extern "C" fn CResult_NoneReplayEventZ_free(_res: CResult_NoneReplayEventZ) { }
impl Drop for CResult_NoneReplayEventZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::events::ReplayEvent>> for CResult_NoneReplayEventZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::events::ReplayEvent>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneReplayEventZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneReplayEventZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneReplayEventZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneReplayEventZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneReplayEventZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::events::ReplayEvent>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneReplayEventZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneReplayEventZ_clone(orig: &CResult_NoneReplayEventZ) -> CResult_NoneReplayEventZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::chan_utils::CommitmentTransactions of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_CommitmentTransactionZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::chan_utils::CommitmentTransaction,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_CommitmentTransactionZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::chan_utils::CommitmentTransaction> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::chan_utils::CommitmentTransaction] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::chan_utils::CommitmentTransaction>> for CVec_CommitmentTransactionZ {
	fn from(v: Vec<crate::lightning::ln::chan_utils::CommitmentTransaction>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_CommitmentTransactionZ_free(_res: CVec_CommitmentTransactionZ) { }
impl Drop for CVec_CommitmentTransactionZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_CommitmentTransactionZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_u32TxOutZ {
	/// The element at position 0
	pub a: u32,
	/// The element at position 1
	pub b: crate::c_types::TxOut,
}
impl From<(u32, crate::c_types::TxOut)> for C2Tuple_u32TxOutZ {
	fn from (tup: (u32, crate::c_types::TxOut)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_u32TxOutZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (u32, crate::c_types::TxOut) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_u32TxOutZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_u32TxOutZ_clone(orig: &C2Tuple_u32TxOutZ) -> C2Tuple_u32TxOutZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_u32TxOutZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_u32TxOutZ_new(a: u32, b: crate::c_types::TxOut) -> C2Tuple_u32TxOutZ {
	C2Tuple_u32TxOutZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_u32TxOutZ.
pub extern "C" fn C2Tuple_u32TxOutZ_free(_res: C2Tuple_u32TxOutZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32TxOutZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_u32TxOutZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_u32TxOutZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_u32TxOutZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_u32TxOutZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_u32TxOutZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_u32TxOutZ>> for CVec_C2Tuple_u32TxOutZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_u32TxOutZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_u32TxOutZZ_free(_res: CVec_C2Tuple_u32TxOutZZ) { }
impl Drop for CVec_C2Tuple_u32TxOutZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_u32TxOutZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_C2Tuple_u32TxOutZZ,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32TxOutZZ)> for C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32TxOutZZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32TxOutZZ) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ_clone(orig: &C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ) -> C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::c_types::derived::CVec_C2Tuple_u32TxOutZZ) -> C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
	C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ_free(_res: C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_TransactionOutputsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_TransactionOutputsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ>> for CVec_TransactionOutputsZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_TransactionOutputsZ_free(_res: CVec_TransactionOutputsZ) { }
impl Drop for CVec_TransactionOutputsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_TransactionOutputsZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_boolboolZ {
	/// The element at position 0
	pub a: bool,
	/// The element at position 1
	pub b: bool,
}
impl From<(bool, bool)> for C2Tuple_boolboolZ {
	fn from (tup: (bool, bool)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_boolboolZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (bool, bool) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_boolboolZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_boolboolZ_clone(orig: &C2Tuple_boolboolZ) -> C2Tuple_boolboolZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_boolboolZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_boolboolZ_new(a: bool, b: bool) -> C2Tuple_boolboolZ {
	C2Tuple_boolboolZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_boolboolZ.
pub extern "C" fn C2Tuple_boolboolZ_free(_res: C2Tuple_boolboolZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::chain::channelmonitor::Balances of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_BalanceZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::chain::channelmonitor::Balance,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_BalanceZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::chain::channelmonitor::Balance> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::chain::channelmonitor::Balance] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::chain::channelmonitor::Balance>> for CVec_BalanceZ {
	fn from(v: Vec<crate::lightning::chain::channelmonitor::Balance>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_BalanceZ_free(_res: CVec_BalanceZ) { }
impl Drop for CVec_BalanceZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_BalanceZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesChannelMonitorZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::lightning::chain::channelmonitor::ChannelMonitor,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::lightning::chain::channelmonitor::ChannelMonitor)> for C2Tuple_ThirtyTwoBytesChannelMonitorZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::lightning::chain::channelmonitor::ChannelMonitor)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesChannelMonitorZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::lightning::chain::channelmonitor::ChannelMonitor) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ThirtyTwoBytesChannelMonitorZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelMonitorZ_clone(orig: &C2Tuple_ThirtyTwoBytesChannelMonitorZ) -> C2Tuple_ThirtyTwoBytesChannelMonitorZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ThirtyTwoBytesChannelMonitorZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelMonitorZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::lightning::chain::channelmonitor::ChannelMonitor) -> C2Tuple_ThirtyTwoBytesChannelMonitorZ {
	C2Tuple_ThirtyTwoBytesChannelMonitorZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesChannelMonitorZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelMonitorZ_free(_res: C2Tuple_ThirtyTwoBytesChannelMonitorZ) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ
pub union CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	/// The contents of this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr,
	/// Whether this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ in the success state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_ok(o: crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ in the error state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_is_ok(o: &CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_free(_res: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ) { }
impl Drop for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ, crate::lightning::ln::msgs::DecodeError>> for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_clone(orig: &CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_PublicKeyTypeZ {
	/// The element at position 0
	pub a: crate::c_types::PublicKey,
	/// The element at position 1
	pub b: crate::lightning::ln::wire::Type,
}
impl From<(crate::c_types::PublicKey, crate::lightning::ln::wire::Type)> for C2Tuple_PublicKeyTypeZ {
	fn from (tup: (crate::c_types::PublicKey, crate::lightning::ln::wire::Type)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_PublicKeyTypeZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::PublicKey, crate::lightning::ln::wire::Type) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_PublicKeyTypeZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_PublicKeyTypeZ_clone(orig: &C2Tuple_PublicKeyTypeZ) -> C2Tuple_PublicKeyTypeZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_PublicKeyTypeZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_PublicKeyTypeZ_new(a: crate::c_types::PublicKey, b: crate::lightning::ln::wire::Type) -> C2Tuple_PublicKeyTypeZ {
	C2Tuple_PublicKeyTypeZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_PublicKeyTypeZ.
pub extern "C" fn C2Tuple_PublicKeyTypeZ_free(_res: C2Tuple_PublicKeyTypeZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_PublicKeyTypeZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_PublicKeyTypeZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_PublicKeyTypeZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_PublicKeyTypeZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_PublicKeyTypeZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_PublicKeyTypeZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_PublicKeyTypeZ>> for CVec_C2Tuple_PublicKeyTypeZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_PublicKeyTypeZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_PublicKeyTypeZZ_free(_res: CVec_C2Tuple_PublicKeyTypeZZ) { }
impl Drop for CVec_C2Tuple_PublicKeyTypeZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_PublicKeyTypeZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_OnionMessageContentsResponseInstructionZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::packet::OnionMessageContents,
	/// The element at position 1
	pub b: crate::lightning::onion_message::messenger::ResponseInstruction,
}
impl From<(crate::lightning::onion_message::packet::OnionMessageContents, crate::lightning::onion_message::messenger::ResponseInstruction)> for C2Tuple_OnionMessageContentsResponseInstructionZ {
	fn from (tup: (crate::lightning::onion_message::packet::OnionMessageContents, crate::lightning::onion_message::messenger::ResponseInstruction)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_OnionMessageContentsResponseInstructionZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::packet::OnionMessageContents, crate::lightning::onion_message::messenger::ResponseInstruction) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_OnionMessageContentsResponseInstructionZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_OnionMessageContentsResponseInstructionZ_clone(orig: &C2Tuple_OnionMessageContentsResponseInstructionZ) -> C2Tuple_OnionMessageContentsResponseInstructionZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_OnionMessageContentsResponseInstructionZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_OnionMessageContentsResponseInstructionZ_new(a: crate::lightning::onion_message::packet::OnionMessageContents, b: crate::lightning::onion_message::messenger::ResponseInstruction) -> C2Tuple_OnionMessageContentsResponseInstructionZ {
	C2Tuple_OnionMessageContentsResponseInstructionZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_OnionMessageContentsResponseInstructionZ.
pub extern "C" fn C2Tuple_OnionMessageContentsResponseInstructionZ_free(_res: C2Tuple_OnionMessageContentsResponseInstructionZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_OnionMessageContentsResponseInstructionZ or not
pub enum COption_C2Tuple_OnionMessageContentsResponseInstructionZZ {
	/// When we're in this state, this COption_C2Tuple_OnionMessageContentsResponseInstructionZZ contains a crate::c_types::derived::C2Tuple_OnionMessageContentsResponseInstructionZ
	Some(crate::c_types::derived::C2Tuple_OnionMessageContentsResponseInstructionZ),
	/// When we're in this state, this COption_C2Tuple_OnionMessageContentsResponseInstructionZZ contains nothing
	None
}
impl COption_C2Tuple_OnionMessageContentsResponseInstructionZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_OnionMessageContentsResponseInstructionZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_OnionMessageContentsResponseInstructionZZ containing a crate::c_types::derived::C2Tuple_OnionMessageContentsResponseInstructionZ
pub extern "C" fn COption_C2Tuple_OnionMessageContentsResponseInstructionZZ_some(o: crate::c_types::derived::C2Tuple_OnionMessageContentsResponseInstructionZ) -> COption_C2Tuple_OnionMessageContentsResponseInstructionZZ {
	COption_C2Tuple_OnionMessageContentsResponseInstructionZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_OnionMessageContentsResponseInstructionZZ containing nothing
pub extern "C" fn COption_C2Tuple_OnionMessageContentsResponseInstructionZZ_none() -> COption_C2Tuple_OnionMessageContentsResponseInstructionZZ {
	COption_C2Tuple_OnionMessageContentsResponseInstructionZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_OnionMessageContentsResponseInstructionZ, if we are in the Some state
pub extern "C" fn COption_C2Tuple_OnionMessageContentsResponseInstructionZZ_free(_res: COption_C2Tuple_OnionMessageContentsResponseInstructionZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_OnionMessageContentsResponseInstructionZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_OnionMessageContentsResponseInstructionZZ_clone(orig: &COption_C2Tuple_OnionMessageContentsResponseInstructionZZ) -> COption_C2Tuple_OnionMessageContentsResponseInstructionZZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::onion_message::packet::OnionMessageContents or not
pub enum COption_OnionMessageContentsZ {
	/// When we're in this state, this COption_OnionMessageContentsZ contains a crate::lightning::onion_message::packet::OnionMessageContents
	Some(crate::lightning::onion_message::packet::OnionMessageContents),
	/// When we're in this state, this COption_OnionMessageContentsZ contains nothing
	None
}
impl COption_OnionMessageContentsZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::onion_message::packet::OnionMessageContents {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_OnionMessageContentsZ containing a crate::lightning::onion_message::packet::OnionMessageContents
pub extern "C" fn COption_OnionMessageContentsZ_some(o: crate::lightning::onion_message::packet::OnionMessageContents) -> COption_OnionMessageContentsZ {
	COption_OnionMessageContentsZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_OnionMessageContentsZ containing nothing
pub extern "C" fn COption_OnionMessageContentsZ_none() -> COption_OnionMessageContentsZ {
	COption_OnionMessageContentsZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::onion_message::packet::OnionMessageContents, if we are in the Some state
pub extern "C" fn COption_OnionMessageContentsZ_free(_res: COption_OnionMessageContentsZ) { }
#[no_mangle]
/// Creates a new COption_OnionMessageContentsZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_OnionMessageContentsZ_clone(orig: &COption_OnionMessageContentsZ) -> COption_OnionMessageContentsZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_OnionMessageContentsZDecodeErrorZ
pub union CResult_COption_OnionMessageContentsZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_OnionMessageContentsZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_OnionMessageContentsZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_OnionMessageContentsZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_OnionMessageContentsZDecodeErrorZ {
	/// The contents of this CResult_COption_OnionMessageContentsZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_OnionMessageContentsZDecodeErrorZPtr,
	/// Whether this CResult_COption_OnionMessageContentsZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_OnionMessageContentsZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_OnionMessageContentsZDecodeErrorZ_ok(o: crate::c_types::derived::COption_OnionMessageContentsZ) -> CResult_COption_OnionMessageContentsZDecodeErrorZ {
	CResult_COption_OnionMessageContentsZDecodeErrorZ {
		contents: CResult_COption_OnionMessageContentsZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_OnionMessageContentsZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_OnionMessageContentsZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_OnionMessageContentsZDecodeErrorZ {
	CResult_COption_OnionMessageContentsZDecodeErrorZ {
		contents: CResult_COption_OnionMessageContentsZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_OnionMessageContentsZDecodeErrorZ_is_ok(o: &CResult_COption_OnionMessageContentsZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_OnionMessageContentsZDecodeErrorZ.
pub extern "C" fn CResult_COption_OnionMessageContentsZDecodeErrorZ_free(_res: CResult_COption_OnionMessageContentsZDecodeErrorZ) { }
impl Drop for CResult_COption_OnionMessageContentsZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_OnionMessageContentsZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_OnionMessageContentsZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_OnionMessageContentsZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_OnionMessageContentsZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_OnionMessageContentsZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_OnionMessageContentsZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_OnionMessageContentsZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_OnionMessageContentsZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_OnionMessageContentsZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_OnionMessageContentsZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_OnionMessageContentsZDecodeErrorZ_clone(orig: &CResult_COption_OnionMessageContentsZDecodeErrorZ) -> CResult_COption_OnionMessageContentsZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_OnionMessageContentsMessageSendInstructionsZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::packet::OnionMessageContents,
	/// The element at position 1
	pub b: crate::lightning::onion_message::messenger::MessageSendInstructions,
}
impl From<(crate::lightning::onion_message::packet::OnionMessageContents, crate::lightning::onion_message::messenger::MessageSendInstructions)> for C2Tuple_OnionMessageContentsMessageSendInstructionsZ {
	fn from (tup: (crate::lightning::onion_message::packet::OnionMessageContents, crate::lightning::onion_message::messenger::MessageSendInstructions)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_OnionMessageContentsMessageSendInstructionsZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::packet::OnionMessageContents, crate::lightning::onion_message::messenger::MessageSendInstructions) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_OnionMessageContentsMessageSendInstructionsZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_OnionMessageContentsMessageSendInstructionsZ_clone(orig: &C2Tuple_OnionMessageContentsMessageSendInstructionsZ) -> C2Tuple_OnionMessageContentsMessageSendInstructionsZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_OnionMessageContentsMessageSendInstructionsZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_OnionMessageContentsMessageSendInstructionsZ_new(a: crate::lightning::onion_message::packet::OnionMessageContents, b: crate::lightning::onion_message::messenger::MessageSendInstructions) -> C2Tuple_OnionMessageContentsMessageSendInstructionsZ {
	C2Tuple_OnionMessageContentsMessageSendInstructionsZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_OnionMessageContentsMessageSendInstructionsZ.
pub extern "C" fn C2Tuple_OnionMessageContentsMessageSendInstructionsZ_free(_res: C2Tuple_OnionMessageContentsMessageSendInstructionsZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_OnionMessageContentsMessageSendInstructionsZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_OnionMessageContentsMessageSendInstructionsZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_OnionMessageContentsMessageSendInstructionsZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_OnionMessageContentsMessageSendInstructionsZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_OnionMessageContentsMessageSendInstructionsZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_OnionMessageContentsMessageSendInstructionsZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_OnionMessageContentsMessageSendInstructionsZ>> for CVec_C2Tuple_OnionMessageContentsMessageSendInstructionsZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_OnionMessageContentsMessageSendInstructionsZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_OnionMessageContentsMessageSendInstructionsZZ_free(_res: CVec_C2Tuple_OnionMessageContentsMessageSendInstructionsZZ) { }
impl Drop for CVec_C2Tuple_OnionMessageContentsMessageSendInstructionsZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_OnionMessageContentsMessageSendInstructionsZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::ln::wire::Type or not
pub enum COption_TypeZ {
	/// When we're in this state, this COption_TypeZ contains a crate::lightning::ln::wire::Type
	Some(crate::lightning::ln::wire::Type),
	/// When we're in this state, this COption_TypeZ contains nothing
	None
}
impl COption_TypeZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::ln::wire::Type {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_TypeZ containing a crate::lightning::ln::wire::Type
pub extern "C" fn COption_TypeZ_some(o: crate::lightning::ln::wire::Type) -> COption_TypeZ {
	COption_TypeZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_TypeZ containing nothing
pub extern "C" fn COption_TypeZ_none() -> COption_TypeZ {
	COption_TypeZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::ln::wire::Type, if we are in the Some state
pub extern "C" fn COption_TypeZ_free(_res: COption_TypeZ) { }
#[no_mangle]
/// Creates a new COption_TypeZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_TypeZ_clone(orig: &COption_TypeZ) -> COption_TypeZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_TypeZDecodeErrorZ
pub union CResult_COption_TypeZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_TypeZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_TypeZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_TypeZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_TypeZDecodeErrorZ {
	/// The contents of this CResult_COption_TypeZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_TypeZDecodeErrorZPtr,
	/// Whether this CResult_COption_TypeZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_TypeZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_TypeZDecodeErrorZ_ok(o: crate::c_types::derived::COption_TypeZ) -> CResult_COption_TypeZDecodeErrorZ {
	CResult_COption_TypeZDecodeErrorZ {
		contents: CResult_COption_TypeZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_TypeZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_TypeZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_TypeZDecodeErrorZ {
	CResult_COption_TypeZDecodeErrorZ {
		contents: CResult_COption_TypeZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_TypeZDecodeErrorZ_is_ok(o: &CResult_COption_TypeZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_TypeZDecodeErrorZ.
pub extern "C" fn CResult_COption_TypeZDecodeErrorZ_free(_res: CResult_COption_TypeZDecodeErrorZ) { }
impl Drop for CResult_COption_TypeZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_TypeZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_TypeZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_TypeZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_TypeZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_TypeZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_TypeZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_TypeZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_TypeZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_TypeZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_TypeZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_TypeZDecodeErrorZ_clone(orig: &CResult_COption_TypeZDecodeErrorZ) -> CResult_COption_TypeZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::ln::msgs::SocketAddress or not
pub enum COption_SocketAddressZ {
	/// When we're in this state, this COption_SocketAddressZ contains a crate::lightning::ln::msgs::SocketAddress
	Some(crate::lightning::ln::msgs::SocketAddress),
	/// When we're in this state, this COption_SocketAddressZ contains nothing
	None
}
impl COption_SocketAddressZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::ln::msgs::SocketAddress {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_SocketAddressZ containing a crate::lightning::ln::msgs::SocketAddress
pub extern "C" fn COption_SocketAddressZ_some(o: crate::lightning::ln::msgs::SocketAddress) -> COption_SocketAddressZ {
	COption_SocketAddressZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_SocketAddressZ containing nothing
pub extern "C" fn COption_SocketAddressZ_none() -> COption_SocketAddressZ {
	COption_SocketAddressZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::ln::msgs::SocketAddress, if we are in the Some state
pub extern "C" fn COption_SocketAddressZ_free(_res: COption_SocketAddressZ) { }
#[no_mangle]
/// Creates a new COption_SocketAddressZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_SocketAddressZ_clone(orig: &COption_SocketAddressZ) -> COption_SocketAddressZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::peer_handler::PeerDetailss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_PeerDetailsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::peer_handler::PeerDetails,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_PeerDetailsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::peer_handler::PeerDetails> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::peer_handler::PeerDetails] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::peer_handler::PeerDetails>> for CVec_PeerDetailsZ {
	fn from(v: Vec<crate::lightning::ln::peer_handler::PeerDetails>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_PeerDetailsZ_free(_res: CVec_PeerDetailsZ) { }
impl Drop for CVec_PeerDetailsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
#[repr(C)]
/// The contents of CResult_CVec_u8ZPeerHandleErrorZ
pub union CResult_CVec_u8ZPeerHandleErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_u8Z,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::peer_handler::PeerHandleError,
}
#[repr(C)]
/// A CResult_CVec_u8ZPeerHandleErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_u8Z on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_u8ZPeerHandleErrorZ {
	/// The contents of this CResult_CVec_u8ZPeerHandleErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_u8ZPeerHandleErrorZPtr,
	/// Whether this CResult_CVec_u8ZPeerHandleErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the success state.
pub extern "C" fn CResult_CVec_u8ZPeerHandleErrorZ_ok(o: crate::c_types::derived::CVec_u8Z) -> CResult_CVec_u8ZPeerHandleErrorZ {
	CResult_CVec_u8ZPeerHandleErrorZ {
		contents: CResult_CVec_u8ZPeerHandleErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the error state.
pub extern "C" fn CResult_CVec_u8ZPeerHandleErrorZ_err(e: crate::lightning::ln::peer_handler::PeerHandleError) -> CResult_CVec_u8ZPeerHandleErrorZ {
	CResult_CVec_u8ZPeerHandleErrorZ {
		contents: CResult_CVec_u8ZPeerHandleErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_u8ZPeerHandleErrorZ_is_ok(o: &CResult_CVec_u8ZPeerHandleErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_u8ZPeerHandleErrorZ.
pub extern "C" fn CResult_CVec_u8ZPeerHandleErrorZ_free(_res: CResult_CVec_u8ZPeerHandleErrorZ) { }
impl Drop for CResult_CVec_u8ZPeerHandleErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, crate::lightning::ln::peer_handler::PeerHandleError>> for CResult_CVec_u8ZPeerHandleErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, crate::lightning::ln::peer_handler::PeerHandleError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_u8ZPeerHandleErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_u8ZPeerHandleErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_u8ZPeerHandleErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_u8ZPeerHandleErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_u8Z>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_u8ZPeerHandleErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::peer_handler::PeerHandleError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZPeerHandleErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_u8ZPeerHandleErrorZ_clone(orig: &CResult_CVec_u8ZPeerHandleErrorZ) -> CResult_CVec_u8ZPeerHandleErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NonePeerHandleErrorZ
pub union CResult_NonePeerHandleErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::peer_handler::PeerHandleError,
}
#[repr(C)]
/// A CResult_NonePeerHandleErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NonePeerHandleErrorZ {
	/// The contents of this CResult_NonePeerHandleErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NonePeerHandleErrorZPtr,
	/// Whether this CResult_NonePeerHandleErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NonePeerHandleErrorZ in the success state.
pub extern "C" fn CResult_NonePeerHandleErrorZ_ok() -> CResult_NonePeerHandleErrorZ {
	CResult_NonePeerHandleErrorZ {
		contents: CResult_NonePeerHandleErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NonePeerHandleErrorZ in the error state.
pub extern "C" fn CResult_NonePeerHandleErrorZ_err(e: crate::lightning::ln::peer_handler::PeerHandleError) -> CResult_NonePeerHandleErrorZ {
	CResult_NonePeerHandleErrorZ {
		contents: CResult_NonePeerHandleErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NonePeerHandleErrorZ_is_ok(o: &CResult_NonePeerHandleErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NonePeerHandleErrorZ.
pub extern "C" fn CResult_NonePeerHandleErrorZ_free(_res: CResult_NonePeerHandleErrorZ) { }
impl Drop for CResult_NonePeerHandleErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::ln::peer_handler::PeerHandleError>> for CResult_NonePeerHandleErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::ln::peer_handler::PeerHandleError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NonePeerHandleErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NonePeerHandleErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NonePeerHandleErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NonePeerHandleErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NonePeerHandleErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::peer_handler::PeerHandleError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NonePeerHandleErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NonePeerHandleErrorZ_clone(orig: &CResult_NonePeerHandleErrorZ) -> CResult_NonePeerHandleErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_boolPeerHandleErrorZ
pub union CResult_boolPeerHandleErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut bool,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::peer_handler::PeerHandleError,
}
#[repr(C)]
/// A CResult_boolPeerHandleErrorZ represents the result of a fallible operation,
/// containing a bool on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_boolPeerHandleErrorZ {
	/// The contents of this CResult_boolPeerHandleErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_boolPeerHandleErrorZPtr,
	/// Whether this CResult_boolPeerHandleErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_boolPeerHandleErrorZ in the success state.
pub extern "C" fn CResult_boolPeerHandleErrorZ_ok(o: bool) -> CResult_boolPeerHandleErrorZ {
	CResult_boolPeerHandleErrorZ {
		contents: CResult_boolPeerHandleErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_boolPeerHandleErrorZ in the error state.
pub extern "C" fn CResult_boolPeerHandleErrorZ_err(e: crate::lightning::ln::peer_handler::PeerHandleError) -> CResult_boolPeerHandleErrorZ {
	CResult_boolPeerHandleErrorZ {
		contents: CResult_boolPeerHandleErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_boolPeerHandleErrorZ_is_ok(o: &CResult_boolPeerHandleErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_boolPeerHandleErrorZ.
pub extern "C" fn CResult_boolPeerHandleErrorZ_free(_res: CResult_boolPeerHandleErrorZ) { }
impl Drop for CResult_boolPeerHandleErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<bool, crate::lightning::ln::peer_handler::PeerHandleError>> for CResult_boolPeerHandleErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<bool, crate::lightning::ln::peer_handler::PeerHandleError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_boolPeerHandleErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_boolPeerHandleErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_boolPeerHandleErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_boolPeerHandleErrorZPtr {
				result: Box::into_raw(Box::new(<bool>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_boolPeerHandleErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::peer_handler::PeerHandleError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_boolPeerHandleErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_boolPeerHandleErrorZ_clone(orig: &CResult_boolPeerHandleErrorZ) -> CResult_boolPeerHandleErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_u32GraphSyncErrorZ
pub union CResult_u32GraphSyncErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut u32,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_rapid_gossip_sync::GraphSyncError,
}
#[repr(C)]
/// A CResult_u32GraphSyncErrorZ represents the result of a fallible operation,
/// containing a u32 on success and a crate::lightning_rapid_gossip_sync::GraphSyncError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_u32GraphSyncErrorZ {
	/// The contents of this CResult_u32GraphSyncErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_u32GraphSyncErrorZPtr,
	/// Whether this CResult_u32GraphSyncErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_u32GraphSyncErrorZ in the success state.
pub extern "C" fn CResult_u32GraphSyncErrorZ_ok(o: u32) -> CResult_u32GraphSyncErrorZ {
	CResult_u32GraphSyncErrorZ {
		contents: CResult_u32GraphSyncErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_u32GraphSyncErrorZ in the error state.
pub extern "C" fn CResult_u32GraphSyncErrorZ_err(e: crate::lightning_rapid_gossip_sync::GraphSyncError) -> CResult_u32GraphSyncErrorZ {
	CResult_u32GraphSyncErrorZ {
		contents: CResult_u32GraphSyncErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_u32GraphSyncErrorZ_is_ok(o: &CResult_u32GraphSyncErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_u32GraphSyncErrorZ.
pub extern "C" fn CResult_u32GraphSyncErrorZ_free(_res: CResult_u32GraphSyncErrorZ) { }
impl Drop for CResult_u32GraphSyncErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<u32, crate::lightning_rapid_gossip_sync::GraphSyncError>> for CResult_u32GraphSyncErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<u32, crate::lightning_rapid_gossip_sync::GraphSyncError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_u32GraphSyncErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_u32GraphSyncErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_CVec_u8ZIOErrorZ
pub union CResult_CVec_u8ZIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_u8Z,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_CVec_u8ZIOErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_u8Z on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_u8ZIOErrorZ {
	/// The contents of this CResult_CVec_u8ZIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_u8ZIOErrorZPtr,
	/// Whether this CResult_CVec_u8ZIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZIOErrorZ in the success state.
pub extern "C" fn CResult_CVec_u8ZIOErrorZ_ok(o: crate::c_types::derived::CVec_u8Z) -> CResult_CVec_u8ZIOErrorZ {
	CResult_CVec_u8ZIOErrorZ {
		contents: CResult_CVec_u8ZIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZIOErrorZ in the error state.
pub extern "C" fn CResult_CVec_u8ZIOErrorZ_err(e: crate::c_types::IOError) -> CResult_CVec_u8ZIOErrorZ {
	CResult_CVec_u8ZIOErrorZ {
		contents: CResult_CVec_u8ZIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_u8ZIOErrorZ_is_ok(o: &CResult_CVec_u8ZIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_u8ZIOErrorZ.
pub extern "C" fn CResult_CVec_u8ZIOErrorZ_free(_res: CResult_CVec_u8ZIOErrorZ) { }
impl Drop for CResult_CVec_u8ZIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, crate::c_types::IOError>> for CResult_CVec_u8ZIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_u8ZIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_u8ZIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_u8ZIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_u8ZIOErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_u8Z>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_u8ZIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_u8ZIOErrorZ_clone(orig: &CResult_CVec_u8ZIOErrorZ) -> CResult_CVec_u8ZIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CVec_StrZIOErrorZ
pub union CResult_CVec_StrZIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_StrZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_CVec_StrZIOErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_StrZ on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_StrZIOErrorZ {
	/// The contents of this CResult_CVec_StrZIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_StrZIOErrorZPtr,
	/// Whether this CResult_CVec_StrZIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_StrZIOErrorZ in the success state.
pub extern "C" fn CResult_CVec_StrZIOErrorZ_ok(o: crate::c_types::derived::CVec_StrZ) -> CResult_CVec_StrZIOErrorZ {
	CResult_CVec_StrZIOErrorZ {
		contents: CResult_CVec_StrZIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_StrZIOErrorZ in the error state.
pub extern "C" fn CResult_CVec_StrZIOErrorZ_err(e: crate::c_types::IOError) -> CResult_CVec_StrZIOErrorZ {
	CResult_CVec_StrZIOErrorZ {
		contents: CResult_CVec_StrZIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_StrZIOErrorZ_is_ok(o: &CResult_CVec_StrZIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_StrZIOErrorZ.
pub extern "C" fn CResult_CVec_StrZIOErrorZ_free(_res: CResult_CVec_StrZIOErrorZ) { }
impl Drop for CResult_CVec_StrZIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_StrZ, crate::c_types::IOError>> for CResult_CVec_StrZIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_StrZ, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_StrZIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_StrZIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_StrZIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_StrZIOErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_StrZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_StrZIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_StrZIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_StrZIOErrorZ_clone(orig: &CResult_CVec_StrZIOErrorZ) -> CResult_CVec_StrZIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_StrStrStrZ {
	/// The element at position 0
	pub a: crate::c_types::Str,
	/// The element at position 1
	pub b: crate::c_types::Str,
	/// The element at position 2
	pub c: crate::c_types::Str,
}
impl From<(crate::c_types::Str, crate::c_types::Str, crate::c_types::Str)> for C3Tuple_StrStrStrZ {
	fn from (tup: (crate::c_types::Str, crate::c_types::Str, crate::c_types::Str)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_StrStrStrZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::Str, crate::c_types::Str, crate::c_types::Str) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_StrStrStrZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_StrStrStrZ_clone(orig: &C3Tuple_StrStrStrZ) -> C3Tuple_StrStrStrZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_StrStrStrZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_StrStrStrZ_new(a: crate::c_types::Str, b: crate::c_types::Str, c: crate::c_types::Str) -> C3Tuple_StrStrStrZ {
	C3Tuple_StrStrStrZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_StrStrStrZ.
pub extern "C" fn C3Tuple_StrStrStrZ_free(_res: C3Tuple_StrStrStrZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C3Tuple_StrStrStrZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C3Tuple_StrStrStrZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C3Tuple_StrStrStrZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C3Tuple_StrStrStrZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C3Tuple_StrStrStrZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C3Tuple_StrStrStrZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C3Tuple_StrStrStrZ>> for CVec_C3Tuple_StrStrStrZZ {
	fn from(v: Vec<crate::c_types::derived::C3Tuple_StrStrStrZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C3Tuple_StrStrStrZZ_free(_res: CVec_C3Tuple_StrStrStrZZ) { }
impl Drop for CVec_C3Tuple_StrStrStrZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C3Tuple_StrStrStrZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ
pub union CResult_CVec_C3Tuple_StrStrStrZZIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_C3Tuple_StrStrStrZZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_C3Tuple_StrStrStrZZ on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ {
	/// The contents of this CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_C3Tuple_StrStrStrZZIOErrorZPtr,
	/// Whether this CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ in the success state.
pub extern "C" fn CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ_ok(o: crate::c_types::derived::CVec_C3Tuple_StrStrStrZZ) -> CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ {
	CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ {
		contents: CResult_CVec_C3Tuple_StrStrStrZZIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ in the error state.
pub extern "C" fn CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ_err(e: crate::c_types::IOError) -> CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ {
	CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ {
		contents: CResult_CVec_C3Tuple_StrStrStrZZIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ_is_ok(o: &CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ.
pub extern "C" fn CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ_free(_res: CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ) { }
impl Drop for CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_C3Tuple_StrStrStrZZ, crate::c_types::IOError>> for CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_C3Tuple_StrStrStrZZ, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_C3Tuple_StrStrStrZZIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_C3Tuple_StrStrStrZZIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_C3Tuple_StrStrStrZZIOErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_C3Tuple_StrStrStrZZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_C3Tuple_StrStrStrZZIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ_clone(orig: &CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ) -> CResult_CVec_C3Tuple_StrStrStrZZIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ>> for CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ_free(_res: CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ) { }
impl Drop for CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ
pub union CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	/// The contents of this CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr,
	/// Whether this CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ in the success state.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_ok(o: crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ) -> CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
		contents: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ in the error state.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_err(e: crate::c_types::IOError) -> CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
		contents: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_is_ok(o: &CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_free(_res: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ) { }
impl Drop for CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ, crate::c_types::IOError>> for CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_clone(orig: &CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ) -> CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ
pub union CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	/// The contents of this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr,
	/// Whether this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ in the success state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_ok(o: crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ in the error state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_err(e: crate::c_types::IOError) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_is_ok(o: &CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_free(_res: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ) { }
impl Drop for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ, crate::c_types::IOError>> for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_clone(orig: &CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_MonitorNameIOErrorZ
pub union CResult_MonitorNameIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::persist::MonitorName,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_MonitorNameIOErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::persist::MonitorName on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_MonitorNameIOErrorZ {
	/// The contents of this CResult_MonitorNameIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_MonitorNameIOErrorZPtr,
	/// Whether this CResult_MonitorNameIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_MonitorNameIOErrorZ in the success state.
pub extern "C" fn CResult_MonitorNameIOErrorZ_ok(o: crate::lightning::util::persist::MonitorName) -> CResult_MonitorNameIOErrorZ {
	CResult_MonitorNameIOErrorZ {
		contents: CResult_MonitorNameIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_MonitorNameIOErrorZ in the error state.
pub extern "C" fn CResult_MonitorNameIOErrorZ_err(e: crate::c_types::IOError) -> CResult_MonitorNameIOErrorZ {
	CResult_MonitorNameIOErrorZ {
		contents: CResult_MonitorNameIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_MonitorNameIOErrorZ_is_ok(o: &CResult_MonitorNameIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_MonitorNameIOErrorZ.
pub extern "C" fn CResult_MonitorNameIOErrorZ_free(_res: CResult_MonitorNameIOErrorZ) { }
impl Drop for CResult_MonitorNameIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::persist::MonitorName, crate::c_types::IOError>> for CResult_MonitorNameIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::persist::MonitorName, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_MonitorNameIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_MonitorNameIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_UpdateNameIOErrorZ
pub union CResult_UpdateNameIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::persist::UpdateName,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_UpdateNameIOErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::persist::UpdateName on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateNameIOErrorZ {
	/// The contents of this CResult_UpdateNameIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateNameIOErrorZPtr,
	/// Whether this CResult_UpdateNameIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateNameIOErrorZ in the success state.
pub extern "C" fn CResult_UpdateNameIOErrorZ_ok(o: crate::lightning::util::persist::UpdateName) -> CResult_UpdateNameIOErrorZ {
	CResult_UpdateNameIOErrorZ {
		contents: CResult_UpdateNameIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateNameIOErrorZ in the error state.
pub extern "C" fn CResult_UpdateNameIOErrorZ_err(e: crate::c_types::IOError) -> CResult_UpdateNameIOErrorZ {
	CResult_UpdateNameIOErrorZ {
		contents: CResult_UpdateNameIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateNameIOErrorZ_is_ok(o: &CResult_UpdateNameIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateNameIOErrorZ.
pub extern "C" fn CResult_UpdateNameIOErrorZ_free(_res: CResult_UpdateNameIOErrorZ) { }
impl Drop for CResult_UpdateNameIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::persist::UpdateName, crate::c_types::IOError>> for CResult_UpdateNameIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::persist::UpdateName, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateNameIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateNameIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_InvoiceRequestBolt12SemanticErrorZ
pub union CResult_InvoiceRequestBolt12SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice_request::InvoiceRequest,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_InvoiceRequestBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice_request::InvoiceRequest on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InvoiceRequestBolt12SemanticErrorZ {
	/// The contents of this CResult_InvoiceRequestBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InvoiceRequestBolt12SemanticErrorZPtr,
	/// Whether this CResult_InvoiceRequestBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_InvoiceRequestBolt12SemanticErrorZ_ok(o: crate::lightning::offers::invoice_request::InvoiceRequest) -> CResult_InvoiceRequestBolt12SemanticErrorZ {
	CResult_InvoiceRequestBolt12SemanticErrorZ {
		contents: CResult_InvoiceRequestBolt12SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_InvoiceRequestBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_InvoiceRequestBolt12SemanticErrorZ {
	CResult_InvoiceRequestBolt12SemanticErrorZ {
		contents: CResult_InvoiceRequestBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InvoiceRequestBolt12SemanticErrorZ_is_ok(o: &CResult_InvoiceRequestBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InvoiceRequestBolt12SemanticErrorZ.
pub extern "C" fn CResult_InvoiceRequestBolt12SemanticErrorZ_free(_res: CResult_InvoiceRequestBolt12SemanticErrorZ) { }
impl Drop for CResult_InvoiceRequestBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::InvoiceRequest, crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_InvoiceRequestBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::InvoiceRequest, crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InvoiceRequestBolt12SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InvoiceRequestBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InvoiceRequestBolt12SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InvoiceRequestBolt12SemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice_request::InvoiceRequest>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InvoiceRequestBolt12SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestBolt12SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InvoiceRequestBolt12SemanticErrorZ_clone(orig: &CResult_InvoiceRequestBolt12SemanticErrorZ) -> CResult_InvoiceRequestBolt12SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ
pub union CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice::InvoiceWithExplicitSigningPubkeyBuilder,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice::InvoiceWithExplicitSigningPubkeyBuilder on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ {
	/// The contents of this CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZPtr,
	/// Whether this CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ_ok(o: crate::lightning::offers::invoice::InvoiceWithExplicitSigningPubkeyBuilder) -> CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ {
	CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ {
		contents: CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ {
	CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ {
		contents: CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ_is_ok(o: &CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ.
pub extern "C" fn CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ_free(_res: CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ) { }
impl Drop for CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice::InvoiceWithExplicitSigningPubkeyBuilder, crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice::InvoiceWithExplicitSigningPubkeyBuilder, crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InvoiceWithExplicitSigningPubkeyBuilderBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_VerifiedInvoiceRequestNoneZ
pub union CResult_VerifiedInvoiceRequestNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice_request::VerifiedInvoiceRequest,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_VerifiedInvoiceRequestNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice_request::VerifiedInvoiceRequest on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_VerifiedInvoiceRequestNoneZ {
	/// The contents of this CResult_VerifiedInvoiceRequestNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_VerifiedInvoiceRequestNoneZPtr,
	/// Whether this CResult_VerifiedInvoiceRequestNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_VerifiedInvoiceRequestNoneZ in the success state.
pub extern "C" fn CResult_VerifiedInvoiceRequestNoneZ_ok(o: crate::lightning::offers::invoice_request::VerifiedInvoiceRequest) -> CResult_VerifiedInvoiceRequestNoneZ {
	CResult_VerifiedInvoiceRequestNoneZ {
		contents: CResult_VerifiedInvoiceRequestNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_VerifiedInvoiceRequestNoneZ in the error state.
pub extern "C" fn CResult_VerifiedInvoiceRequestNoneZ_err() -> CResult_VerifiedInvoiceRequestNoneZ {
	CResult_VerifiedInvoiceRequestNoneZ {
		contents: CResult_VerifiedInvoiceRequestNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_VerifiedInvoiceRequestNoneZ_is_ok(o: &CResult_VerifiedInvoiceRequestNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_VerifiedInvoiceRequestNoneZ.
pub extern "C" fn CResult_VerifiedInvoiceRequestNoneZ_free(_res: CResult_VerifiedInvoiceRequestNoneZ) { }
impl Drop for CResult_VerifiedInvoiceRequestNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::VerifiedInvoiceRequest, ()>> for CResult_VerifiedInvoiceRequestNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::VerifiedInvoiceRequest, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_VerifiedInvoiceRequestNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_VerifiedInvoiceRequestNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_VerifiedInvoiceRequestNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_VerifiedInvoiceRequestNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice_request::VerifiedInvoiceRequest>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_VerifiedInvoiceRequestNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_VerifiedInvoiceRequestNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_VerifiedInvoiceRequestNoneZ_clone(orig: &CResult_VerifiedInvoiceRequestNoneZ) -> CResult_VerifiedInvoiceRequestNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ
pub union CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice::InvoiceWithDerivedSigningPubkeyBuilder,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice::InvoiceWithDerivedSigningPubkeyBuilder on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ {
	/// The contents of this CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZPtr,
	/// Whether this CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ_ok(o: crate::lightning::offers::invoice::InvoiceWithDerivedSigningPubkeyBuilder) -> CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ {
	CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ {
		contents: CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ {
	CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ {
		contents: CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ_is_ok(o: &CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ.
pub extern "C" fn CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ_free(_res: CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ) { }
impl Drop for CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice::InvoiceWithDerivedSigningPubkeyBuilder, crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice::InvoiceWithDerivedSigningPubkeyBuilder, crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InvoiceWithDerivedSigningPubkeyBuilderBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_InvoiceRequestDecodeErrorZ
pub union CResult_InvoiceRequestDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice_request::InvoiceRequest,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InvoiceRequestDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice_request::InvoiceRequest on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InvoiceRequestDecodeErrorZ {
	/// The contents of this CResult_InvoiceRequestDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InvoiceRequestDecodeErrorZPtr,
	/// Whether this CResult_InvoiceRequestDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestDecodeErrorZ in the success state.
pub extern "C" fn CResult_InvoiceRequestDecodeErrorZ_ok(o: crate::lightning::offers::invoice_request::InvoiceRequest) -> CResult_InvoiceRequestDecodeErrorZ {
	CResult_InvoiceRequestDecodeErrorZ {
		contents: CResult_InvoiceRequestDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestDecodeErrorZ in the error state.
pub extern "C" fn CResult_InvoiceRequestDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InvoiceRequestDecodeErrorZ {
	CResult_InvoiceRequestDecodeErrorZ {
		contents: CResult_InvoiceRequestDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InvoiceRequestDecodeErrorZ_is_ok(o: &CResult_InvoiceRequestDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InvoiceRequestDecodeErrorZ.
pub extern "C" fn CResult_InvoiceRequestDecodeErrorZ_free(_res: CResult_InvoiceRequestDecodeErrorZ) { }
impl Drop for CResult_InvoiceRequestDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::InvoiceRequest, crate::lightning::ln::msgs::DecodeError>> for CResult_InvoiceRequestDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::InvoiceRequest, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InvoiceRequestDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InvoiceRequestDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InvoiceRequestDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InvoiceRequestDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice_request::InvoiceRequest>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InvoiceRequestDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InvoiceRequestDecodeErrorZ_clone(orig: &CResult_InvoiceRequestDecodeErrorZ) -> CResult_InvoiceRequestDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InvoiceRequestFieldsDecodeErrorZ
pub union CResult_InvoiceRequestFieldsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice_request::InvoiceRequestFields,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InvoiceRequestFieldsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice_request::InvoiceRequestFields on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InvoiceRequestFieldsDecodeErrorZ {
	/// The contents of this CResult_InvoiceRequestFieldsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InvoiceRequestFieldsDecodeErrorZPtr,
	/// Whether this CResult_InvoiceRequestFieldsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestFieldsDecodeErrorZ in the success state.
pub extern "C" fn CResult_InvoiceRequestFieldsDecodeErrorZ_ok(o: crate::lightning::offers::invoice_request::InvoiceRequestFields) -> CResult_InvoiceRequestFieldsDecodeErrorZ {
	CResult_InvoiceRequestFieldsDecodeErrorZ {
		contents: CResult_InvoiceRequestFieldsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestFieldsDecodeErrorZ in the error state.
pub extern "C" fn CResult_InvoiceRequestFieldsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InvoiceRequestFieldsDecodeErrorZ {
	CResult_InvoiceRequestFieldsDecodeErrorZ {
		contents: CResult_InvoiceRequestFieldsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InvoiceRequestFieldsDecodeErrorZ_is_ok(o: &CResult_InvoiceRequestFieldsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InvoiceRequestFieldsDecodeErrorZ.
pub extern "C" fn CResult_InvoiceRequestFieldsDecodeErrorZ_free(_res: CResult_InvoiceRequestFieldsDecodeErrorZ) { }
impl Drop for CResult_InvoiceRequestFieldsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::InvoiceRequestFields, crate::lightning::ln::msgs::DecodeError>> for CResult_InvoiceRequestFieldsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::InvoiceRequestFields, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InvoiceRequestFieldsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InvoiceRequestFieldsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InvoiceRequestFieldsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InvoiceRequestFieldsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice_request::InvoiceRequestFields>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InvoiceRequestFieldsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceRequestFieldsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InvoiceRequestFieldsDecodeErrorZ_clone(orig: &CResult_InvoiceRequestFieldsDecodeErrorZ) -> CResult_InvoiceRequestFieldsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// An enum which can either contain a  or not
pub enum COption_NoneZ {
	/// When we're in this state, this COption_NoneZ contains a 
	Some,
	/// When we're in this state, this COption_NoneZ contains nothing
	None
}
impl COption_NoneZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
}
#[no_mangle]
/// Constructs a new COption_NoneZ containing a 
pub extern "C" fn COption_NoneZ_some() -> COption_NoneZ {
	COption_NoneZ::Some
}
#[no_mangle]
/// Constructs a new COption_NoneZ containing nothing
pub extern "C" fn COption_NoneZ_none() -> COption_NoneZ {
	COption_NoneZ::None
}
#[no_mangle]
/// Frees any resources associated with the , if we are in the Some state
pub extern "C" fn COption_NoneZ_free(_res: COption_NoneZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::Witnesss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_WitnessZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::Witness,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_WitnessZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::Witness> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::Witness] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::Witness>> for CVec_WitnessZ {
	fn from(v: Vec<crate::c_types::Witness>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_WitnessZ_free(_res: CVec_WitnessZ) { }
impl Drop for CVec_WitnessZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_WitnessZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::ECDSASignature or not
pub enum COption_ECDSASignatureZ {
	/// When we're in this state, this COption_ECDSASignatureZ contains a crate::c_types::ECDSASignature
	Some(crate::c_types::ECDSASignature),
	/// When we're in this state, this COption_ECDSASignatureZ contains nothing
	None
}
impl COption_ECDSASignatureZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::ECDSASignature {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_ECDSASignatureZ containing a crate::c_types::ECDSASignature
pub extern "C" fn COption_ECDSASignatureZ_some(o: crate::c_types::ECDSASignature) -> COption_ECDSASignatureZ {
	COption_ECDSASignatureZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_ECDSASignatureZ containing nothing
pub extern "C" fn COption_ECDSASignatureZ_none() -> COption_ECDSASignatureZ {
	COption_ECDSASignatureZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::ECDSASignature, if we are in the Some state
pub extern "C" fn COption_ECDSASignatureZ_free(_res: COption_ECDSASignatureZ) { }
#[no_mangle]
/// Creates a new COption_ECDSASignatureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_ECDSASignatureZ_clone(orig: &COption_ECDSASignatureZ) -> COption_ECDSASignatureZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a i64 or not
pub enum COption_i64Z {
	/// When we're in this state, this COption_i64Z contains a i64
	Some(i64),
	/// When we're in this state, this COption_i64Z contains nothing
	None
}
impl COption_i64Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> i64 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_i64Z containing a i64
pub extern "C" fn COption_i64Z_some(o: i64) -> COption_i64Z {
	COption_i64Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_i64Z containing nothing
pub extern "C" fn COption_i64Z_none() -> COption_i64Z {
	COption_i64Z::None
}
#[no_mangle]
/// Frees any resources associated with the i64, if we are in the Some state
pub extern "C" fn COption_i64Z_free(_res: COption_i64Z) { }
#[no_mangle]
/// Creates a new COption_i64Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_i64Z_clone(orig: &COption_i64Z) -> COption_i64Z { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SocketAddressDecodeErrorZ
pub union CResult_SocketAddressDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::SocketAddress,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_SocketAddressDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::SocketAddress on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SocketAddressDecodeErrorZ {
	/// The contents of this CResult_SocketAddressDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SocketAddressDecodeErrorZPtr,
	/// Whether this CResult_SocketAddressDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SocketAddressDecodeErrorZ in the success state.
pub extern "C" fn CResult_SocketAddressDecodeErrorZ_ok(o: crate::lightning::ln::msgs::SocketAddress) -> CResult_SocketAddressDecodeErrorZ {
	CResult_SocketAddressDecodeErrorZ {
		contents: CResult_SocketAddressDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SocketAddressDecodeErrorZ in the error state.
pub extern "C" fn CResult_SocketAddressDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_SocketAddressDecodeErrorZ {
	CResult_SocketAddressDecodeErrorZ {
		contents: CResult_SocketAddressDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SocketAddressDecodeErrorZ_is_ok(o: &CResult_SocketAddressDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SocketAddressDecodeErrorZ.
pub extern "C" fn CResult_SocketAddressDecodeErrorZ_free(_res: CResult_SocketAddressDecodeErrorZ) { }
impl Drop for CResult_SocketAddressDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::SocketAddress, crate::lightning::ln::msgs::DecodeError>> for CResult_SocketAddressDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::SocketAddress, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SocketAddressDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SocketAddressDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SocketAddressDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SocketAddressDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SocketAddress>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SocketAddressDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SocketAddressDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SocketAddressDecodeErrorZ_clone(orig: &CResult_SocketAddressDecodeErrorZ) -> CResult_SocketAddressDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SocketAddressSocketAddressParseErrorZ
pub union CResult_SocketAddressSocketAddressParseErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::SocketAddress,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::SocketAddressParseError,
}
#[repr(C)]
/// A CResult_SocketAddressSocketAddressParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::SocketAddress on success and a crate::lightning::ln::msgs::SocketAddressParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SocketAddressSocketAddressParseErrorZ {
	/// The contents of this CResult_SocketAddressSocketAddressParseErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SocketAddressSocketAddressParseErrorZPtr,
	/// Whether this CResult_SocketAddressSocketAddressParseErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SocketAddressSocketAddressParseErrorZ in the success state.
pub extern "C" fn CResult_SocketAddressSocketAddressParseErrorZ_ok(o: crate::lightning::ln::msgs::SocketAddress) -> CResult_SocketAddressSocketAddressParseErrorZ {
	CResult_SocketAddressSocketAddressParseErrorZ {
		contents: CResult_SocketAddressSocketAddressParseErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SocketAddressSocketAddressParseErrorZ in the error state.
pub extern "C" fn CResult_SocketAddressSocketAddressParseErrorZ_err(e: crate::lightning::ln::msgs::SocketAddressParseError) -> CResult_SocketAddressSocketAddressParseErrorZ {
	CResult_SocketAddressSocketAddressParseErrorZ {
		contents: CResult_SocketAddressSocketAddressParseErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SocketAddressSocketAddressParseErrorZ_is_ok(o: &CResult_SocketAddressSocketAddressParseErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SocketAddressSocketAddressParseErrorZ.
pub extern "C" fn CResult_SocketAddressSocketAddressParseErrorZ_free(_res: CResult_SocketAddressSocketAddressParseErrorZ) { }
impl Drop for CResult_SocketAddressSocketAddressParseErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::SocketAddress, crate::lightning::ln::msgs::SocketAddressParseError>> for CResult_SocketAddressSocketAddressParseErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::SocketAddress, crate::lightning::ln::msgs::SocketAddressParseError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SocketAddressSocketAddressParseErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SocketAddressSocketAddressParseErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SocketAddressSocketAddressParseErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SocketAddressSocketAddressParseErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SocketAddress>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SocketAddressSocketAddressParseErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SocketAddressParseError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SocketAddressSocketAddressParseErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SocketAddressSocketAddressParseErrorZ_clone(orig: &CResult_SocketAddressSocketAddressParseErrorZ) -> CResult_SocketAddressSocketAddressParseErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateAddHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_UpdateAddHTLCZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::msgs::UpdateAddHTLC,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_UpdateAddHTLCZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::msgs::UpdateAddHTLC> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::msgs::UpdateAddHTLC] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::msgs::UpdateAddHTLC>> for CVec_UpdateAddHTLCZ {
	fn from(v: Vec<crate::lightning::ln::msgs::UpdateAddHTLC>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_UpdateAddHTLCZ_free(_res: CVec_UpdateAddHTLCZ) { }
impl Drop for CVec_UpdateAddHTLCZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_UpdateAddHTLCZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFulfillHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_UpdateFulfillHTLCZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::msgs::UpdateFulfillHTLC,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_UpdateFulfillHTLCZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::msgs::UpdateFulfillHTLC> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::msgs::UpdateFulfillHTLC] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::msgs::UpdateFulfillHTLC>> for CVec_UpdateFulfillHTLCZ {
	fn from(v: Vec<crate::lightning::ln::msgs::UpdateFulfillHTLC>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_UpdateFulfillHTLCZ_free(_res: CVec_UpdateFulfillHTLCZ) { }
impl Drop for CVec_UpdateFulfillHTLCZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_UpdateFulfillHTLCZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_UpdateFailHTLCZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::msgs::UpdateFailHTLC,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_UpdateFailHTLCZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::msgs::UpdateFailHTLC> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::msgs::UpdateFailHTLC] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::msgs::UpdateFailHTLC>> for CVec_UpdateFailHTLCZ {
	fn from(v: Vec<crate::lightning::ln::msgs::UpdateFailHTLC>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_UpdateFailHTLCZ_free(_res: CVec_UpdateFailHTLCZ) { }
impl Drop for CVec_UpdateFailHTLCZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_UpdateFailHTLCZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailMalformedHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_UpdateFailMalformedHTLCZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::msgs::UpdateFailMalformedHTLC,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_UpdateFailMalformedHTLCZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::msgs::UpdateFailMalformedHTLC> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::msgs::UpdateFailMalformedHTLC] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::msgs::UpdateFailMalformedHTLC>> for CVec_UpdateFailMalformedHTLCZ {
	fn from(v: Vec<crate::lightning::ln::msgs::UpdateFailMalformedHTLC>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_UpdateFailMalformedHTLCZ_free(_res: CVec_UpdateFailMalformedHTLCZ) { }
impl Drop for CVec_UpdateFailMalformedHTLCZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_UpdateFailMalformedHTLCZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_AcceptChannelDecodeErrorZ
pub union CResult_AcceptChannelDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::AcceptChannel,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_AcceptChannelDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::AcceptChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_AcceptChannelDecodeErrorZ {
	/// The contents of this CResult_AcceptChannelDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_AcceptChannelDecodeErrorZPtr,
	/// Whether this CResult_AcceptChannelDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelDecodeErrorZ in the success state.
pub extern "C" fn CResult_AcceptChannelDecodeErrorZ_ok(o: crate::lightning::ln::msgs::AcceptChannel) -> CResult_AcceptChannelDecodeErrorZ {
	CResult_AcceptChannelDecodeErrorZ {
		contents: CResult_AcceptChannelDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelDecodeErrorZ in the error state.
pub extern "C" fn CResult_AcceptChannelDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_AcceptChannelDecodeErrorZ {
	CResult_AcceptChannelDecodeErrorZ {
		contents: CResult_AcceptChannelDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_AcceptChannelDecodeErrorZ_is_ok(o: &CResult_AcceptChannelDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_AcceptChannelDecodeErrorZ.
pub extern "C" fn CResult_AcceptChannelDecodeErrorZ_free(_res: CResult_AcceptChannelDecodeErrorZ) { }
impl Drop for CResult_AcceptChannelDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::AcceptChannel, crate::lightning::ln::msgs::DecodeError>> for CResult_AcceptChannelDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::AcceptChannel, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_AcceptChannelDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_AcceptChannelDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_AcceptChannelDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_AcceptChannelDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::AcceptChannel>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_AcceptChannelDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_AcceptChannelDecodeErrorZ_clone(orig: &CResult_AcceptChannelDecodeErrorZ) -> CResult_AcceptChannelDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_AcceptChannelV2DecodeErrorZ
pub union CResult_AcceptChannelV2DecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::AcceptChannelV2,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_AcceptChannelV2DecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::AcceptChannelV2 on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_AcceptChannelV2DecodeErrorZ {
	/// The contents of this CResult_AcceptChannelV2DecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_AcceptChannelV2DecodeErrorZPtr,
	/// Whether this CResult_AcceptChannelV2DecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelV2DecodeErrorZ in the success state.
pub extern "C" fn CResult_AcceptChannelV2DecodeErrorZ_ok(o: crate::lightning::ln::msgs::AcceptChannelV2) -> CResult_AcceptChannelV2DecodeErrorZ {
	CResult_AcceptChannelV2DecodeErrorZ {
		contents: CResult_AcceptChannelV2DecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelV2DecodeErrorZ in the error state.
pub extern "C" fn CResult_AcceptChannelV2DecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_AcceptChannelV2DecodeErrorZ {
	CResult_AcceptChannelV2DecodeErrorZ {
		contents: CResult_AcceptChannelV2DecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_AcceptChannelV2DecodeErrorZ_is_ok(o: &CResult_AcceptChannelV2DecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_AcceptChannelV2DecodeErrorZ.
pub extern "C" fn CResult_AcceptChannelV2DecodeErrorZ_free(_res: CResult_AcceptChannelV2DecodeErrorZ) { }
impl Drop for CResult_AcceptChannelV2DecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::AcceptChannelV2, crate::lightning::ln::msgs::DecodeError>> for CResult_AcceptChannelV2DecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::AcceptChannelV2, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_AcceptChannelV2DecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_AcceptChannelV2DecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_AcceptChannelV2DecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_AcceptChannelV2DecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::AcceptChannelV2>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_AcceptChannelV2DecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelV2DecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_AcceptChannelV2DecodeErrorZ_clone(orig: &CResult_AcceptChannelV2DecodeErrorZ) -> CResult_AcceptChannelV2DecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_StfuDecodeErrorZ
pub union CResult_StfuDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Stfu,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_StfuDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Stfu on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_StfuDecodeErrorZ {
	/// The contents of this CResult_StfuDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_StfuDecodeErrorZPtr,
	/// Whether this CResult_StfuDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_StfuDecodeErrorZ in the success state.
pub extern "C" fn CResult_StfuDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Stfu) -> CResult_StfuDecodeErrorZ {
	CResult_StfuDecodeErrorZ {
		contents: CResult_StfuDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_StfuDecodeErrorZ in the error state.
pub extern "C" fn CResult_StfuDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_StfuDecodeErrorZ {
	CResult_StfuDecodeErrorZ {
		contents: CResult_StfuDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_StfuDecodeErrorZ_is_ok(o: &CResult_StfuDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_StfuDecodeErrorZ.
pub extern "C" fn CResult_StfuDecodeErrorZ_free(_res: CResult_StfuDecodeErrorZ) { }
impl Drop for CResult_StfuDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Stfu, crate::lightning::ln::msgs::DecodeError>> for CResult_StfuDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Stfu, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_StfuDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_StfuDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_StfuDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_StfuDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Stfu>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_StfuDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_StfuDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_StfuDecodeErrorZ_clone(orig: &CResult_StfuDecodeErrorZ) -> CResult_StfuDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SpliceInitDecodeErrorZ
pub union CResult_SpliceInitDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::SpliceInit,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_SpliceInitDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::SpliceInit on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SpliceInitDecodeErrorZ {
	/// The contents of this CResult_SpliceInitDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SpliceInitDecodeErrorZPtr,
	/// Whether this CResult_SpliceInitDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SpliceInitDecodeErrorZ in the success state.
pub extern "C" fn CResult_SpliceInitDecodeErrorZ_ok(o: crate::lightning::ln::msgs::SpliceInit) -> CResult_SpliceInitDecodeErrorZ {
	CResult_SpliceInitDecodeErrorZ {
		contents: CResult_SpliceInitDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceInitDecodeErrorZ in the error state.
pub extern "C" fn CResult_SpliceInitDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_SpliceInitDecodeErrorZ {
	CResult_SpliceInitDecodeErrorZ {
		contents: CResult_SpliceInitDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SpliceInitDecodeErrorZ_is_ok(o: &CResult_SpliceInitDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SpliceInitDecodeErrorZ.
pub extern "C" fn CResult_SpliceInitDecodeErrorZ_free(_res: CResult_SpliceInitDecodeErrorZ) { }
impl Drop for CResult_SpliceInitDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::SpliceInit, crate::lightning::ln::msgs::DecodeError>> for CResult_SpliceInitDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::SpliceInit, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SpliceInitDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SpliceInitDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SpliceInitDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SpliceInitDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SpliceInit>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SpliceInitDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceInitDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SpliceInitDecodeErrorZ_clone(orig: &CResult_SpliceInitDecodeErrorZ) -> CResult_SpliceInitDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SpliceAckDecodeErrorZ
pub union CResult_SpliceAckDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::SpliceAck,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_SpliceAckDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::SpliceAck on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SpliceAckDecodeErrorZ {
	/// The contents of this CResult_SpliceAckDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SpliceAckDecodeErrorZPtr,
	/// Whether this CResult_SpliceAckDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SpliceAckDecodeErrorZ in the success state.
pub extern "C" fn CResult_SpliceAckDecodeErrorZ_ok(o: crate::lightning::ln::msgs::SpliceAck) -> CResult_SpliceAckDecodeErrorZ {
	CResult_SpliceAckDecodeErrorZ {
		contents: CResult_SpliceAckDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceAckDecodeErrorZ in the error state.
pub extern "C" fn CResult_SpliceAckDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_SpliceAckDecodeErrorZ {
	CResult_SpliceAckDecodeErrorZ {
		contents: CResult_SpliceAckDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SpliceAckDecodeErrorZ_is_ok(o: &CResult_SpliceAckDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SpliceAckDecodeErrorZ.
pub extern "C" fn CResult_SpliceAckDecodeErrorZ_free(_res: CResult_SpliceAckDecodeErrorZ) { }
impl Drop for CResult_SpliceAckDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::SpliceAck, crate::lightning::ln::msgs::DecodeError>> for CResult_SpliceAckDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::SpliceAck, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SpliceAckDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SpliceAckDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SpliceAckDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SpliceAckDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SpliceAck>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SpliceAckDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceAckDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SpliceAckDecodeErrorZ_clone(orig: &CResult_SpliceAckDecodeErrorZ) -> CResult_SpliceAckDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SpliceLockedDecodeErrorZ
pub union CResult_SpliceLockedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::SpliceLocked,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_SpliceLockedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::SpliceLocked on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SpliceLockedDecodeErrorZ {
	/// The contents of this CResult_SpliceLockedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SpliceLockedDecodeErrorZPtr,
	/// Whether this CResult_SpliceLockedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SpliceLockedDecodeErrorZ in the success state.
pub extern "C" fn CResult_SpliceLockedDecodeErrorZ_ok(o: crate::lightning::ln::msgs::SpliceLocked) -> CResult_SpliceLockedDecodeErrorZ {
	CResult_SpliceLockedDecodeErrorZ {
		contents: CResult_SpliceLockedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceLockedDecodeErrorZ in the error state.
pub extern "C" fn CResult_SpliceLockedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_SpliceLockedDecodeErrorZ {
	CResult_SpliceLockedDecodeErrorZ {
		contents: CResult_SpliceLockedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SpliceLockedDecodeErrorZ_is_ok(o: &CResult_SpliceLockedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SpliceLockedDecodeErrorZ.
pub extern "C" fn CResult_SpliceLockedDecodeErrorZ_free(_res: CResult_SpliceLockedDecodeErrorZ) { }
impl Drop for CResult_SpliceLockedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::SpliceLocked, crate::lightning::ln::msgs::DecodeError>> for CResult_SpliceLockedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::SpliceLocked, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SpliceLockedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SpliceLockedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SpliceLockedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SpliceLockedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SpliceLocked>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SpliceLockedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceLockedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SpliceLockedDecodeErrorZ_clone(orig: &CResult_SpliceLockedDecodeErrorZ) -> CResult_SpliceLockedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxAddInputDecodeErrorZ
pub union CResult_TxAddInputDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxAddInput,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxAddInputDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxAddInput on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxAddInputDecodeErrorZ {
	/// The contents of this CResult_TxAddInputDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxAddInputDecodeErrorZPtr,
	/// Whether this CResult_TxAddInputDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxAddInputDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxAddInputDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxAddInput) -> CResult_TxAddInputDecodeErrorZ {
	CResult_TxAddInputDecodeErrorZ {
		contents: CResult_TxAddInputDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxAddInputDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxAddInputDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxAddInputDecodeErrorZ {
	CResult_TxAddInputDecodeErrorZ {
		contents: CResult_TxAddInputDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxAddInputDecodeErrorZ_is_ok(o: &CResult_TxAddInputDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxAddInputDecodeErrorZ.
pub extern "C" fn CResult_TxAddInputDecodeErrorZ_free(_res: CResult_TxAddInputDecodeErrorZ) { }
impl Drop for CResult_TxAddInputDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAddInput, crate::lightning::ln::msgs::DecodeError>> for CResult_TxAddInputDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAddInput, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxAddInputDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxAddInputDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxAddInputDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxAddInputDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxAddInput>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxAddInputDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxAddInputDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxAddInputDecodeErrorZ_clone(orig: &CResult_TxAddInputDecodeErrorZ) -> CResult_TxAddInputDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxAddOutputDecodeErrorZ
pub union CResult_TxAddOutputDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxAddOutput,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxAddOutputDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxAddOutput on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxAddOutputDecodeErrorZ {
	/// The contents of this CResult_TxAddOutputDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxAddOutputDecodeErrorZPtr,
	/// Whether this CResult_TxAddOutputDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxAddOutputDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxAddOutputDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxAddOutput) -> CResult_TxAddOutputDecodeErrorZ {
	CResult_TxAddOutputDecodeErrorZ {
		contents: CResult_TxAddOutputDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxAddOutputDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxAddOutputDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxAddOutputDecodeErrorZ {
	CResult_TxAddOutputDecodeErrorZ {
		contents: CResult_TxAddOutputDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxAddOutputDecodeErrorZ_is_ok(o: &CResult_TxAddOutputDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxAddOutputDecodeErrorZ.
pub extern "C" fn CResult_TxAddOutputDecodeErrorZ_free(_res: CResult_TxAddOutputDecodeErrorZ) { }
impl Drop for CResult_TxAddOutputDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAddOutput, crate::lightning::ln::msgs::DecodeError>> for CResult_TxAddOutputDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAddOutput, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxAddOutputDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxAddOutputDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxAddOutputDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxAddOutputDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxAddOutput>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxAddOutputDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxAddOutputDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxAddOutputDecodeErrorZ_clone(orig: &CResult_TxAddOutputDecodeErrorZ) -> CResult_TxAddOutputDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxRemoveInputDecodeErrorZ
pub union CResult_TxRemoveInputDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxRemoveInput,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxRemoveInputDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxRemoveInput on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxRemoveInputDecodeErrorZ {
	/// The contents of this CResult_TxRemoveInputDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxRemoveInputDecodeErrorZPtr,
	/// Whether this CResult_TxRemoveInputDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxRemoveInputDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxRemoveInputDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxRemoveInput) -> CResult_TxRemoveInputDecodeErrorZ {
	CResult_TxRemoveInputDecodeErrorZ {
		contents: CResult_TxRemoveInputDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxRemoveInputDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxRemoveInputDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxRemoveInputDecodeErrorZ {
	CResult_TxRemoveInputDecodeErrorZ {
		contents: CResult_TxRemoveInputDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxRemoveInputDecodeErrorZ_is_ok(o: &CResult_TxRemoveInputDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxRemoveInputDecodeErrorZ.
pub extern "C" fn CResult_TxRemoveInputDecodeErrorZ_free(_res: CResult_TxRemoveInputDecodeErrorZ) { }
impl Drop for CResult_TxRemoveInputDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxRemoveInput, crate::lightning::ln::msgs::DecodeError>> for CResult_TxRemoveInputDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxRemoveInput, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxRemoveInputDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxRemoveInputDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxRemoveInputDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxRemoveInputDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxRemoveInput>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxRemoveInputDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxRemoveInputDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxRemoveInputDecodeErrorZ_clone(orig: &CResult_TxRemoveInputDecodeErrorZ) -> CResult_TxRemoveInputDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxRemoveOutputDecodeErrorZ
pub union CResult_TxRemoveOutputDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxRemoveOutput,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxRemoveOutputDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxRemoveOutput on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxRemoveOutputDecodeErrorZ {
	/// The contents of this CResult_TxRemoveOutputDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxRemoveOutputDecodeErrorZPtr,
	/// Whether this CResult_TxRemoveOutputDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxRemoveOutputDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxRemoveOutputDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxRemoveOutput) -> CResult_TxRemoveOutputDecodeErrorZ {
	CResult_TxRemoveOutputDecodeErrorZ {
		contents: CResult_TxRemoveOutputDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxRemoveOutputDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxRemoveOutputDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxRemoveOutputDecodeErrorZ {
	CResult_TxRemoveOutputDecodeErrorZ {
		contents: CResult_TxRemoveOutputDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxRemoveOutputDecodeErrorZ_is_ok(o: &CResult_TxRemoveOutputDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxRemoveOutputDecodeErrorZ.
pub extern "C" fn CResult_TxRemoveOutputDecodeErrorZ_free(_res: CResult_TxRemoveOutputDecodeErrorZ) { }
impl Drop for CResult_TxRemoveOutputDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxRemoveOutput, crate::lightning::ln::msgs::DecodeError>> for CResult_TxRemoveOutputDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxRemoveOutput, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxRemoveOutputDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxRemoveOutputDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxRemoveOutputDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxRemoveOutputDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxRemoveOutput>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxRemoveOutputDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxRemoveOutputDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxRemoveOutputDecodeErrorZ_clone(orig: &CResult_TxRemoveOutputDecodeErrorZ) -> CResult_TxRemoveOutputDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxCompleteDecodeErrorZ
pub union CResult_TxCompleteDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxComplete,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxCompleteDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxComplete on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxCompleteDecodeErrorZ {
	/// The contents of this CResult_TxCompleteDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxCompleteDecodeErrorZPtr,
	/// Whether this CResult_TxCompleteDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxCompleteDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxCompleteDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxComplete) -> CResult_TxCompleteDecodeErrorZ {
	CResult_TxCompleteDecodeErrorZ {
		contents: CResult_TxCompleteDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxCompleteDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxCompleteDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxCompleteDecodeErrorZ {
	CResult_TxCompleteDecodeErrorZ {
		contents: CResult_TxCompleteDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxCompleteDecodeErrorZ_is_ok(o: &CResult_TxCompleteDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxCompleteDecodeErrorZ.
pub extern "C" fn CResult_TxCompleteDecodeErrorZ_free(_res: CResult_TxCompleteDecodeErrorZ) { }
impl Drop for CResult_TxCompleteDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxComplete, crate::lightning::ln::msgs::DecodeError>> for CResult_TxCompleteDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxComplete, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxCompleteDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxCompleteDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxCompleteDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxCompleteDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxComplete>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxCompleteDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxCompleteDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxCompleteDecodeErrorZ_clone(orig: &CResult_TxCompleteDecodeErrorZ) -> CResult_TxCompleteDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxSignaturesDecodeErrorZ
pub union CResult_TxSignaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxSignatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxSignaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxSignatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxSignaturesDecodeErrorZ {
	/// The contents of this CResult_TxSignaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxSignaturesDecodeErrorZPtr,
	/// Whether this CResult_TxSignaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxSignaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxSignaturesDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxSignatures) -> CResult_TxSignaturesDecodeErrorZ {
	CResult_TxSignaturesDecodeErrorZ {
		contents: CResult_TxSignaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxSignaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxSignaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxSignaturesDecodeErrorZ {
	CResult_TxSignaturesDecodeErrorZ {
		contents: CResult_TxSignaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxSignaturesDecodeErrorZ_is_ok(o: &CResult_TxSignaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxSignaturesDecodeErrorZ.
pub extern "C" fn CResult_TxSignaturesDecodeErrorZ_free(_res: CResult_TxSignaturesDecodeErrorZ) { }
impl Drop for CResult_TxSignaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxSignatures, crate::lightning::ln::msgs::DecodeError>> for CResult_TxSignaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxSignatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxSignaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxSignaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxSignaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxSignaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxSignatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxSignaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxSignaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxSignaturesDecodeErrorZ_clone(orig: &CResult_TxSignaturesDecodeErrorZ) -> CResult_TxSignaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxInitRbfDecodeErrorZ
pub union CResult_TxInitRbfDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxInitRbf,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxInitRbfDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxInitRbf on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxInitRbfDecodeErrorZ {
	/// The contents of this CResult_TxInitRbfDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxInitRbfDecodeErrorZPtr,
	/// Whether this CResult_TxInitRbfDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxInitRbfDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxInitRbfDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxInitRbf) -> CResult_TxInitRbfDecodeErrorZ {
	CResult_TxInitRbfDecodeErrorZ {
		contents: CResult_TxInitRbfDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxInitRbfDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxInitRbfDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxInitRbfDecodeErrorZ {
	CResult_TxInitRbfDecodeErrorZ {
		contents: CResult_TxInitRbfDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxInitRbfDecodeErrorZ_is_ok(o: &CResult_TxInitRbfDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxInitRbfDecodeErrorZ.
pub extern "C" fn CResult_TxInitRbfDecodeErrorZ_free(_res: CResult_TxInitRbfDecodeErrorZ) { }
impl Drop for CResult_TxInitRbfDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxInitRbf, crate::lightning::ln::msgs::DecodeError>> for CResult_TxInitRbfDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxInitRbf, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxInitRbfDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxInitRbfDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxInitRbfDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxInitRbfDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxInitRbf>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxInitRbfDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxInitRbfDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxInitRbfDecodeErrorZ_clone(orig: &CResult_TxInitRbfDecodeErrorZ) -> CResult_TxInitRbfDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxAckRbfDecodeErrorZ
pub union CResult_TxAckRbfDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxAckRbf,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxAckRbfDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxAckRbf on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxAckRbfDecodeErrorZ {
	/// The contents of this CResult_TxAckRbfDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxAckRbfDecodeErrorZPtr,
	/// Whether this CResult_TxAckRbfDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxAckRbfDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxAckRbfDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxAckRbf) -> CResult_TxAckRbfDecodeErrorZ {
	CResult_TxAckRbfDecodeErrorZ {
		contents: CResult_TxAckRbfDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxAckRbfDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxAckRbfDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxAckRbfDecodeErrorZ {
	CResult_TxAckRbfDecodeErrorZ {
		contents: CResult_TxAckRbfDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxAckRbfDecodeErrorZ_is_ok(o: &CResult_TxAckRbfDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxAckRbfDecodeErrorZ.
pub extern "C" fn CResult_TxAckRbfDecodeErrorZ_free(_res: CResult_TxAckRbfDecodeErrorZ) { }
impl Drop for CResult_TxAckRbfDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAckRbf, crate::lightning::ln::msgs::DecodeError>> for CResult_TxAckRbfDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAckRbf, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxAckRbfDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxAckRbfDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxAckRbfDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxAckRbfDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxAckRbf>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxAckRbfDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxAckRbfDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxAckRbfDecodeErrorZ_clone(orig: &CResult_TxAckRbfDecodeErrorZ) -> CResult_TxAckRbfDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxAbortDecodeErrorZ
pub union CResult_TxAbortDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxAbort,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxAbortDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxAbort on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxAbortDecodeErrorZ {
	/// The contents of this CResult_TxAbortDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxAbortDecodeErrorZPtr,
	/// Whether this CResult_TxAbortDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxAbortDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxAbortDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxAbort) -> CResult_TxAbortDecodeErrorZ {
	CResult_TxAbortDecodeErrorZ {
		contents: CResult_TxAbortDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxAbortDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxAbortDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxAbortDecodeErrorZ {
	CResult_TxAbortDecodeErrorZ {
		contents: CResult_TxAbortDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxAbortDecodeErrorZ_is_ok(o: &CResult_TxAbortDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxAbortDecodeErrorZ.
pub extern "C" fn CResult_TxAbortDecodeErrorZ_free(_res: CResult_TxAbortDecodeErrorZ) { }
impl Drop for CResult_TxAbortDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAbort, crate::lightning::ln::msgs::DecodeError>> for CResult_TxAbortDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAbort, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxAbortDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxAbortDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxAbortDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxAbortDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxAbort>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxAbortDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxAbortDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxAbortDecodeErrorZ_clone(orig: &CResult_TxAbortDecodeErrorZ) -> CResult_TxAbortDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_AnnouncementSignaturesDecodeErrorZ
pub union CResult_AnnouncementSignaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::AnnouncementSignatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_AnnouncementSignaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::AnnouncementSignatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_AnnouncementSignaturesDecodeErrorZ {
	/// The contents of this CResult_AnnouncementSignaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_AnnouncementSignaturesDecodeErrorZPtr,
	/// Whether this CResult_AnnouncementSignaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_AnnouncementSignaturesDecodeErrorZ_ok(o: crate::lightning::ln::msgs::AnnouncementSignatures) -> CResult_AnnouncementSignaturesDecodeErrorZ {
	CResult_AnnouncementSignaturesDecodeErrorZ {
		contents: CResult_AnnouncementSignaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_AnnouncementSignaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_AnnouncementSignaturesDecodeErrorZ {
	CResult_AnnouncementSignaturesDecodeErrorZ {
		contents: CResult_AnnouncementSignaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(o: &CResult_AnnouncementSignaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_AnnouncementSignaturesDecodeErrorZ.
pub extern "C" fn CResult_AnnouncementSignaturesDecodeErrorZ_free(_res: CResult_AnnouncementSignaturesDecodeErrorZ) { }
impl Drop for CResult_AnnouncementSignaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::AnnouncementSignatures, crate::lightning::ln::msgs::DecodeError>> for CResult_AnnouncementSignaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::AnnouncementSignatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_AnnouncementSignaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_AnnouncementSignaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_AnnouncementSignaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_AnnouncementSignaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::AnnouncementSignatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_AnnouncementSignaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_AnnouncementSignaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_AnnouncementSignaturesDecodeErrorZ_clone(orig: &CResult_AnnouncementSignaturesDecodeErrorZ) -> CResult_AnnouncementSignaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelReestablishDecodeErrorZ
pub union CResult_ChannelReestablishDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ChannelReestablish,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelReestablishDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelReestablish on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelReestablishDecodeErrorZ {
	/// The contents of this CResult_ChannelReestablishDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelReestablishDecodeErrorZPtr,
	/// Whether this CResult_ChannelReestablishDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelReestablishDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelReestablishDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ChannelReestablish) -> CResult_ChannelReestablishDecodeErrorZ {
	CResult_ChannelReestablishDecodeErrorZ {
		contents: CResult_ChannelReestablishDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelReestablishDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelReestablishDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelReestablishDecodeErrorZ {
	CResult_ChannelReestablishDecodeErrorZ {
		contents: CResult_ChannelReestablishDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelReestablishDecodeErrorZ_is_ok(o: &CResult_ChannelReestablishDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelReestablishDecodeErrorZ.
pub extern "C" fn CResult_ChannelReestablishDecodeErrorZ_free(_res: CResult_ChannelReestablishDecodeErrorZ) { }
impl Drop for CResult_ChannelReestablishDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelReestablish, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelReestablishDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelReestablish, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelReestablishDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelReestablishDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelReestablishDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelReestablishDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ChannelReestablish>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelReestablishDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelReestablishDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelReestablishDecodeErrorZ_clone(orig: &CResult_ChannelReestablishDecodeErrorZ) -> CResult_ChannelReestablishDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ClosingSignedDecodeErrorZ
pub union CResult_ClosingSignedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ClosingSigned,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ClosingSignedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ClosingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ClosingSignedDecodeErrorZ {
	/// The contents of this CResult_ClosingSignedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ClosingSignedDecodeErrorZPtr,
	/// Whether this CResult_ClosingSignedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedDecodeErrorZ in the success state.
pub extern "C" fn CResult_ClosingSignedDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ClosingSigned) -> CResult_ClosingSignedDecodeErrorZ {
	CResult_ClosingSignedDecodeErrorZ {
		contents: CResult_ClosingSignedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedDecodeErrorZ in the error state.
pub extern "C" fn CResult_ClosingSignedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ClosingSignedDecodeErrorZ {
	CResult_ClosingSignedDecodeErrorZ {
		contents: CResult_ClosingSignedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ClosingSignedDecodeErrorZ_is_ok(o: &CResult_ClosingSignedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ClosingSignedDecodeErrorZ.
pub extern "C" fn CResult_ClosingSignedDecodeErrorZ_free(_res: CResult_ClosingSignedDecodeErrorZ) { }
impl Drop for CResult_ClosingSignedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ClosingSigned, crate::lightning::ln::msgs::DecodeError>> for CResult_ClosingSignedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ClosingSigned, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ClosingSignedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ClosingSignedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ClosingSignedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ClosingSignedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ClosingSigned>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ClosingSignedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ClosingSignedDecodeErrorZ_clone(orig: &CResult_ClosingSignedDecodeErrorZ) -> CResult_ClosingSignedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ClosingSignedFeeRangeDecodeErrorZ
pub union CResult_ClosingSignedFeeRangeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ClosingSignedFeeRange,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ClosingSignedFeeRangeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ClosingSignedFeeRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ClosingSignedFeeRangeDecodeErrorZ {
	/// The contents of this CResult_ClosingSignedFeeRangeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ClosingSignedFeeRangeDecodeErrorZPtr,
	/// Whether this CResult_ClosingSignedFeeRangeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the success state.
pub extern "C" fn CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ClosingSignedFeeRange) -> CResult_ClosingSignedFeeRangeDecodeErrorZ {
	CResult_ClosingSignedFeeRangeDecodeErrorZ {
		contents: CResult_ClosingSignedFeeRangeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the error state.
pub extern "C" fn CResult_ClosingSignedFeeRangeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ClosingSignedFeeRangeDecodeErrorZ {
	CResult_ClosingSignedFeeRangeDecodeErrorZ {
		contents: CResult_ClosingSignedFeeRangeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(o: &CResult_ClosingSignedFeeRangeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ClosingSignedFeeRangeDecodeErrorZ.
pub extern "C" fn CResult_ClosingSignedFeeRangeDecodeErrorZ_free(_res: CResult_ClosingSignedFeeRangeDecodeErrorZ) { }
impl Drop for CResult_ClosingSignedFeeRangeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ClosingSignedFeeRange, crate::lightning::ln::msgs::DecodeError>> for CResult_ClosingSignedFeeRangeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ClosingSignedFeeRange, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ClosingSignedFeeRangeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ClosingSignedFeeRangeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ClosingSignedFeeRangeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ClosingSignedFeeRangeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ClosingSignedFeeRange>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ClosingSignedFeeRangeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(orig: &CResult_ClosingSignedFeeRangeDecodeErrorZ) -> CResult_ClosingSignedFeeRangeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CommitmentSignedBatchDecodeErrorZ
pub union CResult_CommitmentSignedBatchDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::CommitmentSignedBatch,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CommitmentSignedBatchDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::CommitmentSignedBatch on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CommitmentSignedBatchDecodeErrorZ {
	/// The contents of this CResult_CommitmentSignedBatchDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CommitmentSignedBatchDecodeErrorZPtr,
	/// Whether this CResult_CommitmentSignedBatchDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CommitmentSignedBatchDecodeErrorZ in the success state.
pub extern "C" fn CResult_CommitmentSignedBatchDecodeErrorZ_ok(o: crate::lightning::ln::msgs::CommitmentSignedBatch) -> CResult_CommitmentSignedBatchDecodeErrorZ {
	CResult_CommitmentSignedBatchDecodeErrorZ {
		contents: CResult_CommitmentSignedBatchDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CommitmentSignedBatchDecodeErrorZ in the error state.
pub extern "C" fn CResult_CommitmentSignedBatchDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CommitmentSignedBatchDecodeErrorZ {
	CResult_CommitmentSignedBatchDecodeErrorZ {
		contents: CResult_CommitmentSignedBatchDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CommitmentSignedBatchDecodeErrorZ_is_ok(o: &CResult_CommitmentSignedBatchDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CommitmentSignedBatchDecodeErrorZ.
pub extern "C" fn CResult_CommitmentSignedBatchDecodeErrorZ_free(_res: CResult_CommitmentSignedBatchDecodeErrorZ) { }
impl Drop for CResult_CommitmentSignedBatchDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::CommitmentSignedBatch, crate::lightning::ln::msgs::DecodeError>> for CResult_CommitmentSignedBatchDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::CommitmentSignedBatch, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CommitmentSignedBatchDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CommitmentSignedBatchDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CommitmentSignedBatchDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CommitmentSignedBatchDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::CommitmentSignedBatch>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CommitmentSignedBatchDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CommitmentSignedBatchDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CommitmentSignedBatchDecodeErrorZ_clone(orig: &CResult_CommitmentSignedBatchDecodeErrorZ) -> CResult_CommitmentSignedBatchDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CommitmentSignedDecodeErrorZ
pub union CResult_CommitmentSignedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::CommitmentSigned,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CommitmentSignedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::CommitmentSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CommitmentSignedDecodeErrorZ {
	/// The contents of this CResult_CommitmentSignedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CommitmentSignedDecodeErrorZPtr,
	/// Whether this CResult_CommitmentSignedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CommitmentSignedDecodeErrorZ in the success state.
pub extern "C" fn CResult_CommitmentSignedDecodeErrorZ_ok(o: crate::lightning::ln::msgs::CommitmentSigned) -> CResult_CommitmentSignedDecodeErrorZ {
	CResult_CommitmentSignedDecodeErrorZ {
		contents: CResult_CommitmentSignedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CommitmentSignedDecodeErrorZ in the error state.
pub extern "C" fn CResult_CommitmentSignedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CommitmentSignedDecodeErrorZ {
	CResult_CommitmentSignedDecodeErrorZ {
		contents: CResult_CommitmentSignedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CommitmentSignedDecodeErrorZ_is_ok(o: &CResult_CommitmentSignedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CommitmentSignedDecodeErrorZ.
pub extern "C" fn CResult_CommitmentSignedDecodeErrorZ_free(_res: CResult_CommitmentSignedDecodeErrorZ) { }
impl Drop for CResult_CommitmentSignedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::CommitmentSigned, crate::lightning::ln::msgs::DecodeError>> for CResult_CommitmentSignedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::CommitmentSigned, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CommitmentSignedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CommitmentSignedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CommitmentSignedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CommitmentSignedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::CommitmentSigned>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CommitmentSignedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CommitmentSignedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CommitmentSignedDecodeErrorZ_clone(orig: &CResult_CommitmentSignedDecodeErrorZ) -> CResult_CommitmentSignedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_FundingCreatedDecodeErrorZ
pub union CResult_FundingCreatedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::FundingCreated,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_FundingCreatedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::FundingCreated on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_FundingCreatedDecodeErrorZ {
	/// The contents of this CResult_FundingCreatedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_FundingCreatedDecodeErrorZPtr,
	/// Whether this CResult_FundingCreatedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_FundingCreatedDecodeErrorZ in the success state.
pub extern "C" fn CResult_FundingCreatedDecodeErrorZ_ok(o: crate::lightning::ln::msgs::FundingCreated) -> CResult_FundingCreatedDecodeErrorZ {
	CResult_FundingCreatedDecodeErrorZ {
		contents: CResult_FundingCreatedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_FundingCreatedDecodeErrorZ in the error state.
pub extern "C" fn CResult_FundingCreatedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_FundingCreatedDecodeErrorZ {
	CResult_FundingCreatedDecodeErrorZ {
		contents: CResult_FundingCreatedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_FundingCreatedDecodeErrorZ_is_ok(o: &CResult_FundingCreatedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_FundingCreatedDecodeErrorZ.
pub extern "C" fn CResult_FundingCreatedDecodeErrorZ_free(_res: CResult_FundingCreatedDecodeErrorZ) { }
impl Drop for CResult_FundingCreatedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::FundingCreated, crate::lightning::ln::msgs::DecodeError>> for CResult_FundingCreatedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::FundingCreated, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_FundingCreatedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_FundingCreatedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_FundingCreatedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_FundingCreatedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::FundingCreated>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_FundingCreatedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_FundingCreatedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_FundingCreatedDecodeErrorZ_clone(orig: &CResult_FundingCreatedDecodeErrorZ) -> CResult_FundingCreatedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_FundingSignedDecodeErrorZ
pub union CResult_FundingSignedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::FundingSigned,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_FundingSignedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::FundingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_FundingSignedDecodeErrorZ {
	/// The contents of this CResult_FundingSignedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_FundingSignedDecodeErrorZPtr,
	/// Whether this CResult_FundingSignedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_FundingSignedDecodeErrorZ in the success state.
pub extern "C" fn CResult_FundingSignedDecodeErrorZ_ok(o: crate::lightning::ln::msgs::FundingSigned) -> CResult_FundingSignedDecodeErrorZ {
	CResult_FundingSignedDecodeErrorZ {
		contents: CResult_FundingSignedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_FundingSignedDecodeErrorZ in the error state.
pub extern "C" fn CResult_FundingSignedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_FundingSignedDecodeErrorZ {
	CResult_FundingSignedDecodeErrorZ {
		contents: CResult_FundingSignedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_FundingSignedDecodeErrorZ_is_ok(o: &CResult_FundingSignedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_FundingSignedDecodeErrorZ.
pub extern "C" fn CResult_FundingSignedDecodeErrorZ_free(_res: CResult_FundingSignedDecodeErrorZ) { }
impl Drop for CResult_FundingSignedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::FundingSigned, crate::lightning::ln::msgs::DecodeError>> for CResult_FundingSignedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::FundingSigned, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_FundingSignedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_FundingSignedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_FundingSignedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_FundingSignedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::FundingSigned>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_FundingSignedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_FundingSignedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_FundingSignedDecodeErrorZ_clone(orig: &CResult_FundingSignedDecodeErrorZ) -> CResult_FundingSignedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelReadyDecodeErrorZ
pub union CResult_ChannelReadyDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ChannelReady,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelReadyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelReady on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelReadyDecodeErrorZ {
	/// The contents of this CResult_ChannelReadyDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelReadyDecodeErrorZPtr,
	/// Whether this CResult_ChannelReadyDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelReadyDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelReadyDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ChannelReady) -> CResult_ChannelReadyDecodeErrorZ {
	CResult_ChannelReadyDecodeErrorZ {
		contents: CResult_ChannelReadyDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelReadyDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelReadyDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelReadyDecodeErrorZ {
	CResult_ChannelReadyDecodeErrorZ {
		contents: CResult_ChannelReadyDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelReadyDecodeErrorZ_is_ok(o: &CResult_ChannelReadyDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelReadyDecodeErrorZ.
pub extern "C" fn CResult_ChannelReadyDecodeErrorZ_free(_res: CResult_ChannelReadyDecodeErrorZ) { }
impl Drop for CResult_ChannelReadyDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelReady, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelReadyDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelReady, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelReadyDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelReadyDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelReadyDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelReadyDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ChannelReady>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelReadyDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelReadyDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelReadyDecodeErrorZ_clone(orig: &CResult_ChannelReadyDecodeErrorZ) -> CResult_ChannelReadyDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InitDecodeErrorZ
pub union CResult_InitDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Init,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InitDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Init on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InitDecodeErrorZ {
	/// The contents of this CResult_InitDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InitDecodeErrorZPtr,
	/// Whether this CResult_InitDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InitDecodeErrorZ in the success state.
pub extern "C" fn CResult_InitDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Init) -> CResult_InitDecodeErrorZ {
	CResult_InitDecodeErrorZ {
		contents: CResult_InitDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InitDecodeErrorZ in the error state.
pub extern "C" fn CResult_InitDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InitDecodeErrorZ {
	CResult_InitDecodeErrorZ {
		contents: CResult_InitDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InitDecodeErrorZ_is_ok(o: &CResult_InitDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InitDecodeErrorZ.
pub extern "C" fn CResult_InitDecodeErrorZ_free(_res: CResult_InitDecodeErrorZ) { }
impl Drop for CResult_InitDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Init, crate::lightning::ln::msgs::DecodeError>> for CResult_InitDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Init, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InitDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InitDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InitDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InitDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Init>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InitDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InitDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InitDecodeErrorZ_clone(orig: &CResult_InitDecodeErrorZ) -> CResult_InitDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OpenChannelDecodeErrorZ
pub union CResult_OpenChannelDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::OpenChannel,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OpenChannelDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::OpenChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OpenChannelDecodeErrorZ {
	/// The contents of this CResult_OpenChannelDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OpenChannelDecodeErrorZPtr,
	/// Whether this CResult_OpenChannelDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OpenChannelDecodeErrorZ in the success state.
pub extern "C" fn CResult_OpenChannelDecodeErrorZ_ok(o: crate::lightning::ln::msgs::OpenChannel) -> CResult_OpenChannelDecodeErrorZ {
	CResult_OpenChannelDecodeErrorZ {
		contents: CResult_OpenChannelDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OpenChannelDecodeErrorZ in the error state.
pub extern "C" fn CResult_OpenChannelDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OpenChannelDecodeErrorZ {
	CResult_OpenChannelDecodeErrorZ {
		contents: CResult_OpenChannelDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OpenChannelDecodeErrorZ_is_ok(o: &CResult_OpenChannelDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OpenChannelDecodeErrorZ.
pub extern "C" fn CResult_OpenChannelDecodeErrorZ_free(_res: CResult_OpenChannelDecodeErrorZ) { }
impl Drop for CResult_OpenChannelDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::OpenChannel, crate::lightning::ln::msgs::DecodeError>> for CResult_OpenChannelDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::OpenChannel, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OpenChannelDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OpenChannelDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OpenChannelDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OpenChannelDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::OpenChannel>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OpenChannelDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OpenChannelDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OpenChannelDecodeErrorZ_clone(orig: &CResult_OpenChannelDecodeErrorZ) -> CResult_OpenChannelDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OpenChannelV2DecodeErrorZ
pub union CResult_OpenChannelV2DecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::OpenChannelV2,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OpenChannelV2DecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::OpenChannelV2 on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OpenChannelV2DecodeErrorZ {
	/// The contents of this CResult_OpenChannelV2DecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OpenChannelV2DecodeErrorZPtr,
	/// Whether this CResult_OpenChannelV2DecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OpenChannelV2DecodeErrorZ in the success state.
pub extern "C" fn CResult_OpenChannelV2DecodeErrorZ_ok(o: crate::lightning::ln::msgs::OpenChannelV2) -> CResult_OpenChannelV2DecodeErrorZ {
	CResult_OpenChannelV2DecodeErrorZ {
		contents: CResult_OpenChannelV2DecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OpenChannelV2DecodeErrorZ in the error state.
pub extern "C" fn CResult_OpenChannelV2DecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OpenChannelV2DecodeErrorZ {
	CResult_OpenChannelV2DecodeErrorZ {
		contents: CResult_OpenChannelV2DecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OpenChannelV2DecodeErrorZ_is_ok(o: &CResult_OpenChannelV2DecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OpenChannelV2DecodeErrorZ.
pub extern "C" fn CResult_OpenChannelV2DecodeErrorZ_free(_res: CResult_OpenChannelV2DecodeErrorZ) { }
impl Drop for CResult_OpenChannelV2DecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::OpenChannelV2, crate::lightning::ln::msgs::DecodeError>> for CResult_OpenChannelV2DecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::OpenChannelV2, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OpenChannelV2DecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OpenChannelV2DecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OpenChannelV2DecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OpenChannelV2DecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::OpenChannelV2>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OpenChannelV2DecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OpenChannelV2DecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OpenChannelV2DecodeErrorZ_clone(orig: &CResult_OpenChannelV2DecodeErrorZ) -> CResult_OpenChannelV2DecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RevokeAndACKDecodeErrorZ
pub union CResult_RevokeAndACKDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::RevokeAndACK,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RevokeAndACKDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::RevokeAndACK on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RevokeAndACKDecodeErrorZ {
	/// The contents of this CResult_RevokeAndACKDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RevokeAndACKDecodeErrorZPtr,
	/// Whether this CResult_RevokeAndACKDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RevokeAndACKDecodeErrorZ in the success state.
pub extern "C" fn CResult_RevokeAndACKDecodeErrorZ_ok(o: crate::lightning::ln::msgs::RevokeAndACK) -> CResult_RevokeAndACKDecodeErrorZ {
	CResult_RevokeAndACKDecodeErrorZ {
		contents: CResult_RevokeAndACKDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RevokeAndACKDecodeErrorZ in the error state.
pub extern "C" fn CResult_RevokeAndACKDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RevokeAndACKDecodeErrorZ {
	CResult_RevokeAndACKDecodeErrorZ {
		contents: CResult_RevokeAndACKDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RevokeAndACKDecodeErrorZ_is_ok(o: &CResult_RevokeAndACKDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RevokeAndACKDecodeErrorZ.
pub extern "C" fn CResult_RevokeAndACKDecodeErrorZ_free(_res: CResult_RevokeAndACKDecodeErrorZ) { }
impl Drop for CResult_RevokeAndACKDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::RevokeAndACK, crate::lightning::ln::msgs::DecodeError>> for CResult_RevokeAndACKDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::RevokeAndACK, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RevokeAndACKDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RevokeAndACKDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RevokeAndACKDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RevokeAndACKDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::RevokeAndACK>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RevokeAndACKDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RevokeAndACKDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RevokeAndACKDecodeErrorZ_clone(orig: &CResult_RevokeAndACKDecodeErrorZ) -> CResult_RevokeAndACKDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ShutdownDecodeErrorZ
pub union CResult_ShutdownDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Shutdown,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ShutdownDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Shutdown on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ShutdownDecodeErrorZ {
	/// The contents of this CResult_ShutdownDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ShutdownDecodeErrorZPtr,
	/// Whether this CResult_ShutdownDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ShutdownDecodeErrorZ in the success state.
pub extern "C" fn CResult_ShutdownDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Shutdown) -> CResult_ShutdownDecodeErrorZ {
	CResult_ShutdownDecodeErrorZ {
		contents: CResult_ShutdownDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownDecodeErrorZ in the error state.
pub extern "C" fn CResult_ShutdownDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ShutdownDecodeErrorZ {
	CResult_ShutdownDecodeErrorZ {
		contents: CResult_ShutdownDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ShutdownDecodeErrorZ_is_ok(o: &CResult_ShutdownDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ShutdownDecodeErrorZ.
pub extern "C" fn CResult_ShutdownDecodeErrorZ_free(_res: CResult_ShutdownDecodeErrorZ) { }
impl Drop for CResult_ShutdownDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Shutdown, crate::lightning::ln::msgs::DecodeError>> for CResult_ShutdownDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Shutdown, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ShutdownDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ShutdownDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ShutdownDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ShutdownDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Shutdown>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ShutdownDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ShutdownDecodeErrorZ_clone(orig: &CResult_ShutdownDecodeErrorZ) -> CResult_ShutdownDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UpdateFailHTLCDecodeErrorZ
pub union CResult_UpdateFailHTLCDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UpdateFailHTLC,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UpdateFailHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFailHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateFailHTLCDecodeErrorZ {
	/// The contents of this CResult_UpdateFailHTLCDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateFailHTLCDecodeErrorZPtr,
	/// Whether this CResult_UpdateFailHTLCDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the success state.
pub extern "C" fn CResult_UpdateFailHTLCDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UpdateFailHTLC) -> CResult_UpdateFailHTLCDecodeErrorZ {
	CResult_UpdateFailHTLCDecodeErrorZ {
		contents: CResult_UpdateFailHTLCDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the error state.
pub extern "C" fn CResult_UpdateFailHTLCDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UpdateFailHTLCDecodeErrorZ {
	CResult_UpdateFailHTLCDecodeErrorZ {
		contents: CResult_UpdateFailHTLCDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateFailHTLCDecodeErrorZ_is_ok(o: &CResult_UpdateFailHTLCDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateFailHTLCDecodeErrorZ.
pub extern "C" fn CResult_UpdateFailHTLCDecodeErrorZ_free(_res: CResult_UpdateFailHTLCDecodeErrorZ) { }
impl Drop for CResult_UpdateFailHTLCDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFailHTLC, crate::lightning::ln::msgs::DecodeError>> for CResult_UpdateFailHTLCDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFailHTLC, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateFailHTLCDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateFailHTLCDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UpdateFailHTLCDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UpdateFailHTLCDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UpdateFailHTLC>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UpdateFailHTLCDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFailHTLCDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UpdateFailHTLCDecodeErrorZ_clone(orig: &CResult_UpdateFailHTLCDecodeErrorZ) -> CResult_UpdateFailHTLCDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UpdateFailMalformedHTLCDecodeErrorZ
pub union CResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UpdateFailMalformedHTLC,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UpdateFailMalformedHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFailMalformedHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	/// The contents of this CResult_UpdateFailMalformedHTLCDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateFailMalformedHTLCDecodeErrorZPtr,
	/// Whether this CResult_UpdateFailMalformedHTLCDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the success state.
pub extern "C" fn CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UpdateFailMalformedHTLC) -> CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	CResult_UpdateFailMalformedHTLCDecodeErrorZ {
		contents: CResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the error state.
pub extern "C" fn CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	CResult_UpdateFailMalformedHTLCDecodeErrorZ {
		contents: CResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(o: &CResult_UpdateFailMalformedHTLCDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateFailMalformedHTLCDecodeErrorZ.
pub extern "C" fn CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(_res: CResult_UpdateFailMalformedHTLCDecodeErrorZ) { }
impl Drop for CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFailMalformedHTLC, crate::lightning::ln::msgs::DecodeError>> for CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFailMalformedHTLC, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateFailMalformedHTLCDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateFailMalformedHTLCDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UpdateFailMalformedHTLC>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(orig: &CResult_UpdateFailMalformedHTLCDecodeErrorZ) -> CResult_UpdateFailMalformedHTLCDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UpdateFeeDecodeErrorZ
pub union CResult_UpdateFeeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UpdateFee,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UpdateFeeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFee on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateFeeDecodeErrorZ {
	/// The contents of this CResult_UpdateFeeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateFeeDecodeErrorZPtr,
	/// Whether this CResult_UpdateFeeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateFeeDecodeErrorZ in the success state.
pub extern "C" fn CResult_UpdateFeeDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UpdateFee) -> CResult_UpdateFeeDecodeErrorZ {
	CResult_UpdateFeeDecodeErrorZ {
		contents: CResult_UpdateFeeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFeeDecodeErrorZ in the error state.
pub extern "C" fn CResult_UpdateFeeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UpdateFeeDecodeErrorZ {
	CResult_UpdateFeeDecodeErrorZ {
		contents: CResult_UpdateFeeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateFeeDecodeErrorZ_is_ok(o: &CResult_UpdateFeeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateFeeDecodeErrorZ.
pub extern "C" fn CResult_UpdateFeeDecodeErrorZ_free(_res: CResult_UpdateFeeDecodeErrorZ) { }
impl Drop for CResult_UpdateFeeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFee, crate::lightning::ln::msgs::DecodeError>> for CResult_UpdateFeeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFee, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateFeeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateFeeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UpdateFeeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UpdateFeeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UpdateFee>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UpdateFeeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFeeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UpdateFeeDecodeErrorZ_clone(orig: &CResult_UpdateFeeDecodeErrorZ) -> CResult_UpdateFeeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UpdateFulfillHTLCDecodeErrorZ
pub union CResult_UpdateFulfillHTLCDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UpdateFulfillHTLC,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UpdateFulfillHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFulfillHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateFulfillHTLCDecodeErrorZ {
	/// The contents of this CResult_UpdateFulfillHTLCDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateFulfillHTLCDecodeErrorZPtr,
	/// Whether this CResult_UpdateFulfillHTLCDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the success state.
pub extern "C" fn CResult_UpdateFulfillHTLCDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UpdateFulfillHTLC) -> CResult_UpdateFulfillHTLCDecodeErrorZ {
	CResult_UpdateFulfillHTLCDecodeErrorZ {
		contents: CResult_UpdateFulfillHTLCDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the error state.
pub extern "C" fn CResult_UpdateFulfillHTLCDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UpdateFulfillHTLCDecodeErrorZ {
	CResult_UpdateFulfillHTLCDecodeErrorZ {
		contents: CResult_UpdateFulfillHTLCDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(o: &CResult_UpdateFulfillHTLCDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateFulfillHTLCDecodeErrorZ.
pub extern "C" fn CResult_UpdateFulfillHTLCDecodeErrorZ_free(_res: CResult_UpdateFulfillHTLCDecodeErrorZ) { }
impl Drop for CResult_UpdateFulfillHTLCDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFulfillHTLC, crate::lightning::ln::msgs::DecodeError>> for CResult_UpdateFulfillHTLCDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFulfillHTLC, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateFulfillHTLCDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateFulfillHTLCDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UpdateFulfillHTLCDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UpdateFulfillHTLCDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UpdateFulfillHTLC>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UpdateFulfillHTLCDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UpdateFulfillHTLCDecodeErrorZ_clone(orig: &CResult_UpdateFulfillHTLCDecodeErrorZ) -> CResult_UpdateFulfillHTLCDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OnionPacketDecodeErrorZ
pub union CResult_OnionPacketDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::OnionPacket,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OnionPacketDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::OnionPacket on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OnionPacketDecodeErrorZ {
	/// The contents of this CResult_OnionPacketDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OnionPacketDecodeErrorZPtr,
	/// Whether this CResult_OnionPacketDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OnionPacketDecodeErrorZ in the success state.
pub extern "C" fn CResult_OnionPacketDecodeErrorZ_ok(o: crate::lightning::ln::msgs::OnionPacket) -> CResult_OnionPacketDecodeErrorZ {
	CResult_OnionPacketDecodeErrorZ {
		contents: CResult_OnionPacketDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OnionPacketDecodeErrorZ in the error state.
pub extern "C" fn CResult_OnionPacketDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OnionPacketDecodeErrorZ {
	CResult_OnionPacketDecodeErrorZ {
		contents: CResult_OnionPacketDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OnionPacketDecodeErrorZ_is_ok(o: &CResult_OnionPacketDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OnionPacketDecodeErrorZ.
pub extern "C" fn CResult_OnionPacketDecodeErrorZ_free(_res: CResult_OnionPacketDecodeErrorZ) { }
impl Drop for CResult_OnionPacketDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::OnionPacket, crate::lightning::ln::msgs::DecodeError>> for CResult_OnionPacketDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::OnionPacket, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OnionPacketDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OnionPacketDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OnionPacketDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OnionPacketDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::OnionPacket>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OnionPacketDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OnionPacketDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OnionPacketDecodeErrorZ_clone(orig: &CResult_OnionPacketDecodeErrorZ) -> CResult_OnionPacketDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UpdateAddHTLCDecodeErrorZ
pub union CResult_UpdateAddHTLCDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UpdateAddHTLC,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UpdateAddHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateAddHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateAddHTLCDecodeErrorZ {
	/// The contents of this CResult_UpdateAddHTLCDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateAddHTLCDecodeErrorZPtr,
	/// Whether this CResult_UpdateAddHTLCDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the success state.
pub extern "C" fn CResult_UpdateAddHTLCDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UpdateAddHTLC) -> CResult_UpdateAddHTLCDecodeErrorZ {
	CResult_UpdateAddHTLCDecodeErrorZ {
		contents: CResult_UpdateAddHTLCDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the error state.
pub extern "C" fn CResult_UpdateAddHTLCDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UpdateAddHTLCDecodeErrorZ {
	CResult_UpdateAddHTLCDecodeErrorZ {
		contents: CResult_UpdateAddHTLCDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateAddHTLCDecodeErrorZ_is_ok(o: &CResult_UpdateAddHTLCDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateAddHTLCDecodeErrorZ.
pub extern "C" fn CResult_UpdateAddHTLCDecodeErrorZ_free(_res: CResult_UpdateAddHTLCDecodeErrorZ) { }
impl Drop for CResult_UpdateAddHTLCDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateAddHTLC, crate::lightning::ln::msgs::DecodeError>> for CResult_UpdateAddHTLCDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateAddHTLC, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateAddHTLCDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateAddHTLCDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UpdateAddHTLCDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UpdateAddHTLCDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UpdateAddHTLC>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UpdateAddHTLCDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateAddHTLCDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UpdateAddHTLCDecodeErrorZ_clone(orig: &CResult_UpdateAddHTLCDecodeErrorZ) -> CResult_UpdateAddHTLCDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OnionMessageDecodeErrorZ
pub union CResult_OnionMessageDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::OnionMessage,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OnionMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::OnionMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OnionMessageDecodeErrorZ {
	/// The contents of this CResult_OnionMessageDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OnionMessageDecodeErrorZPtr,
	/// Whether this CResult_OnionMessageDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OnionMessageDecodeErrorZ in the success state.
pub extern "C" fn CResult_OnionMessageDecodeErrorZ_ok(o: crate::lightning::ln::msgs::OnionMessage) -> CResult_OnionMessageDecodeErrorZ {
	CResult_OnionMessageDecodeErrorZ {
		contents: CResult_OnionMessageDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OnionMessageDecodeErrorZ in the error state.
pub extern "C" fn CResult_OnionMessageDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OnionMessageDecodeErrorZ {
	CResult_OnionMessageDecodeErrorZ {
		contents: CResult_OnionMessageDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OnionMessageDecodeErrorZ_is_ok(o: &CResult_OnionMessageDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OnionMessageDecodeErrorZ.
pub extern "C" fn CResult_OnionMessageDecodeErrorZ_free(_res: CResult_OnionMessageDecodeErrorZ) { }
impl Drop for CResult_OnionMessageDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::OnionMessage, crate::lightning::ln::msgs::DecodeError>> for CResult_OnionMessageDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::OnionMessage, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OnionMessageDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OnionMessageDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OnionMessageDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OnionMessageDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::OnionMessage>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OnionMessageDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OnionMessageDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OnionMessageDecodeErrorZ_clone(orig: &CResult_OnionMessageDecodeErrorZ) -> CResult_OnionMessageDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_FinalOnionHopDataDecodeErrorZ
pub union CResult_FinalOnionHopDataDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::FinalOnionHopData,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_FinalOnionHopDataDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::FinalOnionHopData on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_FinalOnionHopDataDecodeErrorZ {
	/// The contents of this CResult_FinalOnionHopDataDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_FinalOnionHopDataDecodeErrorZPtr,
	/// Whether this CResult_FinalOnionHopDataDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_FinalOnionHopDataDecodeErrorZ in the success state.
pub extern "C" fn CResult_FinalOnionHopDataDecodeErrorZ_ok(o: crate::lightning::ln::msgs::FinalOnionHopData) -> CResult_FinalOnionHopDataDecodeErrorZ {
	CResult_FinalOnionHopDataDecodeErrorZ {
		contents: CResult_FinalOnionHopDataDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_FinalOnionHopDataDecodeErrorZ in the error state.
pub extern "C" fn CResult_FinalOnionHopDataDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_FinalOnionHopDataDecodeErrorZ {
	CResult_FinalOnionHopDataDecodeErrorZ {
		contents: CResult_FinalOnionHopDataDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_FinalOnionHopDataDecodeErrorZ_is_ok(o: &CResult_FinalOnionHopDataDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_FinalOnionHopDataDecodeErrorZ.
pub extern "C" fn CResult_FinalOnionHopDataDecodeErrorZ_free(_res: CResult_FinalOnionHopDataDecodeErrorZ) { }
impl Drop for CResult_FinalOnionHopDataDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::FinalOnionHopData, crate::lightning::ln::msgs::DecodeError>> for CResult_FinalOnionHopDataDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::FinalOnionHopData, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_FinalOnionHopDataDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_FinalOnionHopDataDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_FinalOnionHopDataDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_FinalOnionHopDataDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::FinalOnionHopData>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_FinalOnionHopDataDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_FinalOnionHopDataDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_FinalOnionHopDataDecodeErrorZ_clone(orig: &CResult_FinalOnionHopDataDecodeErrorZ) -> CResult_FinalOnionHopDataDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PingDecodeErrorZ
pub union CResult_PingDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Ping,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PingDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Ping on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PingDecodeErrorZ {
	/// The contents of this CResult_PingDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PingDecodeErrorZPtr,
	/// Whether this CResult_PingDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PingDecodeErrorZ in the success state.
pub extern "C" fn CResult_PingDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Ping) -> CResult_PingDecodeErrorZ {
	CResult_PingDecodeErrorZ {
		contents: CResult_PingDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PingDecodeErrorZ in the error state.
pub extern "C" fn CResult_PingDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PingDecodeErrorZ {
	CResult_PingDecodeErrorZ {
		contents: CResult_PingDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PingDecodeErrorZ_is_ok(o: &CResult_PingDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PingDecodeErrorZ.
pub extern "C" fn CResult_PingDecodeErrorZ_free(_res: CResult_PingDecodeErrorZ) { }
impl Drop for CResult_PingDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Ping, crate::lightning::ln::msgs::DecodeError>> for CResult_PingDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Ping, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PingDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PingDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PingDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PingDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Ping>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PingDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PingDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PingDecodeErrorZ_clone(orig: &CResult_PingDecodeErrorZ) -> CResult_PingDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PongDecodeErrorZ
pub union CResult_PongDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Pong,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PongDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Pong on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PongDecodeErrorZ {
	/// The contents of this CResult_PongDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PongDecodeErrorZPtr,
	/// Whether this CResult_PongDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PongDecodeErrorZ in the success state.
pub extern "C" fn CResult_PongDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Pong) -> CResult_PongDecodeErrorZ {
	CResult_PongDecodeErrorZ {
		contents: CResult_PongDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PongDecodeErrorZ in the error state.
pub extern "C" fn CResult_PongDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PongDecodeErrorZ {
	CResult_PongDecodeErrorZ {
		contents: CResult_PongDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PongDecodeErrorZ_is_ok(o: &CResult_PongDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PongDecodeErrorZ.
pub extern "C" fn CResult_PongDecodeErrorZ_free(_res: CResult_PongDecodeErrorZ) { }
impl Drop for CResult_PongDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Pong, crate::lightning::ln::msgs::DecodeError>> for CResult_PongDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Pong, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PongDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PongDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PongDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PongDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Pong>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PongDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PongDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PongDecodeErrorZ_clone(orig: &CResult_PongDecodeErrorZ) -> CResult_PongDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UnsignedChannelAnnouncementDecodeErrorZ
pub union CResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UnsignedChannelAnnouncement,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UnsignedChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UnsignedChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	/// The contents of this CResult_UnsignedChannelAnnouncementDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UnsignedChannelAnnouncementDecodeErrorZPtr,
	/// Whether this CResult_UnsignedChannelAnnouncementDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the success state.
pub extern "C" fn CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UnsignedChannelAnnouncement) -> CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	CResult_UnsignedChannelAnnouncementDecodeErrorZ {
		contents: CResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the error state.
pub extern "C" fn CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	CResult_UnsignedChannelAnnouncementDecodeErrorZ {
		contents: CResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(o: &CResult_UnsignedChannelAnnouncementDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UnsignedChannelAnnouncementDecodeErrorZ.
pub extern "C" fn CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(_res: CResult_UnsignedChannelAnnouncementDecodeErrorZ) { }
impl Drop for CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedChannelAnnouncement, crate::lightning::ln::msgs::DecodeError>> for CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedChannelAnnouncement, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UnsignedChannelAnnouncementDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UnsignedChannelAnnouncementDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UnsignedChannelAnnouncement>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(orig: &CResult_UnsignedChannelAnnouncementDecodeErrorZ) -> CResult_UnsignedChannelAnnouncementDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelAnnouncementDecodeErrorZ
pub union CResult_ChannelAnnouncementDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ChannelAnnouncement,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelAnnouncementDecodeErrorZ {
	/// The contents of this CResult_ChannelAnnouncementDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelAnnouncementDecodeErrorZPtr,
	/// Whether this CResult_ChannelAnnouncementDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelAnnouncementDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ChannelAnnouncement) -> CResult_ChannelAnnouncementDecodeErrorZ {
	CResult_ChannelAnnouncementDecodeErrorZ {
		contents: CResult_ChannelAnnouncementDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelAnnouncementDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelAnnouncementDecodeErrorZ {
	CResult_ChannelAnnouncementDecodeErrorZ {
		contents: CResult_ChannelAnnouncementDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelAnnouncementDecodeErrorZ_is_ok(o: &CResult_ChannelAnnouncementDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelAnnouncementDecodeErrorZ.
pub extern "C" fn CResult_ChannelAnnouncementDecodeErrorZ_free(_res: CResult_ChannelAnnouncementDecodeErrorZ) { }
impl Drop for CResult_ChannelAnnouncementDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelAnnouncement, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelAnnouncementDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelAnnouncement, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelAnnouncementDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelAnnouncementDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelAnnouncementDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelAnnouncementDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ChannelAnnouncement>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelAnnouncementDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelAnnouncementDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelAnnouncementDecodeErrorZ_clone(orig: &CResult_ChannelAnnouncementDecodeErrorZ) -> CResult_ChannelAnnouncementDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UnsignedChannelUpdateDecodeErrorZ
pub union CResult_UnsignedChannelUpdateDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UnsignedChannelUpdate,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UnsignedChannelUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UnsignedChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UnsignedChannelUpdateDecodeErrorZ {
	/// The contents of this CResult_UnsignedChannelUpdateDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UnsignedChannelUpdateDecodeErrorZPtr,
	/// Whether this CResult_UnsignedChannelUpdateDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the success state.
pub extern "C" fn CResult_UnsignedChannelUpdateDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UnsignedChannelUpdate) -> CResult_UnsignedChannelUpdateDecodeErrorZ {
	CResult_UnsignedChannelUpdateDecodeErrorZ {
		contents: CResult_UnsignedChannelUpdateDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the error state.
pub extern "C" fn CResult_UnsignedChannelUpdateDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UnsignedChannelUpdateDecodeErrorZ {
	CResult_UnsignedChannelUpdateDecodeErrorZ {
		contents: CResult_UnsignedChannelUpdateDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(o: &CResult_UnsignedChannelUpdateDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UnsignedChannelUpdateDecodeErrorZ.
pub extern "C" fn CResult_UnsignedChannelUpdateDecodeErrorZ_free(_res: CResult_UnsignedChannelUpdateDecodeErrorZ) { }
impl Drop for CResult_UnsignedChannelUpdateDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedChannelUpdate, crate::lightning::ln::msgs::DecodeError>> for CResult_UnsignedChannelUpdateDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedChannelUpdate, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UnsignedChannelUpdateDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UnsignedChannelUpdateDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UnsignedChannelUpdateDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UnsignedChannelUpdateDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UnsignedChannelUpdate>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UnsignedChannelUpdateDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UnsignedChannelUpdateDecodeErrorZ_clone(orig: &CResult_UnsignedChannelUpdateDecodeErrorZ) -> CResult_UnsignedChannelUpdateDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelUpdateDecodeErrorZ
pub union CResult_ChannelUpdateDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ChannelUpdate,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelUpdateDecodeErrorZ {
	/// The contents of this CResult_ChannelUpdateDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelUpdateDecodeErrorZPtr,
	/// Whether this CResult_ChannelUpdateDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelUpdateDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ChannelUpdate) -> CResult_ChannelUpdateDecodeErrorZ {
	CResult_ChannelUpdateDecodeErrorZ {
		contents: CResult_ChannelUpdateDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelUpdateDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelUpdateDecodeErrorZ {
	CResult_ChannelUpdateDecodeErrorZ {
		contents: CResult_ChannelUpdateDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelUpdateDecodeErrorZ_is_ok(o: &CResult_ChannelUpdateDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelUpdateDecodeErrorZ.
pub extern "C" fn CResult_ChannelUpdateDecodeErrorZ_free(_res: CResult_ChannelUpdateDecodeErrorZ) { }
impl Drop for CResult_ChannelUpdateDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelUpdate, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelUpdateDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelUpdate, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelUpdateDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelUpdateDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelUpdateDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelUpdateDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ChannelUpdate>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelUpdateDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelUpdateDecodeErrorZ_clone(orig: &CResult_ChannelUpdateDecodeErrorZ) -> CResult_ChannelUpdateDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ErrorMessageDecodeErrorZ
pub union CResult_ErrorMessageDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ErrorMessage,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ErrorMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ErrorMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ErrorMessageDecodeErrorZ {
	/// The contents of this CResult_ErrorMessageDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ErrorMessageDecodeErrorZPtr,
	/// Whether this CResult_ErrorMessageDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ErrorMessageDecodeErrorZ in the success state.
pub extern "C" fn CResult_ErrorMessageDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ErrorMessage) -> CResult_ErrorMessageDecodeErrorZ {
	CResult_ErrorMessageDecodeErrorZ {
		contents: CResult_ErrorMessageDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ErrorMessageDecodeErrorZ in the error state.
pub extern "C" fn CResult_ErrorMessageDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ErrorMessageDecodeErrorZ {
	CResult_ErrorMessageDecodeErrorZ {
		contents: CResult_ErrorMessageDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ErrorMessageDecodeErrorZ_is_ok(o: &CResult_ErrorMessageDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ErrorMessageDecodeErrorZ.
pub extern "C" fn CResult_ErrorMessageDecodeErrorZ_free(_res: CResult_ErrorMessageDecodeErrorZ) { }
impl Drop for CResult_ErrorMessageDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ErrorMessage, crate::lightning::ln::msgs::DecodeError>> for CResult_ErrorMessageDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ErrorMessage, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ErrorMessageDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ErrorMessageDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ErrorMessageDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ErrorMessageDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ErrorMessage>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ErrorMessageDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ErrorMessageDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ErrorMessageDecodeErrorZ_clone(orig: &CResult_ErrorMessageDecodeErrorZ) -> CResult_ErrorMessageDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_WarningMessageDecodeErrorZ
pub union CResult_WarningMessageDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::WarningMessage,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_WarningMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::WarningMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_WarningMessageDecodeErrorZ {
	/// The contents of this CResult_WarningMessageDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_WarningMessageDecodeErrorZPtr,
	/// Whether this CResult_WarningMessageDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_WarningMessageDecodeErrorZ in the success state.
pub extern "C" fn CResult_WarningMessageDecodeErrorZ_ok(o: crate::lightning::ln::msgs::WarningMessage) -> CResult_WarningMessageDecodeErrorZ {
	CResult_WarningMessageDecodeErrorZ {
		contents: CResult_WarningMessageDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_WarningMessageDecodeErrorZ in the error state.
pub extern "C" fn CResult_WarningMessageDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_WarningMessageDecodeErrorZ {
	CResult_WarningMessageDecodeErrorZ {
		contents: CResult_WarningMessageDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_WarningMessageDecodeErrorZ_is_ok(o: &CResult_WarningMessageDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_WarningMessageDecodeErrorZ.
pub extern "C" fn CResult_WarningMessageDecodeErrorZ_free(_res: CResult_WarningMessageDecodeErrorZ) { }
impl Drop for CResult_WarningMessageDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::WarningMessage, crate::lightning::ln::msgs::DecodeError>> for CResult_WarningMessageDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::WarningMessage, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_WarningMessageDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_WarningMessageDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_WarningMessageDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_WarningMessageDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::WarningMessage>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_WarningMessageDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_WarningMessageDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_WarningMessageDecodeErrorZ_clone(orig: &CResult_WarningMessageDecodeErrorZ) -> CResult_WarningMessageDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UnsignedNodeAnnouncementDecodeErrorZ
pub union CResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UnsignedNodeAnnouncement,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UnsignedNodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UnsignedNodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	/// The contents of this CResult_UnsignedNodeAnnouncementDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UnsignedNodeAnnouncementDecodeErrorZPtr,
	/// Whether this CResult_UnsignedNodeAnnouncementDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the success state.
pub extern "C" fn CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UnsignedNodeAnnouncement) -> CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	CResult_UnsignedNodeAnnouncementDecodeErrorZ {
		contents: CResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the error state.
pub extern "C" fn CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	CResult_UnsignedNodeAnnouncementDecodeErrorZ {
		contents: CResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(o: &CResult_UnsignedNodeAnnouncementDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UnsignedNodeAnnouncementDecodeErrorZ.
pub extern "C" fn CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(_res: CResult_UnsignedNodeAnnouncementDecodeErrorZ) { }
impl Drop for CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedNodeAnnouncement, crate::lightning::ln::msgs::DecodeError>> for CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedNodeAnnouncement, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UnsignedNodeAnnouncementDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UnsignedNodeAnnouncementDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UnsignedNodeAnnouncement>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(orig: &CResult_UnsignedNodeAnnouncementDecodeErrorZ) -> CResult_UnsignedNodeAnnouncementDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NodeAnnouncementDecodeErrorZ
pub union CResult_NodeAnnouncementDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::NodeAnnouncement,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::NodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeAnnouncementDecodeErrorZ {
	/// The contents of this CResult_NodeAnnouncementDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeAnnouncementDecodeErrorZPtr,
	/// Whether this CResult_NodeAnnouncementDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeAnnouncementDecodeErrorZ_ok(o: crate::lightning::ln::msgs::NodeAnnouncement) -> CResult_NodeAnnouncementDecodeErrorZ {
	CResult_NodeAnnouncementDecodeErrorZ {
		contents: CResult_NodeAnnouncementDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeAnnouncementDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeAnnouncementDecodeErrorZ {
	CResult_NodeAnnouncementDecodeErrorZ {
		contents: CResult_NodeAnnouncementDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeAnnouncementDecodeErrorZ_is_ok(o: &CResult_NodeAnnouncementDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeAnnouncementDecodeErrorZ.
pub extern "C" fn CResult_NodeAnnouncementDecodeErrorZ_free(_res: CResult_NodeAnnouncementDecodeErrorZ) { }
impl Drop for CResult_NodeAnnouncementDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::NodeAnnouncement, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeAnnouncementDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::NodeAnnouncement, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeAnnouncementDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeAnnouncementDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeAnnouncementDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeAnnouncementDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::NodeAnnouncement>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeAnnouncementDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeAnnouncementDecodeErrorZ_clone(orig: &CResult_NodeAnnouncementDecodeErrorZ) -> CResult_NodeAnnouncementDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_QueryShortChannelIdsDecodeErrorZ
pub union CResult_QueryShortChannelIdsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::QueryShortChannelIds,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_QueryShortChannelIdsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::QueryShortChannelIds on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_QueryShortChannelIdsDecodeErrorZ {
	/// The contents of this CResult_QueryShortChannelIdsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_QueryShortChannelIdsDecodeErrorZPtr,
	/// Whether this CResult_QueryShortChannelIdsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the success state.
pub extern "C" fn CResult_QueryShortChannelIdsDecodeErrorZ_ok(o: crate::lightning::ln::msgs::QueryShortChannelIds) -> CResult_QueryShortChannelIdsDecodeErrorZ {
	CResult_QueryShortChannelIdsDecodeErrorZ {
		contents: CResult_QueryShortChannelIdsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the error state.
pub extern "C" fn CResult_QueryShortChannelIdsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_QueryShortChannelIdsDecodeErrorZ {
	CResult_QueryShortChannelIdsDecodeErrorZ {
		contents: CResult_QueryShortChannelIdsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(o: &CResult_QueryShortChannelIdsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_QueryShortChannelIdsDecodeErrorZ.
pub extern "C" fn CResult_QueryShortChannelIdsDecodeErrorZ_free(_res: CResult_QueryShortChannelIdsDecodeErrorZ) { }
impl Drop for CResult_QueryShortChannelIdsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::QueryShortChannelIds, crate::lightning::ln::msgs::DecodeError>> for CResult_QueryShortChannelIdsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::QueryShortChannelIds, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_QueryShortChannelIdsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_QueryShortChannelIdsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_QueryShortChannelIdsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_QueryShortChannelIdsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::QueryShortChannelIds>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_QueryShortChannelIdsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_QueryShortChannelIdsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_QueryShortChannelIdsDecodeErrorZ_clone(orig: &CResult_QueryShortChannelIdsDecodeErrorZ) -> CResult_QueryShortChannelIdsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ReplyShortChannelIdsEndDecodeErrorZ
pub union CResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ReplyShortChannelIdsEnd,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ReplyShortChannelIdsEndDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ReplyShortChannelIdsEnd on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	/// The contents of this CResult_ReplyShortChannelIdsEndDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ReplyShortChannelIdsEndDecodeErrorZPtr,
	/// Whether this CResult_ReplyShortChannelIdsEndDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the success state.
pub extern "C" fn CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ReplyShortChannelIdsEnd) -> CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	CResult_ReplyShortChannelIdsEndDecodeErrorZ {
		contents: CResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the error state.
pub extern "C" fn CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	CResult_ReplyShortChannelIdsEndDecodeErrorZ {
		contents: CResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(o: &CResult_ReplyShortChannelIdsEndDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ReplyShortChannelIdsEndDecodeErrorZ.
pub extern "C" fn CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(_res: CResult_ReplyShortChannelIdsEndDecodeErrorZ) { }
impl Drop for CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ReplyShortChannelIdsEnd, crate::lightning::ln::msgs::DecodeError>> for CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ReplyShortChannelIdsEnd, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ReplyShortChannelIdsEndDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ReplyShortChannelIdsEndDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ReplyShortChannelIdsEnd>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(orig: &CResult_ReplyShortChannelIdsEndDecodeErrorZ) -> CResult_ReplyShortChannelIdsEndDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_QueryChannelRangeDecodeErrorZ
pub union CResult_QueryChannelRangeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::QueryChannelRange,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_QueryChannelRangeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::QueryChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_QueryChannelRangeDecodeErrorZ {
	/// The contents of this CResult_QueryChannelRangeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_QueryChannelRangeDecodeErrorZPtr,
	/// Whether this CResult_QueryChannelRangeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_QueryChannelRangeDecodeErrorZ in the success state.
pub extern "C" fn CResult_QueryChannelRangeDecodeErrorZ_ok(o: crate::lightning::ln::msgs::QueryChannelRange) -> CResult_QueryChannelRangeDecodeErrorZ {
	CResult_QueryChannelRangeDecodeErrorZ {
		contents: CResult_QueryChannelRangeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_QueryChannelRangeDecodeErrorZ in the error state.
pub extern "C" fn CResult_QueryChannelRangeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_QueryChannelRangeDecodeErrorZ {
	CResult_QueryChannelRangeDecodeErrorZ {
		contents: CResult_QueryChannelRangeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_QueryChannelRangeDecodeErrorZ_is_ok(o: &CResult_QueryChannelRangeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_QueryChannelRangeDecodeErrorZ.
pub extern "C" fn CResult_QueryChannelRangeDecodeErrorZ_free(_res: CResult_QueryChannelRangeDecodeErrorZ) { }
impl Drop for CResult_QueryChannelRangeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::QueryChannelRange, crate::lightning::ln::msgs::DecodeError>> for CResult_QueryChannelRangeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::QueryChannelRange, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_QueryChannelRangeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_QueryChannelRangeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_QueryChannelRangeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_QueryChannelRangeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::QueryChannelRange>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_QueryChannelRangeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_QueryChannelRangeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_QueryChannelRangeDecodeErrorZ_clone(orig: &CResult_QueryChannelRangeDecodeErrorZ) -> CResult_QueryChannelRangeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ReplyChannelRangeDecodeErrorZ
pub union CResult_ReplyChannelRangeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ReplyChannelRange,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ReplyChannelRangeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ReplyChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ReplyChannelRangeDecodeErrorZ {
	/// The contents of this CResult_ReplyChannelRangeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ReplyChannelRangeDecodeErrorZPtr,
	/// Whether this CResult_ReplyChannelRangeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the success state.
pub extern "C" fn CResult_ReplyChannelRangeDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ReplyChannelRange) -> CResult_ReplyChannelRangeDecodeErrorZ {
	CResult_ReplyChannelRangeDecodeErrorZ {
		contents: CResult_ReplyChannelRangeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the error state.
pub extern "C" fn CResult_ReplyChannelRangeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ReplyChannelRangeDecodeErrorZ {
	CResult_ReplyChannelRangeDecodeErrorZ {
		contents: CResult_ReplyChannelRangeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ReplyChannelRangeDecodeErrorZ_is_ok(o: &CResult_ReplyChannelRangeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ReplyChannelRangeDecodeErrorZ.
pub extern "C" fn CResult_ReplyChannelRangeDecodeErrorZ_free(_res: CResult_ReplyChannelRangeDecodeErrorZ) { }
impl Drop for CResult_ReplyChannelRangeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ReplyChannelRange, crate::lightning::ln::msgs::DecodeError>> for CResult_ReplyChannelRangeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ReplyChannelRange, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ReplyChannelRangeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ReplyChannelRangeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ReplyChannelRangeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ReplyChannelRangeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ReplyChannelRange>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ReplyChannelRangeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ReplyChannelRangeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ReplyChannelRangeDecodeErrorZ_clone(orig: &CResult_ReplyChannelRangeDecodeErrorZ) -> CResult_ReplyChannelRangeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_GossipTimestampFilterDecodeErrorZ
pub union CResult_GossipTimestampFilterDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::GossipTimestampFilter,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_GossipTimestampFilterDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::GossipTimestampFilter on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_GossipTimestampFilterDecodeErrorZ {
	/// The contents of this CResult_GossipTimestampFilterDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_GossipTimestampFilterDecodeErrorZPtr,
	/// Whether this CResult_GossipTimestampFilterDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the success state.
pub extern "C" fn CResult_GossipTimestampFilterDecodeErrorZ_ok(o: crate::lightning::ln::msgs::GossipTimestampFilter) -> CResult_GossipTimestampFilterDecodeErrorZ {
	CResult_GossipTimestampFilterDecodeErrorZ {
		contents: CResult_GossipTimestampFilterDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the error state.
pub extern "C" fn CResult_GossipTimestampFilterDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_GossipTimestampFilterDecodeErrorZ {
	CResult_GossipTimestampFilterDecodeErrorZ {
		contents: CResult_GossipTimestampFilterDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_GossipTimestampFilterDecodeErrorZ_is_ok(o: &CResult_GossipTimestampFilterDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_GossipTimestampFilterDecodeErrorZ.
pub extern "C" fn CResult_GossipTimestampFilterDecodeErrorZ_free(_res: CResult_GossipTimestampFilterDecodeErrorZ) { }
impl Drop for CResult_GossipTimestampFilterDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::GossipTimestampFilter, crate::lightning::ln::msgs::DecodeError>> for CResult_GossipTimestampFilterDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::GossipTimestampFilter, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_GossipTimestampFilterDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_GossipTimestampFilterDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_GossipTimestampFilterDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_GossipTimestampFilterDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::GossipTimestampFilter>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_GossipTimestampFilterDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_GossipTimestampFilterDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_GossipTimestampFilterDecodeErrorZ_clone(orig: &CResult_GossipTimestampFilterDecodeErrorZ) -> CResult_GossipTimestampFilterDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::ln::channel_state::InboundHTLCStateDetails or not
pub enum COption_InboundHTLCStateDetailsZ {
	/// When we're in this state, this COption_InboundHTLCStateDetailsZ contains a crate::lightning::ln::channel_state::InboundHTLCStateDetails
	Some(crate::lightning::ln::channel_state::InboundHTLCStateDetails),
	/// When we're in this state, this COption_InboundHTLCStateDetailsZ contains nothing
	None
}
impl COption_InboundHTLCStateDetailsZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::ln::channel_state::InboundHTLCStateDetails {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_InboundHTLCStateDetailsZ containing a crate::lightning::ln::channel_state::InboundHTLCStateDetails
pub extern "C" fn COption_InboundHTLCStateDetailsZ_some(o: crate::lightning::ln::channel_state::InboundHTLCStateDetails) -> COption_InboundHTLCStateDetailsZ {
	COption_InboundHTLCStateDetailsZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_InboundHTLCStateDetailsZ containing nothing
pub extern "C" fn COption_InboundHTLCStateDetailsZ_none() -> COption_InboundHTLCStateDetailsZ {
	COption_InboundHTLCStateDetailsZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::ln::channel_state::InboundHTLCStateDetails, if we are in the Some state
pub extern "C" fn COption_InboundHTLCStateDetailsZ_free(_res: COption_InboundHTLCStateDetailsZ) { }
#[no_mangle]
/// Creates a new COption_InboundHTLCStateDetailsZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_InboundHTLCStateDetailsZ_clone(orig: &COption_InboundHTLCStateDetailsZ) -> COption_InboundHTLCStateDetailsZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ
pub union CResult_COption_InboundHTLCStateDetailsZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_InboundHTLCStateDetailsZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_InboundHTLCStateDetailsZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ {
	/// The contents of this CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_InboundHTLCStateDetailsZDecodeErrorZPtr,
	/// Whether this CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ_ok(o: crate::c_types::derived::COption_InboundHTLCStateDetailsZ) -> CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ {
	CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ {
		contents: CResult_COption_InboundHTLCStateDetailsZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ {
	CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ {
		contents: CResult_COption_InboundHTLCStateDetailsZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ_is_ok(o: &CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ.
pub extern "C" fn CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ_free(_res: CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ) { }
impl Drop for CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_InboundHTLCStateDetailsZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_InboundHTLCStateDetailsZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_InboundHTLCStateDetailsZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_InboundHTLCStateDetailsZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_InboundHTLCStateDetailsZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_InboundHTLCStateDetailsZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_InboundHTLCStateDetailsZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ_clone(orig: &CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ) -> CResult_COption_InboundHTLCStateDetailsZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InboundHTLCDetailsDecodeErrorZ
pub union CResult_InboundHTLCDetailsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_state::InboundHTLCDetails,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InboundHTLCDetailsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_state::InboundHTLCDetails on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InboundHTLCDetailsDecodeErrorZ {
	/// The contents of this CResult_InboundHTLCDetailsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InboundHTLCDetailsDecodeErrorZPtr,
	/// Whether this CResult_InboundHTLCDetailsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InboundHTLCDetailsDecodeErrorZ in the success state.
pub extern "C" fn CResult_InboundHTLCDetailsDecodeErrorZ_ok(o: crate::lightning::ln::channel_state::InboundHTLCDetails) -> CResult_InboundHTLCDetailsDecodeErrorZ {
	CResult_InboundHTLCDetailsDecodeErrorZ {
		contents: CResult_InboundHTLCDetailsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InboundHTLCDetailsDecodeErrorZ in the error state.
pub extern "C" fn CResult_InboundHTLCDetailsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InboundHTLCDetailsDecodeErrorZ {
	CResult_InboundHTLCDetailsDecodeErrorZ {
		contents: CResult_InboundHTLCDetailsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InboundHTLCDetailsDecodeErrorZ_is_ok(o: &CResult_InboundHTLCDetailsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InboundHTLCDetailsDecodeErrorZ.
pub extern "C" fn CResult_InboundHTLCDetailsDecodeErrorZ_free(_res: CResult_InboundHTLCDetailsDecodeErrorZ) { }
impl Drop for CResult_InboundHTLCDetailsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_state::InboundHTLCDetails, crate::lightning::ln::msgs::DecodeError>> for CResult_InboundHTLCDetailsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_state::InboundHTLCDetails, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InboundHTLCDetailsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InboundHTLCDetailsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InboundHTLCDetailsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InboundHTLCDetailsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_state::InboundHTLCDetails>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InboundHTLCDetailsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InboundHTLCDetailsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InboundHTLCDetailsDecodeErrorZ_clone(orig: &CResult_InboundHTLCDetailsDecodeErrorZ) -> CResult_InboundHTLCDetailsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::ln::channel_state::OutboundHTLCStateDetails or not
pub enum COption_OutboundHTLCStateDetailsZ {
	/// When we're in this state, this COption_OutboundHTLCStateDetailsZ contains a crate::lightning::ln::channel_state::OutboundHTLCStateDetails
	Some(crate::lightning::ln::channel_state::OutboundHTLCStateDetails),
	/// When we're in this state, this COption_OutboundHTLCStateDetailsZ contains nothing
	None
}
impl COption_OutboundHTLCStateDetailsZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::ln::channel_state::OutboundHTLCStateDetails {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_OutboundHTLCStateDetailsZ containing a crate::lightning::ln::channel_state::OutboundHTLCStateDetails
pub extern "C" fn COption_OutboundHTLCStateDetailsZ_some(o: crate::lightning::ln::channel_state::OutboundHTLCStateDetails) -> COption_OutboundHTLCStateDetailsZ {
	COption_OutboundHTLCStateDetailsZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_OutboundHTLCStateDetailsZ containing nothing
pub extern "C" fn COption_OutboundHTLCStateDetailsZ_none() -> COption_OutboundHTLCStateDetailsZ {
	COption_OutboundHTLCStateDetailsZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::ln::channel_state::OutboundHTLCStateDetails, if we are in the Some state
pub extern "C" fn COption_OutboundHTLCStateDetailsZ_free(_res: COption_OutboundHTLCStateDetailsZ) { }
#[no_mangle]
/// Creates a new COption_OutboundHTLCStateDetailsZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_OutboundHTLCStateDetailsZ_clone(orig: &COption_OutboundHTLCStateDetailsZ) -> COption_OutboundHTLCStateDetailsZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ
pub union CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_OutboundHTLCStateDetailsZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_OutboundHTLCStateDetailsZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ {
	/// The contents of this CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZPtr,
	/// Whether this CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ_ok(o: crate::c_types::derived::COption_OutboundHTLCStateDetailsZ) -> CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ {
	CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ {
		contents: CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ {
	CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ {
		contents: CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ_is_ok(o: &CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ.
pub extern "C" fn CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ_free(_res: CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ) { }
impl Drop for CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_OutboundHTLCStateDetailsZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_OutboundHTLCStateDetailsZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_OutboundHTLCStateDetailsZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ_clone(orig: &CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ) -> CResult_COption_OutboundHTLCStateDetailsZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OutboundHTLCDetailsDecodeErrorZ
pub union CResult_OutboundHTLCDetailsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_state::OutboundHTLCDetails,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OutboundHTLCDetailsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_state::OutboundHTLCDetails on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OutboundHTLCDetailsDecodeErrorZ {
	/// The contents of this CResult_OutboundHTLCDetailsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OutboundHTLCDetailsDecodeErrorZPtr,
	/// Whether this CResult_OutboundHTLCDetailsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OutboundHTLCDetailsDecodeErrorZ in the success state.
pub extern "C" fn CResult_OutboundHTLCDetailsDecodeErrorZ_ok(o: crate::lightning::ln::channel_state::OutboundHTLCDetails) -> CResult_OutboundHTLCDetailsDecodeErrorZ {
	CResult_OutboundHTLCDetailsDecodeErrorZ {
		contents: CResult_OutboundHTLCDetailsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OutboundHTLCDetailsDecodeErrorZ in the error state.
pub extern "C" fn CResult_OutboundHTLCDetailsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OutboundHTLCDetailsDecodeErrorZ {
	CResult_OutboundHTLCDetailsDecodeErrorZ {
		contents: CResult_OutboundHTLCDetailsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OutboundHTLCDetailsDecodeErrorZ_is_ok(o: &CResult_OutboundHTLCDetailsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OutboundHTLCDetailsDecodeErrorZ.
pub extern "C" fn CResult_OutboundHTLCDetailsDecodeErrorZ_free(_res: CResult_OutboundHTLCDetailsDecodeErrorZ) { }
impl Drop for CResult_OutboundHTLCDetailsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_state::OutboundHTLCDetails, crate::lightning::ln::msgs::DecodeError>> for CResult_OutboundHTLCDetailsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_state::OutboundHTLCDetails, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OutboundHTLCDetailsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OutboundHTLCDetailsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OutboundHTLCDetailsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OutboundHTLCDetailsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_state::OutboundHTLCDetails>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OutboundHTLCDetailsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OutboundHTLCDetailsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OutboundHTLCDetailsDecodeErrorZ_clone(orig: &CResult_OutboundHTLCDetailsDecodeErrorZ) -> CResult_OutboundHTLCDetailsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CounterpartyForwardingInfoDecodeErrorZ
pub union CResult_CounterpartyForwardingInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_state::CounterpartyForwardingInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CounterpartyForwardingInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_state::CounterpartyForwardingInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CounterpartyForwardingInfoDecodeErrorZ {
	/// The contents of this CResult_CounterpartyForwardingInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CounterpartyForwardingInfoDecodeErrorZPtr,
	/// Whether this CResult_CounterpartyForwardingInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(o: crate::lightning::ln::channel_state::CounterpartyForwardingInfo) -> CResult_CounterpartyForwardingInfoDecodeErrorZ {
	CResult_CounterpartyForwardingInfoDecodeErrorZ {
		contents: CResult_CounterpartyForwardingInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_CounterpartyForwardingInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CounterpartyForwardingInfoDecodeErrorZ {
	CResult_CounterpartyForwardingInfoDecodeErrorZ {
		contents: CResult_CounterpartyForwardingInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(o: &CResult_CounterpartyForwardingInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CounterpartyForwardingInfoDecodeErrorZ.
pub extern "C" fn CResult_CounterpartyForwardingInfoDecodeErrorZ_free(_res: CResult_CounterpartyForwardingInfoDecodeErrorZ) { }
impl Drop for CResult_CounterpartyForwardingInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_state::CounterpartyForwardingInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_CounterpartyForwardingInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_state::CounterpartyForwardingInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CounterpartyForwardingInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CounterpartyForwardingInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CounterpartyForwardingInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CounterpartyForwardingInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_state::CounterpartyForwardingInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CounterpartyForwardingInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(orig: &CResult_CounterpartyForwardingInfoDecodeErrorZ) -> CResult_CounterpartyForwardingInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelCounterpartyDecodeErrorZ
pub union CResult_ChannelCounterpartyDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_state::ChannelCounterparty,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelCounterpartyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_state::ChannelCounterparty on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelCounterpartyDecodeErrorZ {
	/// The contents of this CResult_ChannelCounterpartyDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelCounterpartyDecodeErrorZPtr,
	/// Whether this CResult_ChannelCounterpartyDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelCounterpartyDecodeErrorZ_ok(o: crate::lightning::ln::channel_state::ChannelCounterparty) -> CResult_ChannelCounterpartyDecodeErrorZ {
	CResult_ChannelCounterpartyDecodeErrorZ {
		contents: CResult_ChannelCounterpartyDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelCounterpartyDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelCounterpartyDecodeErrorZ {
	CResult_ChannelCounterpartyDecodeErrorZ {
		contents: CResult_ChannelCounterpartyDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelCounterpartyDecodeErrorZ_is_ok(o: &CResult_ChannelCounterpartyDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelCounterpartyDecodeErrorZ.
pub extern "C" fn CResult_ChannelCounterpartyDecodeErrorZ_free(_res: CResult_ChannelCounterpartyDecodeErrorZ) { }
impl Drop for CResult_ChannelCounterpartyDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_state::ChannelCounterparty, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelCounterpartyDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_state::ChannelCounterparty, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelCounterpartyDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelCounterpartyDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelCounterpartyDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelCounterpartyDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_state::ChannelCounterparty>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelCounterpartyDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelCounterpartyDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelCounterpartyDecodeErrorZ_clone(orig: &CResult_ChannelCounterpartyDecodeErrorZ) -> CResult_ChannelCounterpartyDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::ln::channel_state::ChannelShutdownState or not
pub enum COption_ChannelShutdownStateZ {
	/// When we're in this state, this COption_ChannelShutdownStateZ contains a crate::lightning::ln::channel_state::ChannelShutdownState
	Some(crate::lightning::ln::channel_state::ChannelShutdownState),
	/// When we're in this state, this COption_ChannelShutdownStateZ contains nothing
	None
}
impl COption_ChannelShutdownStateZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::ln::channel_state::ChannelShutdownState {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_ChannelShutdownStateZ containing a crate::lightning::ln::channel_state::ChannelShutdownState
pub extern "C" fn COption_ChannelShutdownStateZ_some(o: crate::lightning::ln::channel_state::ChannelShutdownState) -> COption_ChannelShutdownStateZ {
	COption_ChannelShutdownStateZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_ChannelShutdownStateZ containing nothing
pub extern "C" fn COption_ChannelShutdownStateZ_none() -> COption_ChannelShutdownStateZ {
	COption_ChannelShutdownStateZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::ln::channel_state::ChannelShutdownState, if we are in the Some state
pub extern "C" fn COption_ChannelShutdownStateZ_free(_res: COption_ChannelShutdownStateZ) { }
#[no_mangle]
/// Creates a new COption_ChannelShutdownStateZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_ChannelShutdownStateZ_clone(orig: &COption_ChannelShutdownStateZ) -> COption_ChannelShutdownStateZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::channel_state::InboundHTLCDetailss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_InboundHTLCDetailsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::channel_state::InboundHTLCDetails,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_InboundHTLCDetailsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::channel_state::InboundHTLCDetails> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::channel_state::InboundHTLCDetails] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::channel_state::InboundHTLCDetails>> for CVec_InboundHTLCDetailsZ {
	fn from(v: Vec<crate::lightning::ln::channel_state::InboundHTLCDetails>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_InboundHTLCDetailsZ_free(_res: CVec_InboundHTLCDetailsZ) { }
impl Drop for CVec_InboundHTLCDetailsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_InboundHTLCDetailsZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::channel_state::OutboundHTLCDetailss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_OutboundHTLCDetailsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::channel_state::OutboundHTLCDetails,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_OutboundHTLCDetailsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::channel_state::OutboundHTLCDetails> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::channel_state::OutboundHTLCDetails] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::channel_state::OutboundHTLCDetails>> for CVec_OutboundHTLCDetailsZ {
	fn from(v: Vec<crate::lightning::ln::channel_state::OutboundHTLCDetails>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_OutboundHTLCDetailsZ_free(_res: CVec_OutboundHTLCDetailsZ) { }
impl Drop for CVec_OutboundHTLCDetailsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_OutboundHTLCDetailsZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_ChannelDetailsDecodeErrorZ
pub union CResult_ChannelDetailsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_state::ChannelDetails,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelDetailsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_state::ChannelDetails on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelDetailsDecodeErrorZ {
	/// The contents of this CResult_ChannelDetailsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelDetailsDecodeErrorZPtr,
	/// Whether this CResult_ChannelDetailsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelDetailsDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelDetailsDecodeErrorZ_ok(o: crate::lightning::ln::channel_state::ChannelDetails) -> CResult_ChannelDetailsDecodeErrorZ {
	CResult_ChannelDetailsDecodeErrorZ {
		contents: CResult_ChannelDetailsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelDetailsDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelDetailsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelDetailsDecodeErrorZ {
	CResult_ChannelDetailsDecodeErrorZ {
		contents: CResult_ChannelDetailsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelDetailsDecodeErrorZ_is_ok(o: &CResult_ChannelDetailsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelDetailsDecodeErrorZ.
pub extern "C" fn CResult_ChannelDetailsDecodeErrorZ_free(_res: CResult_ChannelDetailsDecodeErrorZ) { }
impl Drop for CResult_ChannelDetailsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_state::ChannelDetails, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelDetailsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_state::ChannelDetails, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelDetailsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelDetailsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelDetailsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelDetailsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_state::ChannelDetails>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelDetailsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelDetailsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelDetailsDecodeErrorZ_clone(orig: &CResult_ChannelDetailsDecodeErrorZ) -> CResult_ChannelDetailsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelShutdownStateDecodeErrorZ
pub union CResult_ChannelShutdownStateDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_state::ChannelShutdownState,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelShutdownStateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_state::ChannelShutdownState on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelShutdownStateDecodeErrorZ {
	/// The contents of this CResult_ChannelShutdownStateDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelShutdownStateDecodeErrorZPtr,
	/// Whether this CResult_ChannelShutdownStateDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelShutdownStateDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelShutdownStateDecodeErrorZ_ok(o: crate::lightning::ln::channel_state::ChannelShutdownState) -> CResult_ChannelShutdownStateDecodeErrorZ {
	CResult_ChannelShutdownStateDecodeErrorZ {
		contents: CResult_ChannelShutdownStateDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelShutdownStateDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelShutdownStateDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelShutdownStateDecodeErrorZ {
	CResult_ChannelShutdownStateDecodeErrorZ {
		contents: CResult_ChannelShutdownStateDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelShutdownStateDecodeErrorZ_is_ok(o: &CResult_ChannelShutdownStateDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelShutdownStateDecodeErrorZ.
pub extern "C" fn CResult_ChannelShutdownStateDecodeErrorZ_free(_res: CResult_ChannelShutdownStateDecodeErrorZ) { }
impl Drop for CResult_ChannelShutdownStateDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_state::ChannelShutdownState, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelShutdownStateDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_state::ChannelShutdownState, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelShutdownStateDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelShutdownStateDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelShutdownStateDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelShutdownStateDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_state::ChannelShutdownState>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelShutdownStateDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelShutdownStateDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelShutdownStateDecodeErrorZ_clone(orig: &CResult_ChannelShutdownStateDecodeErrorZ) -> CResult_ChannelShutdownStateDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::util::wakers::Futures of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_FutureZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::util::wakers::Future,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_FutureZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::util::wakers::Future> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::util::wakers::Future] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::util::wakers::Future>> for CVec_FutureZ {
	fn from(v: Vec<crate::lightning::util::wakers::Future>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_FutureZ_free(_res: CVec_FutureZ) { }
impl Drop for CVec_FutureZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
#[repr(C)]
/// The contents of CResult_HeldHtlcAvailableDecodeErrorZ
pub union CResult_HeldHtlcAvailableDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::async_payments::HeldHtlcAvailable,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HeldHtlcAvailableDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::async_payments::HeldHtlcAvailable on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HeldHtlcAvailableDecodeErrorZ {
	/// The contents of this CResult_HeldHtlcAvailableDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HeldHtlcAvailableDecodeErrorZPtr,
	/// Whether this CResult_HeldHtlcAvailableDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HeldHtlcAvailableDecodeErrorZ in the success state.
pub extern "C" fn CResult_HeldHtlcAvailableDecodeErrorZ_ok(o: crate::lightning::onion_message::async_payments::HeldHtlcAvailable) -> CResult_HeldHtlcAvailableDecodeErrorZ {
	CResult_HeldHtlcAvailableDecodeErrorZ {
		contents: CResult_HeldHtlcAvailableDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HeldHtlcAvailableDecodeErrorZ in the error state.
pub extern "C" fn CResult_HeldHtlcAvailableDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HeldHtlcAvailableDecodeErrorZ {
	CResult_HeldHtlcAvailableDecodeErrorZ {
		contents: CResult_HeldHtlcAvailableDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HeldHtlcAvailableDecodeErrorZ_is_ok(o: &CResult_HeldHtlcAvailableDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HeldHtlcAvailableDecodeErrorZ.
pub extern "C" fn CResult_HeldHtlcAvailableDecodeErrorZ_free(_res: CResult_HeldHtlcAvailableDecodeErrorZ) { }
impl Drop for CResult_HeldHtlcAvailableDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::async_payments::HeldHtlcAvailable, crate::lightning::ln::msgs::DecodeError>> for CResult_HeldHtlcAvailableDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::async_payments::HeldHtlcAvailable, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HeldHtlcAvailableDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HeldHtlcAvailableDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HeldHtlcAvailableDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HeldHtlcAvailableDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::async_payments::HeldHtlcAvailable>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HeldHtlcAvailableDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HeldHtlcAvailableDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HeldHtlcAvailableDecodeErrorZ_clone(orig: &CResult_HeldHtlcAvailableDecodeErrorZ) -> CResult_HeldHtlcAvailableDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ReleaseHeldHtlcDecodeErrorZ
pub union CResult_ReleaseHeldHtlcDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::async_payments::ReleaseHeldHtlc,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ReleaseHeldHtlcDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::async_payments::ReleaseHeldHtlc on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ReleaseHeldHtlcDecodeErrorZ {
	/// The contents of this CResult_ReleaseHeldHtlcDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ReleaseHeldHtlcDecodeErrorZPtr,
	/// Whether this CResult_ReleaseHeldHtlcDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ReleaseHeldHtlcDecodeErrorZ in the success state.
pub extern "C" fn CResult_ReleaseHeldHtlcDecodeErrorZ_ok(o: crate::lightning::onion_message::async_payments::ReleaseHeldHtlc) -> CResult_ReleaseHeldHtlcDecodeErrorZ {
	CResult_ReleaseHeldHtlcDecodeErrorZ {
		contents: CResult_ReleaseHeldHtlcDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ReleaseHeldHtlcDecodeErrorZ in the error state.
pub extern "C" fn CResult_ReleaseHeldHtlcDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ReleaseHeldHtlcDecodeErrorZ {
	CResult_ReleaseHeldHtlcDecodeErrorZ {
		contents: CResult_ReleaseHeldHtlcDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ReleaseHeldHtlcDecodeErrorZ_is_ok(o: &CResult_ReleaseHeldHtlcDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ReleaseHeldHtlcDecodeErrorZ.
pub extern "C" fn CResult_ReleaseHeldHtlcDecodeErrorZ_free(_res: CResult_ReleaseHeldHtlcDecodeErrorZ) { }
impl Drop for CResult_ReleaseHeldHtlcDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::async_payments::ReleaseHeldHtlc, crate::lightning::ln::msgs::DecodeError>> for CResult_ReleaseHeldHtlcDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::async_payments::ReleaseHeldHtlc, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ReleaseHeldHtlcDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ReleaseHeldHtlcDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ReleaseHeldHtlcDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ReleaseHeldHtlcDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::async_payments::ReleaseHeldHtlc>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ReleaseHeldHtlcDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ReleaseHeldHtlcDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ReleaseHeldHtlcDecodeErrorZ_clone(orig: &CResult_ReleaseHeldHtlcDecodeErrorZ) -> CResult_ReleaseHeldHtlcDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_AsyncPaymentsMessageDecodeErrorZ
pub union CResult_AsyncPaymentsMessageDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::async_payments::AsyncPaymentsMessage,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_AsyncPaymentsMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::async_payments::AsyncPaymentsMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_AsyncPaymentsMessageDecodeErrorZ {
	/// The contents of this CResult_AsyncPaymentsMessageDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_AsyncPaymentsMessageDecodeErrorZPtr,
	/// Whether this CResult_AsyncPaymentsMessageDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_AsyncPaymentsMessageDecodeErrorZ in the success state.
pub extern "C" fn CResult_AsyncPaymentsMessageDecodeErrorZ_ok(o: crate::lightning::onion_message::async_payments::AsyncPaymentsMessage) -> CResult_AsyncPaymentsMessageDecodeErrorZ {
	CResult_AsyncPaymentsMessageDecodeErrorZ {
		contents: CResult_AsyncPaymentsMessageDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_AsyncPaymentsMessageDecodeErrorZ in the error state.
pub extern "C" fn CResult_AsyncPaymentsMessageDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_AsyncPaymentsMessageDecodeErrorZ {
	CResult_AsyncPaymentsMessageDecodeErrorZ {
		contents: CResult_AsyncPaymentsMessageDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_AsyncPaymentsMessageDecodeErrorZ_is_ok(o: &CResult_AsyncPaymentsMessageDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_AsyncPaymentsMessageDecodeErrorZ.
pub extern "C" fn CResult_AsyncPaymentsMessageDecodeErrorZ_free(_res: CResult_AsyncPaymentsMessageDecodeErrorZ) { }
impl Drop for CResult_AsyncPaymentsMessageDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::async_payments::AsyncPaymentsMessage, crate::lightning::ln::msgs::DecodeError>> for CResult_AsyncPaymentsMessageDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::async_payments::AsyncPaymentsMessage, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_AsyncPaymentsMessageDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_AsyncPaymentsMessageDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_AsyncPaymentsMessageDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_AsyncPaymentsMessageDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::async_payments::AsyncPaymentsMessage>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_AsyncPaymentsMessageDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_AsyncPaymentsMessageDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_AsyncPaymentsMessageDecodeErrorZ_clone(orig: &CResult_AsyncPaymentsMessageDecodeErrorZ) -> CResult_AsyncPaymentsMessageDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OffersMessageDecodeErrorZ
pub union CResult_OffersMessageDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::offers::OffersMessage,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OffersMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::offers::OffersMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OffersMessageDecodeErrorZ {
	/// The contents of this CResult_OffersMessageDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OffersMessageDecodeErrorZPtr,
	/// Whether this CResult_OffersMessageDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OffersMessageDecodeErrorZ in the success state.
pub extern "C" fn CResult_OffersMessageDecodeErrorZ_ok(o: crate::lightning::onion_message::offers::OffersMessage) -> CResult_OffersMessageDecodeErrorZ {
	CResult_OffersMessageDecodeErrorZ {
		contents: CResult_OffersMessageDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OffersMessageDecodeErrorZ in the error state.
pub extern "C" fn CResult_OffersMessageDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OffersMessageDecodeErrorZ {
	CResult_OffersMessageDecodeErrorZ {
		contents: CResult_OffersMessageDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OffersMessageDecodeErrorZ_is_ok(o: &CResult_OffersMessageDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OffersMessageDecodeErrorZ.
pub extern "C" fn CResult_OffersMessageDecodeErrorZ_free(_res: CResult_OffersMessageDecodeErrorZ) { }
impl Drop for CResult_OffersMessageDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::offers::OffersMessage, crate::lightning::ln::msgs::DecodeError>> for CResult_OffersMessageDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::offers::OffersMessage, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OffersMessageDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OffersMessageDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OffersMessageDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OffersMessageDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::offers::OffersMessage>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OffersMessageDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OffersMessageDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OffersMessageDecodeErrorZ_clone(orig: &CResult_OffersMessageDecodeErrorZ) -> CResult_OffersMessageDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// An enum which can either contain a crate::lightning::ln::chan_utils::HTLCClaim or not
pub enum COption_HTLCClaimZ {
	/// When we're in this state, this COption_HTLCClaimZ contains a crate::lightning::ln::chan_utils::HTLCClaim
	Some(crate::lightning::ln::chan_utils::HTLCClaim),
	/// When we're in this state, this COption_HTLCClaimZ contains nothing
	None
}
impl COption_HTLCClaimZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::ln::chan_utils::HTLCClaim {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_HTLCClaimZ containing a crate::lightning::ln::chan_utils::HTLCClaim
pub extern "C" fn COption_HTLCClaimZ_some(o: crate::lightning::ln::chan_utils::HTLCClaim) -> COption_HTLCClaimZ {
	COption_HTLCClaimZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_HTLCClaimZ containing nothing
pub extern "C" fn COption_HTLCClaimZ_none() -> COption_HTLCClaimZ {
	COption_HTLCClaimZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::ln::chan_utils::HTLCClaim, if we are in the Some state
pub extern "C" fn COption_HTLCClaimZ_free(_res: COption_HTLCClaimZ) { }
#[repr(C)]
/// The contents of CResult_CounterpartyCommitmentSecretsDecodeErrorZ
pub union CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	/// The contents of this CResult_CounterpartyCommitmentSecretsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr,
	/// Whether this CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the success state.
pub extern "C" fn CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets) -> CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
		contents: CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the error state.
pub extern "C" fn CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
		contents: CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(o: &CResult_CounterpartyCommitmentSecretsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CounterpartyCommitmentSecretsDecodeErrorZ.
pub extern "C" fn CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(_res: CResult_CounterpartyCommitmentSecretsDecodeErrorZ) { }
impl Drop for CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets, crate::lightning::ln::msgs::DecodeError>> for CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(orig: &CResult_CounterpartyCommitmentSecretsDecodeErrorZ) -> CResult_CounterpartyCommitmentSecretsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxCreationKeysDecodeErrorZ
pub union CResult_TxCreationKeysDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::TxCreationKeys,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxCreationKeysDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::TxCreationKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxCreationKeysDecodeErrorZ {
	/// The contents of this CResult_TxCreationKeysDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxCreationKeysDecodeErrorZPtr,
	/// Whether this CResult_TxCreationKeysDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxCreationKeysDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxCreationKeysDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::TxCreationKeys) -> CResult_TxCreationKeysDecodeErrorZ {
	CResult_TxCreationKeysDecodeErrorZ {
		contents: CResult_TxCreationKeysDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxCreationKeysDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxCreationKeysDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxCreationKeysDecodeErrorZ {
	CResult_TxCreationKeysDecodeErrorZ {
		contents: CResult_TxCreationKeysDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxCreationKeysDecodeErrorZ_is_ok(o: &CResult_TxCreationKeysDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxCreationKeysDecodeErrorZ.
pub extern "C" fn CResult_TxCreationKeysDecodeErrorZ_free(_res: CResult_TxCreationKeysDecodeErrorZ) { }
impl Drop for CResult_TxCreationKeysDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TxCreationKeys, crate::lightning::ln::msgs::DecodeError>> for CResult_TxCreationKeysDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TxCreationKeys, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxCreationKeysDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxCreationKeysDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxCreationKeysDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxCreationKeysDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::TxCreationKeys>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxCreationKeysDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxCreationKeysDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxCreationKeysDecodeErrorZ_clone(orig: &CResult_TxCreationKeysDecodeErrorZ) -> CResult_TxCreationKeysDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelPublicKeysDecodeErrorZ
pub union CResult_ChannelPublicKeysDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::ChannelPublicKeys,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelPublicKeysDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::ChannelPublicKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelPublicKeysDecodeErrorZ {
	/// The contents of this CResult_ChannelPublicKeysDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelPublicKeysDecodeErrorZPtr,
	/// Whether this CResult_ChannelPublicKeysDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelPublicKeysDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::ChannelPublicKeys) -> CResult_ChannelPublicKeysDecodeErrorZ {
	CResult_ChannelPublicKeysDecodeErrorZ {
		contents: CResult_ChannelPublicKeysDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelPublicKeysDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelPublicKeysDecodeErrorZ {
	CResult_ChannelPublicKeysDecodeErrorZ {
		contents: CResult_ChannelPublicKeysDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelPublicKeysDecodeErrorZ_is_ok(o: &CResult_ChannelPublicKeysDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelPublicKeysDecodeErrorZ.
pub extern "C" fn CResult_ChannelPublicKeysDecodeErrorZ_free(_res: CResult_ChannelPublicKeysDecodeErrorZ) { }
impl Drop for CResult_ChannelPublicKeysDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::ChannelPublicKeys, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelPublicKeysDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::ChannelPublicKeys, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelPublicKeysDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelPublicKeysDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelPublicKeysDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelPublicKeysDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::ChannelPublicKeys>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelPublicKeysDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelPublicKeysDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelPublicKeysDecodeErrorZ_clone(orig: &CResult_ChannelPublicKeysDecodeErrorZ) -> CResult_ChannelPublicKeysDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HTLCOutputInCommitmentDecodeErrorZ
pub union CResult_HTLCOutputInCommitmentDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::HTLCOutputInCommitment,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HTLCOutputInCommitmentDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::HTLCOutputInCommitment on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HTLCOutputInCommitmentDecodeErrorZ {
	/// The contents of this CResult_HTLCOutputInCommitmentDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HTLCOutputInCommitmentDecodeErrorZPtr,
	/// Whether this CResult_HTLCOutputInCommitmentDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the success state.
pub extern "C" fn CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::HTLCOutputInCommitment) -> CResult_HTLCOutputInCommitmentDecodeErrorZ {
	CResult_HTLCOutputInCommitmentDecodeErrorZ {
		contents: CResult_HTLCOutputInCommitmentDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the error state.
pub extern "C" fn CResult_HTLCOutputInCommitmentDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HTLCOutputInCommitmentDecodeErrorZ {
	CResult_HTLCOutputInCommitmentDecodeErrorZ {
		contents: CResult_HTLCOutputInCommitmentDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(o: &CResult_HTLCOutputInCommitmentDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HTLCOutputInCommitmentDecodeErrorZ.
pub extern "C" fn CResult_HTLCOutputInCommitmentDecodeErrorZ_free(_res: CResult_HTLCOutputInCommitmentDecodeErrorZ) { }
impl Drop for CResult_HTLCOutputInCommitmentDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::HTLCOutputInCommitment, crate::lightning::ln::msgs::DecodeError>> for CResult_HTLCOutputInCommitmentDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::HTLCOutputInCommitment, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HTLCOutputInCommitmentDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HTLCOutputInCommitmentDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HTLCOutputInCommitmentDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HTLCOutputInCommitmentDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::HTLCOutputInCommitment>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HTLCOutputInCommitmentDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(orig: &CResult_HTLCOutputInCommitmentDecodeErrorZ) -> CResult_HTLCOutputInCommitmentDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CounterpartyChannelTransactionParametersDecodeErrorZ
pub union CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	/// The contents of this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr,
	/// Whether this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the success state.
pub extern "C" fn CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters) -> CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
		contents: CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the error state.
pub extern "C" fn CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
		contents: CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(o: &CResult_CounterpartyChannelTransactionParametersDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CounterpartyChannelTransactionParametersDecodeErrorZ.
pub extern "C" fn CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(_res: CResult_CounterpartyChannelTransactionParametersDecodeErrorZ) { }
impl Drop for CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters, crate::lightning::ln::msgs::DecodeError>> for CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(orig: &CResult_CounterpartyChannelTransactionParametersDecodeErrorZ) -> CResult_CounterpartyChannelTransactionParametersDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelTransactionParametersDecodeErrorZ
pub union CResult_ChannelTransactionParametersDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::ChannelTransactionParameters,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::ChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelTransactionParametersDecodeErrorZ {
	/// The contents of this CResult_ChannelTransactionParametersDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelTransactionParametersDecodeErrorZPtr,
	/// Whether this CResult_ChannelTransactionParametersDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelTransactionParametersDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::ChannelTransactionParameters) -> CResult_ChannelTransactionParametersDecodeErrorZ {
	CResult_ChannelTransactionParametersDecodeErrorZ {
		contents: CResult_ChannelTransactionParametersDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelTransactionParametersDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelTransactionParametersDecodeErrorZ {
	CResult_ChannelTransactionParametersDecodeErrorZ {
		contents: CResult_ChannelTransactionParametersDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(o: &CResult_ChannelTransactionParametersDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelTransactionParametersDecodeErrorZ.
pub extern "C" fn CResult_ChannelTransactionParametersDecodeErrorZ_free(_res: CResult_ChannelTransactionParametersDecodeErrorZ) { }
impl Drop for CResult_ChannelTransactionParametersDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::ChannelTransactionParameters, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelTransactionParametersDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::ChannelTransactionParameters, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelTransactionParametersDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelTransactionParametersDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelTransactionParametersDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelTransactionParametersDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::ChannelTransactionParameters>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelTransactionParametersDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelTransactionParametersDecodeErrorZ_clone(orig: &CResult_ChannelTransactionParametersDecodeErrorZ) -> CResult_ChannelTransactionParametersDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HolderCommitmentTransactionDecodeErrorZ
pub union CResult_HolderCommitmentTransactionDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::HolderCommitmentTransaction,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HolderCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::HolderCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HolderCommitmentTransactionDecodeErrorZ {
	/// The contents of this CResult_HolderCommitmentTransactionDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HolderCommitmentTransactionDecodeErrorZPtr,
	/// Whether this CResult_HolderCommitmentTransactionDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the success state.
pub extern "C" fn CResult_HolderCommitmentTransactionDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::HolderCommitmentTransaction) -> CResult_HolderCommitmentTransactionDecodeErrorZ {
	CResult_HolderCommitmentTransactionDecodeErrorZ {
		contents: CResult_HolderCommitmentTransactionDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the error state.
pub extern "C" fn CResult_HolderCommitmentTransactionDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HolderCommitmentTransactionDecodeErrorZ {
	CResult_HolderCommitmentTransactionDecodeErrorZ {
		contents: CResult_HolderCommitmentTransactionDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(o: &CResult_HolderCommitmentTransactionDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HolderCommitmentTransactionDecodeErrorZ.
pub extern "C" fn CResult_HolderCommitmentTransactionDecodeErrorZ_free(_res: CResult_HolderCommitmentTransactionDecodeErrorZ) { }
impl Drop for CResult_HolderCommitmentTransactionDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::HolderCommitmentTransaction, crate::lightning::ln::msgs::DecodeError>> for CResult_HolderCommitmentTransactionDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::HolderCommitmentTransaction, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HolderCommitmentTransactionDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HolderCommitmentTransactionDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HolderCommitmentTransactionDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HolderCommitmentTransactionDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::HolderCommitmentTransaction>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HolderCommitmentTransactionDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HolderCommitmentTransactionDecodeErrorZ_clone(orig: &CResult_HolderCommitmentTransactionDecodeErrorZ) -> CResult_HolderCommitmentTransactionDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BuiltCommitmentTransactionDecodeErrorZ
pub union CResult_BuiltCommitmentTransactionDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::BuiltCommitmentTransaction,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BuiltCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::BuiltCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BuiltCommitmentTransactionDecodeErrorZ {
	/// The contents of this CResult_BuiltCommitmentTransactionDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BuiltCommitmentTransactionDecodeErrorZPtr,
	/// Whether this CResult_BuiltCommitmentTransactionDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the success state.
pub extern "C" fn CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::BuiltCommitmentTransaction) -> CResult_BuiltCommitmentTransactionDecodeErrorZ {
	CResult_BuiltCommitmentTransactionDecodeErrorZ {
		contents: CResult_BuiltCommitmentTransactionDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the error state.
pub extern "C" fn CResult_BuiltCommitmentTransactionDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BuiltCommitmentTransactionDecodeErrorZ {
	CResult_BuiltCommitmentTransactionDecodeErrorZ {
		contents: CResult_BuiltCommitmentTransactionDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(o: &CResult_BuiltCommitmentTransactionDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BuiltCommitmentTransactionDecodeErrorZ.
pub extern "C" fn CResult_BuiltCommitmentTransactionDecodeErrorZ_free(_res: CResult_BuiltCommitmentTransactionDecodeErrorZ) { }
impl Drop for CResult_BuiltCommitmentTransactionDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::BuiltCommitmentTransaction, crate::lightning::ln::msgs::DecodeError>> for CResult_BuiltCommitmentTransactionDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::BuiltCommitmentTransaction, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BuiltCommitmentTransactionDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BuiltCommitmentTransactionDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BuiltCommitmentTransactionDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BuiltCommitmentTransactionDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::BuiltCommitmentTransaction>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BuiltCommitmentTransactionDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(orig: &CResult_BuiltCommitmentTransactionDecodeErrorZ) -> CResult_BuiltCommitmentTransactionDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TrustedClosingTransactionNoneZ
pub union CResult_TrustedClosingTransactionNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::TrustedClosingTransaction,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_TrustedClosingTransactionNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::TrustedClosingTransaction on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TrustedClosingTransactionNoneZ {
	/// The contents of this CResult_TrustedClosingTransactionNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TrustedClosingTransactionNoneZPtr,
	/// Whether this CResult_TrustedClosingTransactionNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TrustedClosingTransactionNoneZ in the success state.
pub extern "C" fn CResult_TrustedClosingTransactionNoneZ_ok(o: crate::lightning::ln::chan_utils::TrustedClosingTransaction) -> CResult_TrustedClosingTransactionNoneZ {
	CResult_TrustedClosingTransactionNoneZ {
		contents: CResult_TrustedClosingTransactionNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TrustedClosingTransactionNoneZ in the error state.
pub extern "C" fn CResult_TrustedClosingTransactionNoneZ_err() -> CResult_TrustedClosingTransactionNoneZ {
	CResult_TrustedClosingTransactionNoneZ {
		contents: CResult_TrustedClosingTransactionNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TrustedClosingTransactionNoneZ_is_ok(o: &CResult_TrustedClosingTransactionNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TrustedClosingTransactionNoneZ.
pub extern "C" fn CResult_TrustedClosingTransactionNoneZ_free(_res: CResult_TrustedClosingTransactionNoneZ) { }
impl Drop for CResult_TrustedClosingTransactionNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TrustedClosingTransaction, ()>> for CResult_TrustedClosingTransactionNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TrustedClosingTransaction, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TrustedClosingTransactionNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_TrustedClosingTransactionNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_CommitmentTransactionDecodeErrorZ
pub union CResult_CommitmentTransactionDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::CommitmentTransaction,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::CommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CommitmentTransactionDecodeErrorZ {
	/// The contents of this CResult_CommitmentTransactionDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CommitmentTransactionDecodeErrorZPtr,
	/// Whether this CResult_CommitmentTransactionDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CommitmentTransactionDecodeErrorZ in the success state.
pub extern "C" fn CResult_CommitmentTransactionDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::CommitmentTransaction) -> CResult_CommitmentTransactionDecodeErrorZ {
	CResult_CommitmentTransactionDecodeErrorZ {
		contents: CResult_CommitmentTransactionDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CommitmentTransactionDecodeErrorZ in the error state.
pub extern "C" fn CResult_CommitmentTransactionDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CommitmentTransactionDecodeErrorZ {
	CResult_CommitmentTransactionDecodeErrorZ {
		contents: CResult_CommitmentTransactionDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CommitmentTransactionDecodeErrorZ_is_ok(o: &CResult_CommitmentTransactionDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CommitmentTransactionDecodeErrorZ.
pub extern "C" fn CResult_CommitmentTransactionDecodeErrorZ_free(_res: CResult_CommitmentTransactionDecodeErrorZ) { }
impl Drop for CResult_CommitmentTransactionDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CommitmentTransaction, crate::lightning::ln::msgs::DecodeError>> for CResult_CommitmentTransactionDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CommitmentTransaction, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CommitmentTransactionDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CommitmentTransactionDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CommitmentTransactionDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CommitmentTransactionDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::CommitmentTransaction>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CommitmentTransactionDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CommitmentTransactionDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CommitmentTransactionDecodeErrorZ_clone(orig: &CResult_CommitmentTransactionDecodeErrorZ) -> CResult_CommitmentTransactionDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TrustedCommitmentTransactionNoneZ
pub union CResult_TrustedCommitmentTransactionNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::TrustedCommitmentTransaction,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_TrustedCommitmentTransactionNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::TrustedCommitmentTransaction on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TrustedCommitmentTransactionNoneZ {
	/// The contents of this CResult_TrustedCommitmentTransactionNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TrustedCommitmentTransactionNoneZPtr,
	/// Whether this CResult_TrustedCommitmentTransactionNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TrustedCommitmentTransactionNoneZ in the success state.
pub extern "C" fn CResult_TrustedCommitmentTransactionNoneZ_ok(o: crate::lightning::ln::chan_utils::TrustedCommitmentTransaction) -> CResult_TrustedCommitmentTransactionNoneZ {
	CResult_TrustedCommitmentTransactionNoneZ {
		contents: CResult_TrustedCommitmentTransactionNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TrustedCommitmentTransactionNoneZ in the error state.
pub extern "C" fn CResult_TrustedCommitmentTransactionNoneZ_err() -> CResult_TrustedCommitmentTransactionNoneZ {
	CResult_TrustedCommitmentTransactionNoneZ {
		contents: CResult_TrustedCommitmentTransactionNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TrustedCommitmentTransactionNoneZ_is_ok(o: &CResult_TrustedCommitmentTransactionNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TrustedCommitmentTransactionNoneZ.
pub extern "C" fn CResult_TrustedCommitmentTransactionNoneZ_free(_res: CResult_TrustedCommitmentTransactionNoneZ) { }
impl Drop for CResult_TrustedCommitmentTransactionNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TrustedCommitmentTransaction, ()>> for CResult_TrustedCommitmentTransactionNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TrustedCommitmentTransaction, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TrustedCommitmentTransactionNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_TrustedCommitmentTransactionNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_CVec_ECDSASignatureZNoneZ
pub union CResult_CVec_ECDSASignatureZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_ECDSASignatureZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CVec_ECDSASignatureZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_ECDSASignatureZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_ECDSASignatureZNoneZ {
	/// The contents of this CResult_CVec_ECDSASignatureZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_ECDSASignatureZNoneZPtr,
	/// Whether this CResult_CVec_ECDSASignatureZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_ECDSASignatureZNoneZ in the success state.
pub extern "C" fn CResult_CVec_ECDSASignatureZNoneZ_ok(o: crate::c_types::derived::CVec_ECDSASignatureZ) -> CResult_CVec_ECDSASignatureZNoneZ {
	CResult_CVec_ECDSASignatureZNoneZ {
		contents: CResult_CVec_ECDSASignatureZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_ECDSASignatureZNoneZ in the error state.
pub extern "C" fn CResult_CVec_ECDSASignatureZNoneZ_err() -> CResult_CVec_ECDSASignatureZNoneZ {
	CResult_CVec_ECDSASignatureZNoneZ {
		contents: CResult_CVec_ECDSASignatureZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_ECDSASignatureZNoneZ_is_ok(o: &CResult_CVec_ECDSASignatureZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_ECDSASignatureZNoneZ.
pub extern "C" fn CResult_CVec_ECDSASignatureZNoneZ_free(_res: CResult_CVec_ECDSASignatureZNoneZ) { }
impl Drop for CResult_CVec_ECDSASignatureZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_ECDSASignatureZ, ()>> for CResult_CVec_ECDSASignatureZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_ECDSASignatureZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_ECDSASignatureZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CVec_ECDSASignatureZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_ECDSASignatureZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_ECDSASignatureZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_ECDSASignatureZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_ECDSASignatureZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_ECDSASignatureZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_ECDSASignatureZNoneZ_clone(orig: &CResult_CVec_ECDSASignatureZNoneZ) -> CResult_CVec_ECDSASignatureZNoneZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a usize or not
pub enum COption_usizeZ {
	/// When we're in this state, this COption_usizeZ contains a usize
	Some(usize),
	/// When we're in this state, this COption_usizeZ contains nothing
	None
}
impl COption_usizeZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> usize {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_usizeZ containing a usize
pub extern "C" fn COption_usizeZ_some(o: usize) -> COption_usizeZ {
	COption_usizeZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_usizeZ containing nothing
pub extern "C" fn COption_usizeZ_none() -> COption_usizeZ {
	COption_usizeZ::None
}
#[no_mangle]
/// Frees any resources associated with the usize, if we are in the Some state
pub extern "C" fn COption_usizeZ_free(_res: COption_usizeZ) { }
#[no_mangle]
/// Creates a new COption_usizeZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_usizeZ_clone(orig: &COption_usizeZ) -> COption_usizeZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ShutdownScriptDecodeErrorZ
pub union CResult_ShutdownScriptDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::script::ShutdownScript,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ShutdownScriptDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ShutdownScriptDecodeErrorZ {
	/// The contents of this CResult_ShutdownScriptDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ShutdownScriptDecodeErrorZPtr,
	/// Whether this CResult_ShutdownScriptDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptDecodeErrorZ in the success state.
pub extern "C" fn CResult_ShutdownScriptDecodeErrorZ_ok(o: crate::lightning::ln::script::ShutdownScript) -> CResult_ShutdownScriptDecodeErrorZ {
	CResult_ShutdownScriptDecodeErrorZ {
		contents: CResult_ShutdownScriptDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptDecodeErrorZ in the error state.
pub extern "C" fn CResult_ShutdownScriptDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ShutdownScriptDecodeErrorZ {
	CResult_ShutdownScriptDecodeErrorZ {
		contents: CResult_ShutdownScriptDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ShutdownScriptDecodeErrorZ_is_ok(o: &CResult_ShutdownScriptDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ShutdownScriptDecodeErrorZ.
pub extern "C" fn CResult_ShutdownScriptDecodeErrorZ_free(_res: CResult_ShutdownScriptDecodeErrorZ) { }
impl Drop for CResult_ShutdownScriptDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, crate::lightning::ln::msgs::DecodeError>> for CResult_ShutdownScriptDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ShutdownScriptDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ShutdownScriptDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ShutdownScriptDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ShutdownScriptDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::script::ShutdownScript>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ShutdownScriptDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ShutdownScriptDecodeErrorZ_clone(orig: &CResult_ShutdownScriptDecodeErrorZ) -> CResult_ShutdownScriptDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ShutdownScriptInvalidShutdownScriptZ
pub union CResult_ShutdownScriptInvalidShutdownScriptZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::script::ShutdownScript,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::script::InvalidShutdownScript,
}
#[repr(C)]
/// A CResult_ShutdownScriptInvalidShutdownScriptZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::script::InvalidShutdownScript on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ShutdownScriptInvalidShutdownScriptZ {
	/// The contents of this CResult_ShutdownScriptInvalidShutdownScriptZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ShutdownScriptInvalidShutdownScriptZPtr,
	/// Whether this CResult_ShutdownScriptInvalidShutdownScriptZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the success state.
pub extern "C" fn CResult_ShutdownScriptInvalidShutdownScriptZ_ok(o: crate::lightning::ln::script::ShutdownScript) -> CResult_ShutdownScriptInvalidShutdownScriptZ {
	CResult_ShutdownScriptInvalidShutdownScriptZ {
		contents: CResult_ShutdownScriptInvalidShutdownScriptZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the error state.
pub extern "C" fn CResult_ShutdownScriptInvalidShutdownScriptZ_err(e: crate::lightning::ln::script::InvalidShutdownScript) -> CResult_ShutdownScriptInvalidShutdownScriptZ {
	CResult_ShutdownScriptInvalidShutdownScriptZ {
		contents: CResult_ShutdownScriptInvalidShutdownScriptZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(o: &CResult_ShutdownScriptInvalidShutdownScriptZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ShutdownScriptInvalidShutdownScriptZ.
pub extern "C" fn CResult_ShutdownScriptInvalidShutdownScriptZ_free(_res: CResult_ShutdownScriptInvalidShutdownScriptZ) { }
impl Drop for CResult_ShutdownScriptInvalidShutdownScriptZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, crate::lightning::ln::script::InvalidShutdownScript>> for CResult_ShutdownScriptInvalidShutdownScriptZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, crate::lightning::ln::script::InvalidShutdownScript>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ShutdownScriptInvalidShutdownScriptZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ShutdownScriptInvalidShutdownScriptZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ShutdownScriptInvalidShutdownScriptZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ShutdownScriptInvalidShutdownScriptZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::script::ShutdownScript>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ShutdownScriptInvalidShutdownScriptZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::script::InvalidShutdownScript>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ShutdownScriptInvalidShutdownScriptZ_clone(orig: &CResult_ShutdownScriptInvalidShutdownScriptZ) -> CResult_ShutdownScriptInvalidShutdownScriptZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::Transactions of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_TransactionZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::Transaction,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_TransactionZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::Transaction> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::Transaction] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::Transaction>> for CVec_TransactionZ {
	fn from(v: Vec<crate::c_types::Transaction>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_TransactionZ_free(_res: CVec_TransactionZ) { }
impl Drop for CVec_TransactionZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_TransactionZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_FundingInfoDecodeErrorZ
pub union CResult_FundingInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::events::FundingInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_FundingInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::events::FundingInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_FundingInfoDecodeErrorZ {
	/// The contents of this CResult_FundingInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_FundingInfoDecodeErrorZPtr,
	/// Whether this CResult_FundingInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_FundingInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_FundingInfoDecodeErrorZ_ok(o: crate::lightning::events::FundingInfo) -> CResult_FundingInfoDecodeErrorZ {
	CResult_FundingInfoDecodeErrorZ {
		contents: CResult_FundingInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_FundingInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_FundingInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_FundingInfoDecodeErrorZ {
	CResult_FundingInfoDecodeErrorZ {
		contents: CResult_FundingInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_FundingInfoDecodeErrorZ_is_ok(o: &CResult_FundingInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_FundingInfoDecodeErrorZ.
pub extern "C" fn CResult_FundingInfoDecodeErrorZ_free(_res: CResult_FundingInfoDecodeErrorZ) { }
impl Drop for CResult_FundingInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::events::FundingInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_FundingInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::events::FundingInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_FundingInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_FundingInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_FundingInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_FundingInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::events::FundingInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_FundingInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_FundingInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_FundingInfoDecodeErrorZ_clone(orig: &CResult_FundingInfoDecodeErrorZ) -> CResult_FundingInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PaymentPurposeDecodeErrorZ
pub union CResult_PaymentPurposeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::events::PaymentPurpose,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PaymentPurposeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::events::PaymentPurpose on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PaymentPurposeDecodeErrorZ {
	/// The contents of this CResult_PaymentPurposeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PaymentPurposeDecodeErrorZPtr,
	/// Whether this CResult_PaymentPurposeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PaymentPurposeDecodeErrorZ in the success state.
pub extern "C" fn CResult_PaymentPurposeDecodeErrorZ_ok(o: crate::lightning::events::PaymentPurpose) -> CResult_PaymentPurposeDecodeErrorZ {
	CResult_PaymentPurposeDecodeErrorZ {
		contents: CResult_PaymentPurposeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentPurposeDecodeErrorZ in the error state.
pub extern "C" fn CResult_PaymentPurposeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PaymentPurposeDecodeErrorZ {
	CResult_PaymentPurposeDecodeErrorZ {
		contents: CResult_PaymentPurposeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PaymentPurposeDecodeErrorZ_is_ok(o: &CResult_PaymentPurposeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PaymentPurposeDecodeErrorZ.
pub extern "C" fn CResult_PaymentPurposeDecodeErrorZ_free(_res: CResult_PaymentPurposeDecodeErrorZ) { }
impl Drop for CResult_PaymentPurposeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::events::PaymentPurpose, crate::lightning::ln::msgs::DecodeError>> for CResult_PaymentPurposeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::events::PaymentPurpose, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PaymentPurposeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PaymentPurposeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PaymentPurposeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PaymentPurposeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::events::PaymentPurpose>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PaymentPurposeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentPurposeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PaymentPurposeDecodeErrorZ_clone(orig: &CResult_PaymentPurposeDecodeErrorZ) -> CResult_PaymentPurposeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ClaimedHTLCDecodeErrorZ
pub union CResult_ClaimedHTLCDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::events::ClaimedHTLC,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ClaimedHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::events::ClaimedHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ClaimedHTLCDecodeErrorZ {
	/// The contents of this CResult_ClaimedHTLCDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ClaimedHTLCDecodeErrorZPtr,
	/// Whether this CResult_ClaimedHTLCDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ClaimedHTLCDecodeErrorZ in the success state.
pub extern "C" fn CResult_ClaimedHTLCDecodeErrorZ_ok(o: crate::lightning::events::ClaimedHTLC) -> CResult_ClaimedHTLCDecodeErrorZ {
	CResult_ClaimedHTLCDecodeErrorZ {
		contents: CResult_ClaimedHTLCDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ClaimedHTLCDecodeErrorZ in the error state.
pub extern "C" fn CResult_ClaimedHTLCDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ClaimedHTLCDecodeErrorZ {
	CResult_ClaimedHTLCDecodeErrorZ {
		contents: CResult_ClaimedHTLCDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ClaimedHTLCDecodeErrorZ_is_ok(o: &CResult_ClaimedHTLCDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ClaimedHTLCDecodeErrorZ.
pub extern "C" fn CResult_ClaimedHTLCDecodeErrorZ_free(_res: CResult_ClaimedHTLCDecodeErrorZ) { }
impl Drop for CResult_ClaimedHTLCDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::events::ClaimedHTLC, crate::lightning::ln::msgs::DecodeError>> for CResult_ClaimedHTLCDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::events::ClaimedHTLC, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ClaimedHTLCDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ClaimedHTLCDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ClaimedHTLCDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ClaimedHTLCDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::events::ClaimedHTLC>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ClaimedHTLCDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ClaimedHTLCDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ClaimedHTLCDecodeErrorZ_clone(orig: &CResult_ClaimedHTLCDecodeErrorZ) -> CResult_ClaimedHTLCDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::events::PathFailure or not
pub enum COption_PathFailureZ {
	/// When we're in this state, this COption_PathFailureZ contains a crate::lightning::events::PathFailure
	Some(crate::lightning::events::PathFailure),
	/// When we're in this state, this COption_PathFailureZ contains nothing
	None
}
impl COption_PathFailureZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::events::PathFailure {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_PathFailureZ containing a crate::lightning::events::PathFailure
pub extern "C" fn COption_PathFailureZ_some(o: crate::lightning::events::PathFailure) -> COption_PathFailureZ {
	COption_PathFailureZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_PathFailureZ containing nothing
pub extern "C" fn COption_PathFailureZ_none() -> COption_PathFailureZ {
	COption_PathFailureZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::events::PathFailure, if we are in the Some state
pub extern "C" fn COption_PathFailureZ_free(_res: COption_PathFailureZ) { }
#[no_mangle]
/// Creates a new COption_PathFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_PathFailureZ_clone(orig: &COption_PathFailureZ) -> COption_PathFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_PathFailureZDecodeErrorZ
pub union CResult_COption_PathFailureZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_PathFailureZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_PathFailureZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_PathFailureZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_PathFailureZDecodeErrorZ {
	/// The contents of this CResult_COption_PathFailureZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_PathFailureZDecodeErrorZPtr,
	/// Whether this CResult_COption_PathFailureZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_PathFailureZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_PathFailureZDecodeErrorZ_ok(o: crate::c_types::derived::COption_PathFailureZ) -> CResult_COption_PathFailureZDecodeErrorZ {
	CResult_COption_PathFailureZDecodeErrorZ {
		contents: CResult_COption_PathFailureZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_PathFailureZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_PathFailureZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_PathFailureZDecodeErrorZ {
	CResult_COption_PathFailureZDecodeErrorZ {
		contents: CResult_COption_PathFailureZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_PathFailureZDecodeErrorZ_is_ok(o: &CResult_COption_PathFailureZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_PathFailureZDecodeErrorZ.
pub extern "C" fn CResult_COption_PathFailureZDecodeErrorZ_free(_res: CResult_COption_PathFailureZDecodeErrorZ) { }
impl Drop for CResult_COption_PathFailureZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_PathFailureZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_PathFailureZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_PathFailureZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_PathFailureZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_PathFailureZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_PathFailureZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_PathFailureZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_PathFailureZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_PathFailureZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_PathFailureZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_PathFailureZDecodeErrorZ_clone(orig: &CResult_COption_PathFailureZDecodeErrorZ) -> CResult_COption_PathFailureZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::events::ClosureReason or not
pub enum COption_ClosureReasonZ {
	/// When we're in this state, this COption_ClosureReasonZ contains a crate::lightning::events::ClosureReason
	Some(crate::lightning::events::ClosureReason),
	/// When we're in this state, this COption_ClosureReasonZ contains nothing
	None
}
impl COption_ClosureReasonZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::events::ClosureReason {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_ClosureReasonZ containing a crate::lightning::events::ClosureReason
pub extern "C" fn COption_ClosureReasonZ_some(o: crate::lightning::events::ClosureReason) -> COption_ClosureReasonZ {
	COption_ClosureReasonZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_ClosureReasonZ containing nothing
pub extern "C" fn COption_ClosureReasonZ_none() -> COption_ClosureReasonZ {
	COption_ClosureReasonZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::events::ClosureReason, if we are in the Some state
pub extern "C" fn COption_ClosureReasonZ_free(_res: COption_ClosureReasonZ) { }
#[no_mangle]
/// Creates a new COption_ClosureReasonZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_ClosureReasonZ_clone(orig: &COption_ClosureReasonZ) -> COption_ClosureReasonZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_ClosureReasonZDecodeErrorZ
pub union CResult_COption_ClosureReasonZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_ClosureReasonZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_ClosureReasonZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_ClosureReasonZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_ClosureReasonZDecodeErrorZ {
	/// The contents of this CResult_COption_ClosureReasonZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_ClosureReasonZDecodeErrorZPtr,
	/// Whether this CResult_COption_ClosureReasonZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_ClosureReasonZDecodeErrorZ_ok(o: crate::c_types::derived::COption_ClosureReasonZ) -> CResult_COption_ClosureReasonZDecodeErrorZ {
	CResult_COption_ClosureReasonZDecodeErrorZ {
		contents: CResult_COption_ClosureReasonZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_ClosureReasonZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_ClosureReasonZDecodeErrorZ {
	CResult_COption_ClosureReasonZDecodeErrorZ {
		contents: CResult_COption_ClosureReasonZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(o: &CResult_COption_ClosureReasonZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_ClosureReasonZDecodeErrorZ.
pub extern "C" fn CResult_COption_ClosureReasonZDecodeErrorZ_free(_res: CResult_COption_ClosureReasonZDecodeErrorZ) { }
impl Drop for CResult_COption_ClosureReasonZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_ClosureReasonZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_ClosureReasonZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_ClosureReasonZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_ClosureReasonZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_ClosureReasonZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_ClosureReasonZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_ClosureReasonZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_ClosureReasonZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_ClosureReasonZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_ClosureReasonZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_ClosureReasonZDecodeErrorZ_clone(orig: &CResult_COption_ClosureReasonZDecodeErrorZ) -> CResult_COption_ClosureReasonZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::events::HTLCDestination or not
pub enum COption_HTLCDestinationZ {
	/// When we're in this state, this COption_HTLCDestinationZ contains a crate::lightning::events::HTLCDestination
	Some(crate::lightning::events::HTLCDestination),
	/// When we're in this state, this COption_HTLCDestinationZ contains nothing
	None
}
impl COption_HTLCDestinationZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::events::HTLCDestination {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_HTLCDestinationZ containing a crate::lightning::events::HTLCDestination
pub extern "C" fn COption_HTLCDestinationZ_some(o: crate::lightning::events::HTLCDestination) -> COption_HTLCDestinationZ {
	COption_HTLCDestinationZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_HTLCDestinationZ containing nothing
pub extern "C" fn COption_HTLCDestinationZ_none() -> COption_HTLCDestinationZ {
	COption_HTLCDestinationZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::events::HTLCDestination, if we are in the Some state
pub extern "C" fn COption_HTLCDestinationZ_free(_res: COption_HTLCDestinationZ) { }
#[no_mangle]
/// Creates a new COption_HTLCDestinationZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_HTLCDestinationZ_clone(orig: &COption_HTLCDestinationZ) -> COption_HTLCDestinationZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_HTLCDestinationZDecodeErrorZ
pub union CResult_COption_HTLCDestinationZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_HTLCDestinationZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_HTLCDestinationZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_HTLCDestinationZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_HTLCDestinationZDecodeErrorZ {
	/// The contents of this CResult_COption_HTLCDestinationZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_HTLCDestinationZDecodeErrorZPtr,
	/// Whether this CResult_COption_HTLCDestinationZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_HTLCDestinationZDecodeErrorZ_ok(o: crate::c_types::derived::COption_HTLCDestinationZ) -> CResult_COption_HTLCDestinationZDecodeErrorZ {
	CResult_COption_HTLCDestinationZDecodeErrorZ {
		contents: CResult_COption_HTLCDestinationZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_HTLCDestinationZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_HTLCDestinationZDecodeErrorZ {
	CResult_COption_HTLCDestinationZDecodeErrorZ {
		contents: CResult_COption_HTLCDestinationZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok(o: &CResult_COption_HTLCDestinationZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_HTLCDestinationZDecodeErrorZ.
pub extern "C" fn CResult_COption_HTLCDestinationZDecodeErrorZ_free(_res: CResult_COption_HTLCDestinationZDecodeErrorZ) { }
impl Drop for CResult_COption_HTLCDestinationZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_HTLCDestinationZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_HTLCDestinationZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_HTLCDestinationZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_HTLCDestinationZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_HTLCDestinationZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_HTLCDestinationZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_HTLCDestinationZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_HTLCDestinationZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_HTLCDestinationZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_HTLCDestinationZDecodeErrorZ_clone(orig: &CResult_COption_HTLCDestinationZDecodeErrorZ) -> CResult_COption_HTLCDestinationZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::events::PaymentFailureReason or not
pub enum COption_PaymentFailureReasonZ {
	/// When we're in this state, this COption_PaymentFailureReasonZ contains a crate::lightning::events::PaymentFailureReason
	Some(crate::lightning::events::PaymentFailureReason),
	/// When we're in this state, this COption_PaymentFailureReasonZ contains nothing
	None
}
impl COption_PaymentFailureReasonZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::events::PaymentFailureReason {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_PaymentFailureReasonZ containing a crate::lightning::events::PaymentFailureReason
pub extern "C" fn COption_PaymentFailureReasonZ_some(o: crate::lightning::events::PaymentFailureReason) -> COption_PaymentFailureReasonZ {
	COption_PaymentFailureReasonZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_PaymentFailureReasonZ containing nothing
pub extern "C" fn COption_PaymentFailureReasonZ_none() -> COption_PaymentFailureReasonZ {
	COption_PaymentFailureReasonZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::events::PaymentFailureReason, if we are in the Some state
pub extern "C" fn COption_PaymentFailureReasonZ_free(_res: COption_PaymentFailureReasonZ) { }
#[no_mangle]
/// Creates a new COption_PaymentFailureReasonZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_PaymentFailureReasonZ_clone(orig: &COption_PaymentFailureReasonZ) -> COption_PaymentFailureReasonZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_PaymentFailureReasonZDecodeErrorZ
pub union CResult_COption_PaymentFailureReasonZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_PaymentFailureReasonZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_PaymentFailureReasonZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_PaymentFailureReasonZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_PaymentFailureReasonZDecodeErrorZ {
	/// The contents of this CResult_COption_PaymentFailureReasonZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_PaymentFailureReasonZDecodeErrorZPtr,
	/// Whether this CResult_COption_PaymentFailureReasonZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_PaymentFailureReasonZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_PaymentFailureReasonZDecodeErrorZ_ok(o: crate::c_types::derived::COption_PaymentFailureReasonZ) -> CResult_COption_PaymentFailureReasonZDecodeErrorZ {
	CResult_COption_PaymentFailureReasonZDecodeErrorZ {
		contents: CResult_COption_PaymentFailureReasonZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_PaymentFailureReasonZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_PaymentFailureReasonZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_PaymentFailureReasonZDecodeErrorZ {
	CResult_COption_PaymentFailureReasonZDecodeErrorZ {
		contents: CResult_COption_PaymentFailureReasonZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_PaymentFailureReasonZDecodeErrorZ_is_ok(o: &CResult_COption_PaymentFailureReasonZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_PaymentFailureReasonZDecodeErrorZ.
pub extern "C" fn CResult_COption_PaymentFailureReasonZDecodeErrorZ_free(_res: CResult_COption_PaymentFailureReasonZDecodeErrorZ) { }
impl Drop for CResult_COption_PaymentFailureReasonZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_PaymentFailureReasonZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_PaymentFailureReasonZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_PaymentFailureReasonZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_PaymentFailureReasonZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_PaymentFailureReasonZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_PaymentFailureReasonZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_PaymentFailureReasonZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_PaymentFailureReasonZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_PaymentFailureReasonZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_PaymentFailureReasonZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_PaymentFailureReasonZDecodeErrorZ_clone(orig: &CResult_COption_PaymentFailureReasonZDecodeErrorZ) -> CResult_COption_PaymentFailureReasonZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::U128 or not
pub enum COption_U128Z {
	/// When we're in this state, this COption_U128Z contains a crate::c_types::U128
	Some(crate::c_types::U128),
	/// When we're in this state, this COption_U128Z contains nothing
	None
}
impl COption_U128Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::U128 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_U128Z containing a crate::c_types::U128
pub extern "C" fn COption_U128Z_some(o: crate::c_types::U128) -> COption_U128Z {
	COption_U128Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_U128Z containing nothing
pub extern "C" fn COption_U128Z_none() -> COption_U128Z {
	COption_U128Z::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::U128, if we are in the Some state
pub extern "C" fn COption_U128Z_free(_res: COption_U128Z) { }
#[no_mangle]
/// Creates a new COption_U128Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_U128Z_clone(orig: &COption_U128Z) -> COption_U128Z { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::events::ClaimedHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ClaimedHTLCZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::events::ClaimedHTLC,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ClaimedHTLCZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::events::ClaimedHTLC> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::events::ClaimedHTLC] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::events::ClaimedHTLC>> for CVec_ClaimedHTLCZ {
	fn from(v: Vec<crate::lightning::events::ClaimedHTLC>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ClaimedHTLCZ_free(_res: CVec_ClaimedHTLCZ) { }
impl Drop for CVec_ClaimedHTLCZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ClaimedHTLCZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::events::Event or not
pub enum COption_EventZ {
	/// When we're in this state, this COption_EventZ contains a crate::lightning::events::Event
	Some(crate::lightning::events::Event),
	/// When we're in this state, this COption_EventZ contains nothing
	None
}
impl COption_EventZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::events::Event {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_EventZ containing a crate::lightning::events::Event
pub extern "C" fn COption_EventZ_some(o: crate::lightning::events::Event) -> COption_EventZ {
	COption_EventZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_EventZ containing nothing
pub extern "C" fn COption_EventZ_none() -> COption_EventZ {
	COption_EventZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::events::Event, if we are in the Some state
pub extern "C" fn COption_EventZ_free(_res: COption_EventZ) { }
#[no_mangle]
/// Creates a new COption_EventZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_EventZ_clone(orig: &COption_EventZ) -> COption_EventZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_EventZDecodeErrorZ
pub union CResult_COption_EventZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_EventZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_EventZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_EventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_EventZDecodeErrorZ {
	/// The contents of this CResult_COption_EventZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_EventZDecodeErrorZPtr,
	/// Whether this CResult_COption_EventZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_EventZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_EventZDecodeErrorZ_ok(o: crate::c_types::derived::COption_EventZ) -> CResult_COption_EventZDecodeErrorZ {
	CResult_COption_EventZDecodeErrorZ {
		contents: CResult_COption_EventZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_EventZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_EventZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_EventZDecodeErrorZ {
	CResult_COption_EventZDecodeErrorZ {
		contents: CResult_COption_EventZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_EventZDecodeErrorZ_is_ok(o: &CResult_COption_EventZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_EventZDecodeErrorZ.
pub extern "C" fn CResult_COption_EventZDecodeErrorZ_free(_res: CResult_COption_EventZDecodeErrorZ) { }
impl Drop for CResult_COption_EventZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_EventZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_EventZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_EventZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_EventZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_EventZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_EventZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_EventZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_EventZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_EventZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_EventZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_EventZDecodeErrorZ_clone(orig: &CResult_COption_EventZDecodeErrorZ) -> CResult_COption_EventZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NonceDecodeErrorZ
pub union CResult_NonceDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::nonce::Nonce,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NonceDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::nonce::Nonce on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NonceDecodeErrorZ {
	/// The contents of this CResult_NonceDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NonceDecodeErrorZPtr,
	/// Whether this CResult_NonceDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NonceDecodeErrorZ in the success state.
pub extern "C" fn CResult_NonceDecodeErrorZ_ok(o: crate::lightning::offers::nonce::Nonce) -> CResult_NonceDecodeErrorZ {
	CResult_NonceDecodeErrorZ {
		contents: CResult_NonceDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NonceDecodeErrorZ in the error state.
pub extern "C" fn CResult_NonceDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NonceDecodeErrorZ {
	CResult_NonceDecodeErrorZ {
		contents: CResult_NonceDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NonceDecodeErrorZ_is_ok(o: &CResult_NonceDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NonceDecodeErrorZ.
pub extern "C" fn CResult_NonceDecodeErrorZ_free(_res: CResult_NonceDecodeErrorZ) { }
impl Drop for CResult_NonceDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::nonce::Nonce, crate::lightning::ln::msgs::DecodeError>> for CResult_NonceDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::nonce::Nonce, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NonceDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NonceDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NonceDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NonceDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::nonce::Nonce>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NonceDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NonceDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NonceDecodeErrorZ_clone(orig: &CResult_NonceDecodeErrorZ) -> CResult_NonceDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning_types::routing::RouteHintHops of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_RouteHintHopZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning_types::routing::RouteHintHop,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_RouteHintHopZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning_types::routing::RouteHintHop> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning_types::routing::RouteHintHop] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning_types::routing::RouteHintHop>> for CVec_RouteHintHopZ {
	fn from(v: Vec<crate::lightning_types::routing::RouteHintHop>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_RouteHintHopZ_free(_res: CVec_RouteHintHopZ) { }
impl Drop for CVec_RouteHintHopZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_RouteHintHopZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_SiPrefixBolt11ParseErrorZ
pub union CResult_SiPrefixBolt11ParseErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::SiPrefix,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::Bolt11ParseError,
}
#[repr(C)]
/// A CResult_SiPrefixBolt11ParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::SiPrefix on success and a crate::lightning_invoice::Bolt11ParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SiPrefixBolt11ParseErrorZ {
	/// The contents of this CResult_SiPrefixBolt11ParseErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SiPrefixBolt11ParseErrorZPtr,
	/// Whether this CResult_SiPrefixBolt11ParseErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SiPrefixBolt11ParseErrorZ in the success state.
pub extern "C" fn CResult_SiPrefixBolt11ParseErrorZ_ok(o: crate::lightning_invoice::SiPrefix) -> CResult_SiPrefixBolt11ParseErrorZ {
	CResult_SiPrefixBolt11ParseErrorZ {
		contents: CResult_SiPrefixBolt11ParseErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SiPrefixBolt11ParseErrorZ in the error state.
pub extern "C" fn CResult_SiPrefixBolt11ParseErrorZ_err(e: crate::lightning_invoice::Bolt11ParseError) -> CResult_SiPrefixBolt11ParseErrorZ {
	CResult_SiPrefixBolt11ParseErrorZ {
		contents: CResult_SiPrefixBolt11ParseErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SiPrefixBolt11ParseErrorZ_is_ok(o: &CResult_SiPrefixBolt11ParseErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SiPrefixBolt11ParseErrorZ.
pub extern "C" fn CResult_SiPrefixBolt11ParseErrorZ_free(_res: CResult_SiPrefixBolt11ParseErrorZ) { }
impl Drop for CResult_SiPrefixBolt11ParseErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::SiPrefix, crate::lightning_invoice::Bolt11ParseError>> for CResult_SiPrefixBolt11ParseErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::SiPrefix, crate::lightning_invoice::Bolt11ParseError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SiPrefixBolt11ParseErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SiPrefixBolt11ParseErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SiPrefixBolt11ParseErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SiPrefixBolt11ParseErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::SiPrefix>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SiPrefixBolt11ParseErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11ParseError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SiPrefixBolt11ParseErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SiPrefixBolt11ParseErrorZ_clone(orig: &CResult_SiPrefixBolt11ParseErrorZ) -> CResult_SiPrefixBolt11ParseErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt11InvoiceParseOrSemanticErrorZ
pub union CResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::Bolt11Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::ParseOrSemanticError,
}
#[repr(C)]
/// A CResult_Bolt11InvoiceParseOrSemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Bolt11Invoice on success and a crate::lightning_invoice::ParseOrSemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	/// The contents of this CResult_Bolt11InvoiceParseOrSemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt11InvoiceParseOrSemanticErrorZPtr,
	/// Whether this CResult_Bolt11InvoiceParseOrSemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceParseOrSemanticErrorZ in the success state.
pub extern "C" fn CResult_Bolt11InvoiceParseOrSemanticErrorZ_ok(o: crate::lightning_invoice::Bolt11Invoice) -> CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	CResult_Bolt11InvoiceParseOrSemanticErrorZ {
		contents: CResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceParseOrSemanticErrorZ in the error state.
pub extern "C" fn CResult_Bolt11InvoiceParseOrSemanticErrorZ_err(e: crate::lightning_invoice::ParseOrSemanticError) -> CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	CResult_Bolt11InvoiceParseOrSemanticErrorZ {
		contents: CResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt11InvoiceParseOrSemanticErrorZ_is_ok(o: &CResult_Bolt11InvoiceParseOrSemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt11InvoiceParseOrSemanticErrorZ.
pub extern "C" fn CResult_Bolt11InvoiceParseOrSemanticErrorZ_free(_res: CResult_Bolt11InvoiceParseOrSemanticErrorZ) { }
impl Drop for CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::ParseOrSemanticError>> for CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::ParseOrSemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt11InvoiceParseOrSemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt11InvoiceParseOrSemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::ParseOrSemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceParseOrSemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt11InvoiceParseOrSemanticErrorZ_clone(orig: &CResult_Bolt11InvoiceParseOrSemanticErrorZ) -> CResult_Bolt11InvoiceParseOrSemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ
pub union CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::SignedRawBolt11Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::Bolt11ParseError,
}
#[repr(C)]
/// A CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::SignedRawBolt11Invoice on success and a crate::lightning_invoice::Bolt11ParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	/// The contents of this CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr,
	/// Whether this CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ in the success state.
pub extern "C" fn CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_ok(o: crate::lightning_invoice::SignedRawBolt11Invoice) -> CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
		contents: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ in the error state.
pub extern "C" fn CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_err(e: crate::lightning_invoice::Bolt11ParseError) -> CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
		contents: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_is_ok(o: &CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ.
pub extern "C" fn CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_free(_res: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ) { }
impl Drop for CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::SignedRawBolt11Invoice, crate::lightning_invoice::Bolt11ParseError>> for CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::SignedRawBolt11Invoice, crate::lightning_invoice::Bolt11ParseError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::SignedRawBolt11Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11ParseError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_clone(orig: &CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ) -> CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
	/// The element at position 0
	pub a: crate::lightning_invoice::RawBolt11Invoice,
	/// The element at position 1
	pub b: crate::c_types::ThirtyTwoBytes,
	/// The element at position 2
	pub c: crate::lightning_invoice::Bolt11InvoiceSignature,
}
impl From<(crate::lightning_invoice::RawBolt11Invoice, crate::c_types::ThirtyTwoBytes, crate::lightning_invoice::Bolt11InvoiceSignature)> for C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
	fn from (tup: (crate::lightning_invoice::RawBolt11Invoice, crate::c_types::ThirtyTwoBytes, crate::lightning_invoice::Bolt11InvoiceSignature)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning_invoice::RawBolt11Invoice, crate::c_types::ThirtyTwoBytes, crate::lightning_invoice::Bolt11InvoiceSignature) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_clone(orig: &C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ) -> C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_new(a: crate::lightning_invoice::RawBolt11Invoice, b: crate::c_types::ThirtyTwoBytes, c: crate::lightning_invoice::Bolt11InvoiceSignature) -> C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
	C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ.
pub extern "C" fn C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_free(_res: C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ) { }
#[repr(C)]
/// The contents of CResult_PayeePubKeySecp256k1ErrorZ
pub union CResult_PayeePubKeySecp256k1ErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::PayeePubKey,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::Secp256k1Error,
}
#[repr(C)]
/// A CResult_PayeePubKeySecp256k1ErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::PayeePubKey on success and a crate::c_types::Secp256k1Error on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PayeePubKeySecp256k1ErrorZ {
	/// The contents of this CResult_PayeePubKeySecp256k1ErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PayeePubKeySecp256k1ErrorZPtr,
	/// Whether this CResult_PayeePubKeySecp256k1ErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PayeePubKeySecp256k1ErrorZ in the success state.
pub extern "C" fn CResult_PayeePubKeySecp256k1ErrorZ_ok(o: crate::lightning_invoice::PayeePubKey) -> CResult_PayeePubKeySecp256k1ErrorZ {
	CResult_PayeePubKeySecp256k1ErrorZ {
		contents: CResult_PayeePubKeySecp256k1ErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PayeePubKeySecp256k1ErrorZ in the error state.
pub extern "C" fn CResult_PayeePubKeySecp256k1ErrorZ_err(e: crate::c_types::Secp256k1Error) -> CResult_PayeePubKeySecp256k1ErrorZ {
	CResult_PayeePubKeySecp256k1ErrorZ {
		contents: CResult_PayeePubKeySecp256k1ErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PayeePubKeySecp256k1ErrorZ_is_ok(o: &CResult_PayeePubKeySecp256k1ErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PayeePubKeySecp256k1ErrorZ.
pub extern "C" fn CResult_PayeePubKeySecp256k1ErrorZ_free(_res: CResult_PayeePubKeySecp256k1ErrorZ) { }
impl Drop for CResult_PayeePubKeySecp256k1ErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::PayeePubKey, crate::c_types::Secp256k1Error>> for CResult_PayeePubKeySecp256k1ErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::PayeePubKey, crate::c_types::Secp256k1Error>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PayeePubKeySecp256k1ErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PayeePubKeySecp256k1ErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PayeePubKeySecp256k1ErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PayeePubKeySecp256k1ErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::PayeePubKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PayeePubKeySecp256k1ErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::Secp256k1Error>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PayeePubKeySecp256k1ErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PayeePubKeySecp256k1ErrorZ_clone(orig: &CResult_PayeePubKeySecp256k1ErrorZ) -> CResult_PayeePubKeySecp256k1ErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning_invoice::PrivateRoutes of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_PrivateRouteZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning_invoice::PrivateRoute,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_PrivateRouteZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning_invoice::PrivateRoute> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning_invoice::PrivateRoute] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning_invoice::PrivateRoute>> for CVec_PrivateRouteZ {
	fn from(v: Vec<crate::lightning_invoice::PrivateRoute>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_PrivateRouteZ_free(_res: CVec_PrivateRouteZ) { }
impl Drop for CVec_PrivateRouteZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_PrivateRouteZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_PositiveTimestampCreationErrorZ
pub union CResult_PositiveTimestampCreationErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::PositiveTimestamp,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::CreationError,
}
#[repr(C)]
/// A CResult_PositiveTimestampCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::PositiveTimestamp on success and a crate::lightning_invoice::CreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PositiveTimestampCreationErrorZ {
	/// The contents of this CResult_PositiveTimestampCreationErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PositiveTimestampCreationErrorZPtr,
	/// Whether this CResult_PositiveTimestampCreationErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PositiveTimestampCreationErrorZ in the success state.
pub extern "C" fn CResult_PositiveTimestampCreationErrorZ_ok(o: crate::lightning_invoice::PositiveTimestamp) -> CResult_PositiveTimestampCreationErrorZ {
	CResult_PositiveTimestampCreationErrorZ {
		contents: CResult_PositiveTimestampCreationErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PositiveTimestampCreationErrorZ in the error state.
pub extern "C" fn CResult_PositiveTimestampCreationErrorZ_err(e: crate::lightning_invoice::CreationError) -> CResult_PositiveTimestampCreationErrorZ {
	CResult_PositiveTimestampCreationErrorZ {
		contents: CResult_PositiveTimestampCreationErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PositiveTimestampCreationErrorZ_is_ok(o: &CResult_PositiveTimestampCreationErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PositiveTimestampCreationErrorZ.
pub extern "C" fn CResult_PositiveTimestampCreationErrorZ_free(_res: CResult_PositiveTimestampCreationErrorZ) { }
impl Drop for CResult_PositiveTimestampCreationErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::PositiveTimestamp, crate::lightning_invoice::CreationError>> for CResult_PositiveTimestampCreationErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::PositiveTimestamp, crate::lightning_invoice::CreationError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PositiveTimestampCreationErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PositiveTimestampCreationErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PositiveTimestampCreationErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PositiveTimestampCreationErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::PositiveTimestamp>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PositiveTimestampCreationErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::CreationError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PositiveTimestampCreationErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PositiveTimestampCreationErrorZ_clone(orig: &CResult_PositiveTimestampCreationErrorZ) -> CResult_PositiveTimestampCreationErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneBolt11SemanticErrorZ
pub union CResult_NoneBolt11SemanticErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::Bolt11SemanticError,
}
#[repr(C)]
/// A CResult_NoneBolt11SemanticErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning_invoice::Bolt11SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneBolt11SemanticErrorZ {
	/// The contents of this CResult_NoneBolt11SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneBolt11SemanticErrorZPtr,
	/// Whether this CResult_NoneBolt11SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneBolt11SemanticErrorZ in the success state.
pub extern "C" fn CResult_NoneBolt11SemanticErrorZ_ok() -> CResult_NoneBolt11SemanticErrorZ {
	CResult_NoneBolt11SemanticErrorZ {
		contents: CResult_NoneBolt11SemanticErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneBolt11SemanticErrorZ in the error state.
pub extern "C" fn CResult_NoneBolt11SemanticErrorZ_err(e: crate::lightning_invoice::Bolt11SemanticError) -> CResult_NoneBolt11SemanticErrorZ {
	CResult_NoneBolt11SemanticErrorZ {
		contents: CResult_NoneBolt11SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneBolt11SemanticErrorZ_is_ok(o: &CResult_NoneBolt11SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneBolt11SemanticErrorZ.
pub extern "C" fn CResult_NoneBolt11SemanticErrorZ_free(_res: CResult_NoneBolt11SemanticErrorZ) { }
impl Drop for CResult_NoneBolt11SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning_invoice::Bolt11SemanticError>> for CResult_NoneBolt11SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning_invoice::Bolt11SemanticError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneBolt11SemanticErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneBolt11SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneBolt11SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneBolt11SemanticErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneBolt11SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneBolt11SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneBolt11SemanticErrorZ_clone(orig: &CResult_NoneBolt11SemanticErrorZ) -> CResult_NoneBolt11SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt11InvoiceBolt11SemanticErrorZ
pub union CResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::Bolt11Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::Bolt11SemanticError,
}
#[repr(C)]
/// A CResult_Bolt11InvoiceBolt11SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Bolt11Invoice on success and a crate::lightning_invoice::Bolt11SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	/// The contents of this CResult_Bolt11InvoiceBolt11SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt11InvoiceBolt11SemanticErrorZPtr,
	/// Whether this CResult_Bolt11InvoiceBolt11SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceBolt11SemanticErrorZ in the success state.
pub extern "C" fn CResult_Bolt11InvoiceBolt11SemanticErrorZ_ok(o: crate::lightning_invoice::Bolt11Invoice) -> CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	CResult_Bolt11InvoiceBolt11SemanticErrorZ {
		contents: CResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceBolt11SemanticErrorZ in the error state.
pub extern "C" fn CResult_Bolt11InvoiceBolt11SemanticErrorZ_err(e: crate::lightning_invoice::Bolt11SemanticError) -> CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	CResult_Bolt11InvoiceBolt11SemanticErrorZ {
		contents: CResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt11InvoiceBolt11SemanticErrorZ_is_ok(o: &CResult_Bolt11InvoiceBolt11SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt11InvoiceBolt11SemanticErrorZ.
pub extern "C" fn CResult_Bolt11InvoiceBolt11SemanticErrorZ_free(_res: CResult_Bolt11InvoiceBolt11SemanticErrorZ) { }
impl Drop for CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::Bolt11SemanticError>> for CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::Bolt11SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt11InvoiceBolt11SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt11InvoiceBolt11SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceBolt11SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt11InvoiceBolt11SemanticErrorZ_clone(orig: &CResult_Bolt11InvoiceBolt11SemanticErrorZ) -> CResult_Bolt11InvoiceBolt11SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_DescriptionCreationErrorZ
pub union CResult_DescriptionCreationErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::Description,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::CreationError,
}
#[repr(C)]
/// A CResult_DescriptionCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Description on success and a crate::lightning_invoice::CreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_DescriptionCreationErrorZ {
	/// The contents of this CResult_DescriptionCreationErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_DescriptionCreationErrorZPtr,
	/// Whether this CResult_DescriptionCreationErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_DescriptionCreationErrorZ in the success state.
pub extern "C" fn CResult_DescriptionCreationErrorZ_ok(o: crate::lightning_invoice::Description) -> CResult_DescriptionCreationErrorZ {
	CResult_DescriptionCreationErrorZ {
		contents: CResult_DescriptionCreationErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_DescriptionCreationErrorZ in the error state.
pub extern "C" fn CResult_DescriptionCreationErrorZ_err(e: crate::lightning_invoice::CreationError) -> CResult_DescriptionCreationErrorZ {
	CResult_DescriptionCreationErrorZ {
		contents: CResult_DescriptionCreationErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_DescriptionCreationErrorZ_is_ok(o: &CResult_DescriptionCreationErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_DescriptionCreationErrorZ.
pub extern "C" fn CResult_DescriptionCreationErrorZ_free(_res: CResult_DescriptionCreationErrorZ) { }
impl Drop for CResult_DescriptionCreationErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::Description, crate::lightning_invoice::CreationError>> for CResult_DescriptionCreationErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::Description, crate::lightning_invoice::CreationError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_DescriptionCreationErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_DescriptionCreationErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_DescriptionCreationErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_DescriptionCreationErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::Description>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_DescriptionCreationErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::CreationError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_DescriptionCreationErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_DescriptionCreationErrorZ_clone(orig: &CResult_DescriptionCreationErrorZ) -> CResult_DescriptionCreationErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PrivateRouteCreationErrorZ
pub union CResult_PrivateRouteCreationErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::PrivateRoute,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::CreationError,
}
#[repr(C)]
/// A CResult_PrivateRouteCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::PrivateRoute on success and a crate::lightning_invoice::CreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PrivateRouteCreationErrorZ {
	/// The contents of this CResult_PrivateRouteCreationErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PrivateRouteCreationErrorZPtr,
	/// Whether this CResult_PrivateRouteCreationErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PrivateRouteCreationErrorZ in the success state.
pub extern "C" fn CResult_PrivateRouteCreationErrorZ_ok(o: crate::lightning_invoice::PrivateRoute) -> CResult_PrivateRouteCreationErrorZ {
	CResult_PrivateRouteCreationErrorZ {
		contents: CResult_PrivateRouteCreationErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PrivateRouteCreationErrorZ in the error state.
pub extern "C" fn CResult_PrivateRouteCreationErrorZ_err(e: crate::lightning_invoice::CreationError) -> CResult_PrivateRouteCreationErrorZ {
	CResult_PrivateRouteCreationErrorZ {
		contents: CResult_PrivateRouteCreationErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PrivateRouteCreationErrorZ_is_ok(o: &CResult_PrivateRouteCreationErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PrivateRouteCreationErrorZ.
pub extern "C" fn CResult_PrivateRouteCreationErrorZ_free(_res: CResult_PrivateRouteCreationErrorZ) { }
impl Drop for CResult_PrivateRouteCreationErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::PrivateRoute, crate::lightning_invoice::CreationError>> for CResult_PrivateRouteCreationErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::PrivateRoute, crate::lightning_invoice::CreationError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PrivateRouteCreationErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PrivateRouteCreationErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PrivateRouteCreationErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PrivateRouteCreationErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::PrivateRoute>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PrivateRouteCreationErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::CreationError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PrivateRouteCreationErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PrivateRouteCreationErrorZ_clone(orig: &CResult_PrivateRouteCreationErrorZ) -> CResult_PrivateRouteCreationErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OutPointDecodeErrorZ
pub union CResult_OutPointDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::transaction::OutPoint,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OutPointDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::transaction::OutPoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OutPointDecodeErrorZ {
	/// The contents of this CResult_OutPointDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OutPointDecodeErrorZPtr,
	/// Whether this CResult_OutPointDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OutPointDecodeErrorZ in the success state.
pub extern "C" fn CResult_OutPointDecodeErrorZ_ok(o: crate::lightning::chain::transaction::OutPoint) -> CResult_OutPointDecodeErrorZ {
	CResult_OutPointDecodeErrorZ {
		contents: CResult_OutPointDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OutPointDecodeErrorZ in the error state.
pub extern "C" fn CResult_OutPointDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OutPointDecodeErrorZ {
	CResult_OutPointDecodeErrorZ {
		contents: CResult_OutPointDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OutPointDecodeErrorZ_is_ok(o: &CResult_OutPointDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OutPointDecodeErrorZ.
pub extern "C" fn CResult_OutPointDecodeErrorZ_free(_res: CResult_OutPointDecodeErrorZ) { }
impl Drop for CResult_OutPointDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::transaction::OutPoint, crate::lightning::ln::msgs::DecodeError>> for CResult_OutPointDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::transaction::OutPoint, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OutPointDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OutPointDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OutPointDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OutPointDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::chain::transaction::OutPoint>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OutPointDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OutPointDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OutPointDecodeErrorZ_clone(orig: &CResult_OutPointDecodeErrorZ) -> CResult_OutPointDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BigSizeDecodeErrorZ
pub union CResult_BigSizeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::ser::BigSize,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BigSizeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::ser::BigSize on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BigSizeDecodeErrorZ {
	/// The contents of this CResult_BigSizeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BigSizeDecodeErrorZPtr,
	/// Whether this CResult_BigSizeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BigSizeDecodeErrorZ in the success state.
pub extern "C" fn CResult_BigSizeDecodeErrorZ_ok(o: crate::lightning::util::ser::BigSize) -> CResult_BigSizeDecodeErrorZ {
	CResult_BigSizeDecodeErrorZ {
		contents: CResult_BigSizeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BigSizeDecodeErrorZ in the error state.
pub extern "C" fn CResult_BigSizeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BigSizeDecodeErrorZ {
	CResult_BigSizeDecodeErrorZ {
		contents: CResult_BigSizeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BigSizeDecodeErrorZ_is_ok(o: &CResult_BigSizeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BigSizeDecodeErrorZ.
pub extern "C" fn CResult_BigSizeDecodeErrorZ_free(_res: CResult_BigSizeDecodeErrorZ) { }
impl Drop for CResult_BigSizeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::ser::BigSize, crate::lightning::ln::msgs::DecodeError>> for CResult_BigSizeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::ser::BigSize, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BigSizeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BigSizeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BigSizeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BigSizeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::ser::BigSize>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BigSizeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BigSizeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BigSizeDecodeErrorZ_clone(orig: &CResult_BigSizeDecodeErrorZ) -> CResult_BigSizeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UntrustedStringDecodeErrorZ
pub union CResult_UntrustedStringDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::string::UntrustedString,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UntrustedStringDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::string::UntrustedString on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UntrustedStringDecodeErrorZ {
	/// The contents of this CResult_UntrustedStringDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UntrustedStringDecodeErrorZPtr,
	/// Whether this CResult_UntrustedStringDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UntrustedStringDecodeErrorZ in the success state.
pub extern "C" fn CResult_UntrustedStringDecodeErrorZ_ok(o: crate::lightning_types::string::UntrustedString) -> CResult_UntrustedStringDecodeErrorZ {
	CResult_UntrustedStringDecodeErrorZ {
		contents: CResult_UntrustedStringDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UntrustedStringDecodeErrorZ in the error state.
pub extern "C" fn CResult_UntrustedStringDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UntrustedStringDecodeErrorZ {
	CResult_UntrustedStringDecodeErrorZ {
		contents: CResult_UntrustedStringDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UntrustedStringDecodeErrorZ_is_ok(o: &CResult_UntrustedStringDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UntrustedStringDecodeErrorZ.
pub extern "C" fn CResult_UntrustedStringDecodeErrorZ_free(_res: CResult_UntrustedStringDecodeErrorZ) { }
impl Drop for CResult_UntrustedStringDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::string::UntrustedString, crate::lightning::ln::msgs::DecodeError>> for CResult_UntrustedStringDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::string::UntrustedString, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UntrustedStringDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UntrustedStringDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UntrustedStringDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UntrustedStringDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::string::UntrustedString>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UntrustedStringDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UntrustedStringDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UntrustedStringDecodeErrorZ_clone(orig: &CResult_UntrustedStringDecodeErrorZ) -> CResult_UntrustedStringDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HostnameDecodeErrorZ
pub union CResult_HostnameDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::ser::Hostname,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HostnameDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::ser::Hostname on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HostnameDecodeErrorZ {
	/// The contents of this CResult_HostnameDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HostnameDecodeErrorZPtr,
	/// Whether this CResult_HostnameDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HostnameDecodeErrorZ in the success state.
pub extern "C" fn CResult_HostnameDecodeErrorZ_ok(o: crate::lightning::util::ser::Hostname) -> CResult_HostnameDecodeErrorZ {
	CResult_HostnameDecodeErrorZ {
		contents: CResult_HostnameDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HostnameDecodeErrorZ in the error state.
pub extern "C" fn CResult_HostnameDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HostnameDecodeErrorZ {
	CResult_HostnameDecodeErrorZ {
		contents: CResult_HostnameDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HostnameDecodeErrorZ_is_ok(o: &CResult_HostnameDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HostnameDecodeErrorZ.
pub extern "C" fn CResult_HostnameDecodeErrorZ_free(_res: CResult_HostnameDecodeErrorZ) { }
impl Drop for CResult_HostnameDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::ser::Hostname, crate::lightning::ln::msgs::DecodeError>> for CResult_HostnameDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::ser::Hostname, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HostnameDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HostnameDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HostnameDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HostnameDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::ser::Hostname>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HostnameDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HostnameDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HostnameDecodeErrorZ_clone(orig: &CResult_HostnameDecodeErrorZ) -> CResult_HostnameDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TransactionU16LenLimitedNoneZ
pub union CResult_TransactionU16LenLimitedNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::ser::TransactionU16LenLimited,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_TransactionU16LenLimitedNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::util::ser::TransactionU16LenLimited on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TransactionU16LenLimitedNoneZ {
	/// The contents of this CResult_TransactionU16LenLimitedNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TransactionU16LenLimitedNoneZPtr,
	/// Whether this CResult_TransactionU16LenLimitedNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedNoneZ in the success state.
pub extern "C" fn CResult_TransactionU16LenLimitedNoneZ_ok(o: crate::lightning::util::ser::TransactionU16LenLimited) -> CResult_TransactionU16LenLimitedNoneZ {
	CResult_TransactionU16LenLimitedNoneZ {
		contents: CResult_TransactionU16LenLimitedNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedNoneZ in the error state.
pub extern "C" fn CResult_TransactionU16LenLimitedNoneZ_err() -> CResult_TransactionU16LenLimitedNoneZ {
	CResult_TransactionU16LenLimitedNoneZ {
		contents: CResult_TransactionU16LenLimitedNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TransactionU16LenLimitedNoneZ_is_ok(o: &CResult_TransactionU16LenLimitedNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TransactionU16LenLimitedNoneZ.
pub extern "C" fn CResult_TransactionU16LenLimitedNoneZ_free(_res: CResult_TransactionU16LenLimitedNoneZ) { }
impl Drop for CResult_TransactionU16LenLimitedNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::ser::TransactionU16LenLimited, ()>> for CResult_TransactionU16LenLimitedNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::ser::TransactionU16LenLimited, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TransactionU16LenLimitedNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_TransactionU16LenLimitedNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TransactionU16LenLimitedNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TransactionU16LenLimitedNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::ser::TransactionU16LenLimited>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TransactionU16LenLimitedNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TransactionU16LenLimitedNoneZ_clone(orig: &CResult_TransactionU16LenLimitedNoneZ) -> CResult_TransactionU16LenLimitedNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TransactionU16LenLimitedDecodeErrorZ
pub union CResult_TransactionU16LenLimitedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::ser::TransactionU16LenLimited,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TransactionU16LenLimitedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::ser::TransactionU16LenLimited on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TransactionU16LenLimitedDecodeErrorZ {
	/// The contents of this CResult_TransactionU16LenLimitedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TransactionU16LenLimitedDecodeErrorZPtr,
	/// Whether this CResult_TransactionU16LenLimitedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedDecodeErrorZ in the success state.
pub extern "C" fn CResult_TransactionU16LenLimitedDecodeErrorZ_ok(o: crate::lightning::util::ser::TransactionU16LenLimited) -> CResult_TransactionU16LenLimitedDecodeErrorZ {
	CResult_TransactionU16LenLimitedDecodeErrorZ {
		contents: CResult_TransactionU16LenLimitedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedDecodeErrorZ in the error state.
pub extern "C" fn CResult_TransactionU16LenLimitedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TransactionU16LenLimitedDecodeErrorZ {
	CResult_TransactionU16LenLimitedDecodeErrorZ {
		contents: CResult_TransactionU16LenLimitedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TransactionU16LenLimitedDecodeErrorZ_is_ok(o: &CResult_TransactionU16LenLimitedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TransactionU16LenLimitedDecodeErrorZ.
pub extern "C" fn CResult_TransactionU16LenLimitedDecodeErrorZ_free(_res: CResult_TransactionU16LenLimitedDecodeErrorZ) { }
impl Drop for CResult_TransactionU16LenLimitedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::ser::TransactionU16LenLimited, crate::lightning::ln::msgs::DecodeError>> for CResult_TransactionU16LenLimitedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::ser::TransactionU16LenLimited, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TransactionU16LenLimitedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TransactionU16LenLimitedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TransactionU16LenLimitedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TransactionU16LenLimitedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::ser::TransactionU16LenLimited>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TransactionU16LenLimitedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TransactionU16LenLimitedDecodeErrorZ_clone(orig: &CResult_TransactionU16LenLimitedDecodeErrorZ) -> CResult_TransactionU16LenLimitedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelIdDecodeErrorZ
pub union CResult_ChannelIdDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::types::ChannelId,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelIdDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::types::ChannelId on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelIdDecodeErrorZ {
	/// The contents of this CResult_ChannelIdDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelIdDecodeErrorZPtr,
	/// Whether this CResult_ChannelIdDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelIdDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelIdDecodeErrorZ_ok(o: crate::lightning::ln::types::ChannelId) -> CResult_ChannelIdDecodeErrorZ {
	CResult_ChannelIdDecodeErrorZ {
		contents: CResult_ChannelIdDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelIdDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelIdDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelIdDecodeErrorZ {
	CResult_ChannelIdDecodeErrorZ {
		contents: CResult_ChannelIdDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelIdDecodeErrorZ_is_ok(o: &CResult_ChannelIdDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelIdDecodeErrorZ.
pub extern "C" fn CResult_ChannelIdDecodeErrorZ_free(_res: CResult_ChannelIdDecodeErrorZ) { }
impl Drop for CResult_ChannelIdDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::types::ChannelId, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelIdDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::types::ChannelId, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelIdDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelIdDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelIdDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelIdDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::types::ChannelId>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelIdDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelIdDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelIdDecodeErrorZ_clone(orig: &CResult_ChannelIdDecodeErrorZ) -> CResult_ChannelIdDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InitFeaturesDecodeErrorZ
pub union CResult_InitFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::features::InitFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InitFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::features::InitFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InitFeaturesDecodeErrorZ {
	/// The contents of this CResult_InitFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InitFeaturesDecodeErrorZPtr,
	/// Whether this CResult_InitFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InitFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_InitFeaturesDecodeErrorZ_ok(o: crate::lightning_types::features::InitFeatures) -> CResult_InitFeaturesDecodeErrorZ {
	CResult_InitFeaturesDecodeErrorZ {
		contents: CResult_InitFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InitFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_InitFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InitFeaturesDecodeErrorZ {
	CResult_InitFeaturesDecodeErrorZ {
		contents: CResult_InitFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InitFeaturesDecodeErrorZ_is_ok(o: &CResult_InitFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InitFeaturesDecodeErrorZ.
pub extern "C" fn CResult_InitFeaturesDecodeErrorZ_free(_res: CResult_InitFeaturesDecodeErrorZ) { }
impl Drop for CResult_InitFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::features::InitFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_InitFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::features::InitFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InitFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InitFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InitFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InitFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::features::InitFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InitFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InitFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InitFeaturesDecodeErrorZ_clone(orig: &CResult_InitFeaturesDecodeErrorZ) -> CResult_InitFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelFeaturesDecodeErrorZ
pub union CResult_ChannelFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::features::ChannelFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::features::ChannelFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelFeaturesDecodeErrorZ {
	/// The contents of this CResult_ChannelFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelFeaturesDecodeErrorZPtr,
	/// Whether this CResult_ChannelFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelFeaturesDecodeErrorZ_ok(o: crate::lightning_types::features::ChannelFeatures) -> CResult_ChannelFeaturesDecodeErrorZ {
	CResult_ChannelFeaturesDecodeErrorZ {
		contents: CResult_ChannelFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelFeaturesDecodeErrorZ {
	CResult_ChannelFeaturesDecodeErrorZ {
		contents: CResult_ChannelFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelFeaturesDecodeErrorZ_is_ok(o: &CResult_ChannelFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelFeaturesDecodeErrorZ.
pub extern "C" fn CResult_ChannelFeaturesDecodeErrorZ_free(_res: CResult_ChannelFeaturesDecodeErrorZ) { }
impl Drop for CResult_ChannelFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::features::ChannelFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::features::ChannelFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::features::ChannelFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelFeaturesDecodeErrorZ_clone(orig: &CResult_ChannelFeaturesDecodeErrorZ) -> CResult_ChannelFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NodeFeaturesDecodeErrorZ
pub union CResult_NodeFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::features::NodeFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::features::NodeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeFeaturesDecodeErrorZ {
	/// The contents of this CResult_NodeFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeFeaturesDecodeErrorZPtr,
	/// Whether this CResult_NodeFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeFeaturesDecodeErrorZ_ok(o: crate::lightning_types::features::NodeFeatures) -> CResult_NodeFeaturesDecodeErrorZ {
	CResult_NodeFeaturesDecodeErrorZ {
		contents: CResult_NodeFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeFeaturesDecodeErrorZ {
	CResult_NodeFeaturesDecodeErrorZ {
		contents: CResult_NodeFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeFeaturesDecodeErrorZ_is_ok(o: &CResult_NodeFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeFeaturesDecodeErrorZ.
pub extern "C" fn CResult_NodeFeaturesDecodeErrorZ_free(_res: CResult_NodeFeaturesDecodeErrorZ) { }
impl Drop for CResult_NodeFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::features::NodeFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::features::NodeFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::features::NodeFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeFeaturesDecodeErrorZ_clone(orig: &CResult_NodeFeaturesDecodeErrorZ) -> CResult_NodeFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt11InvoiceFeaturesDecodeErrorZ
pub union CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::features::Bolt11InvoiceFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_Bolt11InvoiceFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::features::Bolt11InvoiceFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	/// The contents of this CResult_Bolt11InvoiceFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr,
	/// Whether this CResult_Bolt11InvoiceFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_Bolt11InvoiceFeaturesDecodeErrorZ_ok(o: crate::lightning_types::features::Bolt11InvoiceFeatures) -> CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
		contents: CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_Bolt11InvoiceFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
		contents: CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt11InvoiceFeaturesDecodeErrorZ_is_ok(o: &CResult_Bolt11InvoiceFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt11InvoiceFeaturesDecodeErrorZ.
pub extern "C" fn CResult_Bolt11InvoiceFeaturesDecodeErrorZ_free(_res: CResult_Bolt11InvoiceFeaturesDecodeErrorZ) { }
impl Drop for CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::features::Bolt11InvoiceFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::features::Bolt11InvoiceFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::features::Bolt11InvoiceFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt11InvoiceFeaturesDecodeErrorZ_clone(orig: &CResult_Bolt11InvoiceFeaturesDecodeErrorZ) -> CResult_Bolt11InvoiceFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt12InvoiceFeaturesDecodeErrorZ
pub union CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::features::Bolt12InvoiceFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_Bolt12InvoiceFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::features::Bolt12InvoiceFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	/// The contents of this CResult_Bolt12InvoiceFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr,
	/// Whether this CResult_Bolt12InvoiceFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_Bolt12InvoiceFeaturesDecodeErrorZ_ok(o: crate::lightning_types::features::Bolt12InvoiceFeatures) -> CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
		contents: CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_Bolt12InvoiceFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
		contents: CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt12InvoiceFeaturesDecodeErrorZ_is_ok(o: &CResult_Bolt12InvoiceFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt12InvoiceFeaturesDecodeErrorZ.
pub extern "C" fn CResult_Bolt12InvoiceFeaturesDecodeErrorZ_free(_res: CResult_Bolt12InvoiceFeaturesDecodeErrorZ) { }
impl Drop for CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::features::Bolt12InvoiceFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::features::Bolt12InvoiceFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::features::Bolt12InvoiceFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt12InvoiceFeaturesDecodeErrorZ_clone(orig: &CResult_Bolt12InvoiceFeaturesDecodeErrorZ) -> CResult_Bolt12InvoiceFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedHopFeaturesDecodeErrorZ
pub union CResult_BlindedHopFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::features::BlindedHopFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedHopFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::features::BlindedHopFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedHopFeaturesDecodeErrorZ {
	/// The contents of this CResult_BlindedHopFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedHopFeaturesDecodeErrorZPtr,
	/// Whether this CResult_BlindedHopFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedHopFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedHopFeaturesDecodeErrorZ_ok(o: crate::lightning_types::features::BlindedHopFeatures) -> CResult_BlindedHopFeaturesDecodeErrorZ {
	CResult_BlindedHopFeaturesDecodeErrorZ {
		contents: CResult_BlindedHopFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedHopFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedHopFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedHopFeaturesDecodeErrorZ {
	CResult_BlindedHopFeaturesDecodeErrorZ {
		contents: CResult_BlindedHopFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedHopFeaturesDecodeErrorZ_is_ok(o: &CResult_BlindedHopFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedHopFeaturesDecodeErrorZ.
pub extern "C" fn CResult_BlindedHopFeaturesDecodeErrorZ_free(_res: CResult_BlindedHopFeaturesDecodeErrorZ) { }
impl Drop for CResult_BlindedHopFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::features::BlindedHopFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedHopFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::features::BlindedHopFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedHopFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedHopFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedHopFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedHopFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::features::BlindedHopFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedHopFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedHopFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedHopFeaturesDecodeErrorZ_clone(orig: &CResult_BlindedHopFeaturesDecodeErrorZ) -> CResult_BlindedHopFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelTypeFeaturesDecodeErrorZ
pub union CResult_ChannelTypeFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_types::features::ChannelTypeFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelTypeFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_types::features::ChannelTypeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelTypeFeaturesDecodeErrorZ {
	/// The contents of this CResult_ChannelTypeFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelTypeFeaturesDecodeErrorZPtr,
	/// Whether this CResult_ChannelTypeFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelTypeFeaturesDecodeErrorZ_ok(o: crate::lightning_types::features::ChannelTypeFeatures) -> CResult_ChannelTypeFeaturesDecodeErrorZ {
	CResult_ChannelTypeFeaturesDecodeErrorZ {
		contents: CResult_ChannelTypeFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelTypeFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelTypeFeaturesDecodeErrorZ {
	CResult_ChannelTypeFeaturesDecodeErrorZ {
		contents: CResult_ChannelTypeFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(o: &CResult_ChannelTypeFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelTypeFeaturesDecodeErrorZ.
pub extern "C" fn CResult_ChannelTypeFeaturesDecodeErrorZ_free(_res: CResult_ChannelTypeFeaturesDecodeErrorZ) { }
impl Drop for CResult_ChannelTypeFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_types::features::ChannelTypeFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelTypeFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_types::features::ChannelTypeFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelTypeFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelTypeFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelTypeFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelTypeFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_types::features::ChannelTypeFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelTypeFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelTypeFeaturesDecodeErrorZ_clone(orig: &CResult_ChannelTypeFeaturesDecodeErrorZ) -> CResult_ChannelTypeFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple__u832u16Z {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: u16,
}
impl From<(crate::c_types::ThirtyTwoBytes, u16)> for C2Tuple__u832u16Z {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, u16)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple__u832u16Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, u16) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple__u832u16Z {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple__u832u16Z_clone(orig: &C2Tuple__u832u16Z) -> C2Tuple__u832u16Z { Clone::clone(&orig) }
/// Creates a new C2Tuple__u832u16Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple__u832u16Z_new(a: crate::c_types::ThirtyTwoBytes, b: u16) -> C2Tuple__u832u16Z {
	C2Tuple__u832u16Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple__u832u16Z.
pub extern "C" fn C2Tuple__u832u16Z_free(_res: C2Tuple__u832u16Z) { }
#[repr(C)]
/// The contents of CResult_BlindedPayInfoDecodeErrorZ
pub union CResult_BlindedPayInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::payment::BlindedPayInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedPayInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::payment::BlindedPayInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedPayInfoDecodeErrorZ {
	/// The contents of this CResult_BlindedPayInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedPayInfoDecodeErrorZPtr,
	/// Whether this CResult_BlindedPayInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedPayInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedPayInfoDecodeErrorZ_ok(o: crate::lightning::blinded_path::payment::BlindedPayInfo) -> CResult_BlindedPayInfoDecodeErrorZ {
	CResult_BlindedPayInfoDecodeErrorZ {
		contents: CResult_BlindedPayInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedPayInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedPayInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedPayInfoDecodeErrorZ {
	CResult_BlindedPayInfoDecodeErrorZ {
		contents: CResult_BlindedPayInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedPayInfoDecodeErrorZ_is_ok(o: &CResult_BlindedPayInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedPayInfoDecodeErrorZ.
pub extern "C" fn CResult_BlindedPayInfoDecodeErrorZ_free(_res: CResult_BlindedPayInfoDecodeErrorZ) { }
impl Drop for CResult_BlindedPayInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::BlindedPayInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedPayInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::BlindedPayInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedPayInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedPayInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedPayInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedPayInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::payment::BlindedPayInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedPayInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedPayInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedPayInfoDecodeErrorZ_clone(orig: &CResult_BlindedPayInfoDecodeErrorZ) -> CResult_BlindedPayInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedPaymentPathNoneZ
pub union CResult_BlindedPaymentPathNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::payment::BlindedPaymentPath,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_BlindedPaymentPathNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::payment::BlindedPaymentPath on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedPaymentPathNoneZ {
	/// The contents of this CResult_BlindedPaymentPathNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedPaymentPathNoneZPtr,
	/// Whether this CResult_BlindedPaymentPathNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedPaymentPathNoneZ in the success state.
pub extern "C" fn CResult_BlindedPaymentPathNoneZ_ok(o: crate::lightning::blinded_path::payment::BlindedPaymentPath) -> CResult_BlindedPaymentPathNoneZ {
	CResult_BlindedPaymentPathNoneZ {
		contents: CResult_BlindedPaymentPathNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedPaymentPathNoneZ in the error state.
pub extern "C" fn CResult_BlindedPaymentPathNoneZ_err() -> CResult_BlindedPaymentPathNoneZ {
	CResult_BlindedPaymentPathNoneZ {
		contents: CResult_BlindedPaymentPathNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedPaymentPathNoneZ_is_ok(o: &CResult_BlindedPaymentPathNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedPaymentPathNoneZ.
pub extern "C" fn CResult_BlindedPaymentPathNoneZ_free(_res: CResult_BlindedPaymentPathNoneZ) { }
impl Drop for CResult_BlindedPaymentPathNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::BlindedPaymentPath, ()>> for CResult_BlindedPaymentPathNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::BlindedPaymentPath, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedPaymentPathNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_BlindedPaymentPathNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedPaymentPathNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedPaymentPathNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::payment::BlindedPaymentPath>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedPaymentPathNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedPaymentPathNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedPaymentPathNoneZ_clone(orig: &CResult_BlindedPaymentPathNoneZ) -> CResult_BlindedPaymentPathNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::blinded_path::payment::PaymentForwardNodes of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_PaymentForwardNodeZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::blinded_path::payment::PaymentForwardNode,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_PaymentForwardNodeZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::blinded_path::payment::PaymentForwardNode> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::blinded_path::payment::PaymentForwardNode] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::blinded_path::payment::PaymentForwardNode>> for CVec_PaymentForwardNodeZ {
	fn from(v: Vec<crate::lightning::blinded_path::payment::PaymentForwardNode>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_PaymentForwardNodeZ_free(_res: CVec_PaymentForwardNodeZ) { }
impl Drop for CVec_PaymentForwardNodeZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_PaymentForwardNodeZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_PaymentRelayDecodeErrorZ
pub union CResult_PaymentRelayDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::payment::PaymentRelay,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PaymentRelayDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::payment::PaymentRelay on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PaymentRelayDecodeErrorZ {
	/// The contents of this CResult_PaymentRelayDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PaymentRelayDecodeErrorZPtr,
	/// Whether this CResult_PaymentRelayDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PaymentRelayDecodeErrorZ in the success state.
pub extern "C" fn CResult_PaymentRelayDecodeErrorZ_ok(o: crate::lightning::blinded_path::payment::PaymentRelay) -> CResult_PaymentRelayDecodeErrorZ {
	CResult_PaymentRelayDecodeErrorZ {
		contents: CResult_PaymentRelayDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentRelayDecodeErrorZ in the error state.
pub extern "C" fn CResult_PaymentRelayDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PaymentRelayDecodeErrorZ {
	CResult_PaymentRelayDecodeErrorZ {
		contents: CResult_PaymentRelayDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PaymentRelayDecodeErrorZ_is_ok(o: &CResult_PaymentRelayDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PaymentRelayDecodeErrorZ.
pub extern "C" fn CResult_PaymentRelayDecodeErrorZ_free(_res: CResult_PaymentRelayDecodeErrorZ) { }
impl Drop for CResult_PaymentRelayDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::PaymentRelay, crate::lightning::ln::msgs::DecodeError>> for CResult_PaymentRelayDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::PaymentRelay, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PaymentRelayDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PaymentRelayDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PaymentRelayDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PaymentRelayDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::payment::PaymentRelay>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PaymentRelayDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentRelayDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PaymentRelayDecodeErrorZ_clone(orig: &CResult_PaymentRelayDecodeErrorZ) -> CResult_PaymentRelayDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PaymentConstraintsDecodeErrorZ
pub union CResult_PaymentConstraintsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::payment::PaymentConstraints,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PaymentConstraintsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::payment::PaymentConstraints on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PaymentConstraintsDecodeErrorZ {
	/// The contents of this CResult_PaymentConstraintsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PaymentConstraintsDecodeErrorZPtr,
	/// Whether this CResult_PaymentConstraintsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PaymentConstraintsDecodeErrorZ in the success state.
pub extern "C" fn CResult_PaymentConstraintsDecodeErrorZ_ok(o: crate::lightning::blinded_path::payment::PaymentConstraints) -> CResult_PaymentConstraintsDecodeErrorZ {
	CResult_PaymentConstraintsDecodeErrorZ {
		contents: CResult_PaymentConstraintsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentConstraintsDecodeErrorZ in the error state.
pub extern "C" fn CResult_PaymentConstraintsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PaymentConstraintsDecodeErrorZ {
	CResult_PaymentConstraintsDecodeErrorZ {
		contents: CResult_PaymentConstraintsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PaymentConstraintsDecodeErrorZ_is_ok(o: &CResult_PaymentConstraintsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PaymentConstraintsDecodeErrorZ.
pub extern "C" fn CResult_PaymentConstraintsDecodeErrorZ_free(_res: CResult_PaymentConstraintsDecodeErrorZ) { }
impl Drop for CResult_PaymentConstraintsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::PaymentConstraints, crate::lightning::ln::msgs::DecodeError>> for CResult_PaymentConstraintsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::PaymentConstraints, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PaymentConstraintsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PaymentConstraintsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PaymentConstraintsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PaymentConstraintsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::payment::PaymentConstraints>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PaymentConstraintsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentConstraintsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PaymentConstraintsDecodeErrorZ_clone(orig: &CResult_PaymentConstraintsDecodeErrorZ) -> CResult_PaymentConstraintsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PaymentContextDecodeErrorZ
pub union CResult_PaymentContextDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::payment::PaymentContext,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PaymentContextDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::payment::PaymentContext on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PaymentContextDecodeErrorZ {
	/// The contents of this CResult_PaymentContextDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PaymentContextDecodeErrorZPtr,
	/// Whether this CResult_PaymentContextDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PaymentContextDecodeErrorZ in the success state.
pub extern "C" fn CResult_PaymentContextDecodeErrorZ_ok(o: crate::lightning::blinded_path::payment::PaymentContext) -> CResult_PaymentContextDecodeErrorZ {
	CResult_PaymentContextDecodeErrorZ {
		contents: CResult_PaymentContextDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentContextDecodeErrorZ in the error state.
pub extern "C" fn CResult_PaymentContextDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PaymentContextDecodeErrorZ {
	CResult_PaymentContextDecodeErrorZ {
		contents: CResult_PaymentContextDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PaymentContextDecodeErrorZ_is_ok(o: &CResult_PaymentContextDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PaymentContextDecodeErrorZ.
pub extern "C" fn CResult_PaymentContextDecodeErrorZ_free(_res: CResult_PaymentContextDecodeErrorZ) { }
impl Drop for CResult_PaymentContextDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::PaymentContext, crate::lightning::ln::msgs::DecodeError>> for CResult_PaymentContextDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::PaymentContext, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PaymentContextDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PaymentContextDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PaymentContextDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PaymentContextDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::payment::PaymentContext>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PaymentContextDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentContextDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PaymentContextDecodeErrorZ_clone(orig: &CResult_PaymentContextDecodeErrorZ) -> CResult_PaymentContextDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt12OfferContextDecodeErrorZ
pub union CResult_Bolt12OfferContextDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::payment::Bolt12OfferContext,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_Bolt12OfferContextDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::payment::Bolt12OfferContext on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt12OfferContextDecodeErrorZ {
	/// The contents of this CResult_Bolt12OfferContextDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt12OfferContextDecodeErrorZPtr,
	/// Whether this CResult_Bolt12OfferContextDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt12OfferContextDecodeErrorZ in the success state.
pub extern "C" fn CResult_Bolt12OfferContextDecodeErrorZ_ok(o: crate::lightning::blinded_path::payment::Bolt12OfferContext) -> CResult_Bolt12OfferContextDecodeErrorZ {
	CResult_Bolt12OfferContextDecodeErrorZ {
		contents: CResult_Bolt12OfferContextDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12OfferContextDecodeErrorZ in the error state.
pub extern "C" fn CResult_Bolt12OfferContextDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_Bolt12OfferContextDecodeErrorZ {
	CResult_Bolt12OfferContextDecodeErrorZ {
		contents: CResult_Bolt12OfferContextDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt12OfferContextDecodeErrorZ_is_ok(o: &CResult_Bolt12OfferContextDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt12OfferContextDecodeErrorZ.
pub extern "C" fn CResult_Bolt12OfferContextDecodeErrorZ_free(_res: CResult_Bolt12OfferContextDecodeErrorZ) { }
impl Drop for CResult_Bolt12OfferContextDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::Bolt12OfferContext, crate::lightning::ln::msgs::DecodeError>> for CResult_Bolt12OfferContextDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::Bolt12OfferContext, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt12OfferContextDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt12OfferContextDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt12OfferContextDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt12OfferContextDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::payment::Bolt12OfferContext>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt12OfferContextDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12OfferContextDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt12OfferContextDecodeErrorZ_clone(orig: &CResult_Bolt12OfferContextDecodeErrorZ) -> CResult_Bolt12OfferContextDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt12RefundContextDecodeErrorZ
pub union CResult_Bolt12RefundContextDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::payment::Bolt12RefundContext,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_Bolt12RefundContextDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::payment::Bolt12RefundContext on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt12RefundContextDecodeErrorZ {
	/// The contents of this CResult_Bolt12RefundContextDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt12RefundContextDecodeErrorZPtr,
	/// Whether this CResult_Bolt12RefundContextDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt12RefundContextDecodeErrorZ in the success state.
pub extern "C" fn CResult_Bolt12RefundContextDecodeErrorZ_ok(o: crate::lightning::blinded_path::payment::Bolt12RefundContext) -> CResult_Bolt12RefundContextDecodeErrorZ {
	CResult_Bolt12RefundContextDecodeErrorZ {
		contents: CResult_Bolt12RefundContextDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12RefundContextDecodeErrorZ in the error state.
pub extern "C" fn CResult_Bolt12RefundContextDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_Bolt12RefundContextDecodeErrorZ {
	CResult_Bolt12RefundContextDecodeErrorZ {
		contents: CResult_Bolt12RefundContextDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt12RefundContextDecodeErrorZ_is_ok(o: &CResult_Bolt12RefundContextDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt12RefundContextDecodeErrorZ.
pub extern "C" fn CResult_Bolt12RefundContextDecodeErrorZ_free(_res: CResult_Bolt12RefundContextDecodeErrorZ) { }
impl Drop for CResult_Bolt12RefundContextDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::Bolt12RefundContext, crate::lightning::ln::msgs::DecodeError>> for CResult_Bolt12RefundContextDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::Bolt12RefundContext, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt12RefundContextDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt12RefundContextDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt12RefundContextDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt12RefundContextDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::payment::Bolt12RefundContext>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt12RefundContextDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12RefundContextDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt12RefundContextDecodeErrorZ_clone(orig: &CResult_Bolt12RefundContextDecodeErrorZ) -> CResult_Bolt12RefundContextDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxOutUtxoLookupErrorZ
pub union CResult_TxOutUtxoLookupErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::TxOut,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::routing::utxo::UtxoLookupError,
}
#[repr(C)]
/// A CResult_TxOutUtxoLookupErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::TxOut on success and a crate::lightning::routing::utxo::UtxoLookupError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxOutUtxoLookupErrorZ {
	/// The contents of this CResult_TxOutUtxoLookupErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxOutUtxoLookupErrorZPtr,
	/// Whether this CResult_TxOutUtxoLookupErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxOutUtxoLookupErrorZ in the success state.
pub extern "C" fn CResult_TxOutUtxoLookupErrorZ_ok(o: crate::c_types::TxOut) -> CResult_TxOutUtxoLookupErrorZ {
	CResult_TxOutUtxoLookupErrorZ {
		contents: CResult_TxOutUtxoLookupErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxOutUtxoLookupErrorZ in the error state.
pub extern "C" fn CResult_TxOutUtxoLookupErrorZ_err(e: crate::lightning::routing::utxo::UtxoLookupError) -> CResult_TxOutUtxoLookupErrorZ {
	CResult_TxOutUtxoLookupErrorZ {
		contents: CResult_TxOutUtxoLookupErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxOutUtxoLookupErrorZ_is_ok(o: &CResult_TxOutUtxoLookupErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxOutUtxoLookupErrorZ.
pub extern "C" fn CResult_TxOutUtxoLookupErrorZ_free(_res: CResult_TxOutUtxoLookupErrorZ) { }
impl Drop for CResult_TxOutUtxoLookupErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::TxOut, crate::lightning::routing::utxo::UtxoLookupError>> for CResult_TxOutUtxoLookupErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::TxOut, crate::lightning::routing::utxo::UtxoLookupError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxOutUtxoLookupErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxOutUtxoLookupErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxOutUtxoLookupErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxOutUtxoLookupErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::TxOut>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxOutUtxoLookupErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::routing::utxo::UtxoLookupError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxOutUtxoLookupErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxOutUtxoLookupErrorZ_clone(orig: &CResult_TxOutUtxoLookupErrorZ) -> CResult_TxOutUtxoLookupErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ResponderDecodeErrorZ
pub union CResult_ResponderDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::messenger::Responder,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ResponderDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::messenger::Responder on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ResponderDecodeErrorZ {
	/// The contents of this CResult_ResponderDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ResponderDecodeErrorZPtr,
	/// Whether this CResult_ResponderDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ResponderDecodeErrorZ in the success state.
pub extern "C" fn CResult_ResponderDecodeErrorZ_ok(o: crate::lightning::onion_message::messenger::Responder) -> CResult_ResponderDecodeErrorZ {
	CResult_ResponderDecodeErrorZ {
		contents: CResult_ResponderDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ResponderDecodeErrorZ in the error state.
pub extern "C" fn CResult_ResponderDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ResponderDecodeErrorZ {
	CResult_ResponderDecodeErrorZ {
		contents: CResult_ResponderDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ResponderDecodeErrorZ_is_ok(o: &CResult_ResponderDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ResponderDecodeErrorZ.
pub extern "C" fn CResult_ResponderDecodeErrorZ_free(_res: CResult_ResponderDecodeErrorZ) { }
impl Drop for CResult_ResponderDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::Responder, crate::lightning::ln::msgs::DecodeError>> for CResult_ResponderDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::Responder, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ResponderDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ResponderDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ResponderDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ResponderDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::messenger::Responder>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ResponderDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ResponderDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ResponderDecodeErrorZ_clone(orig: &CResult_ResponderDecodeErrorZ) -> CResult_ResponderDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OnionMessagePathNoneZ
pub union CResult_OnionMessagePathNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::messenger::OnionMessagePath,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_OnionMessagePathNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::messenger::OnionMessagePath on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OnionMessagePathNoneZ {
	/// The contents of this CResult_OnionMessagePathNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OnionMessagePathNoneZPtr,
	/// Whether this CResult_OnionMessagePathNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OnionMessagePathNoneZ in the success state.
pub extern "C" fn CResult_OnionMessagePathNoneZ_ok(o: crate::lightning::onion_message::messenger::OnionMessagePath) -> CResult_OnionMessagePathNoneZ {
	CResult_OnionMessagePathNoneZ {
		contents: CResult_OnionMessagePathNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OnionMessagePathNoneZ in the error state.
pub extern "C" fn CResult_OnionMessagePathNoneZ_err() -> CResult_OnionMessagePathNoneZ {
	CResult_OnionMessagePathNoneZ {
		contents: CResult_OnionMessagePathNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OnionMessagePathNoneZ_is_ok(o: &CResult_OnionMessagePathNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OnionMessagePathNoneZ.
pub extern "C" fn CResult_OnionMessagePathNoneZ_free(_res: CResult_OnionMessagePathNoneZ) { }
impl Drop for CResult_OnionMessagePathNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::OnionMessagePath, ()>> for CResult_OnionMessagePathNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::OnionMessagePath, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OnionMessagePathNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_OnionMessagePathNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OnionMessagePathNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OnionMessagePathNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::messenger::OnionMessagePath>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OnionMessagePathNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OnionMessagePathNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OnionMessagePathNoneZ_clone(orig: &CResult_OnionMessagePathNoneZ) -> CResult_OnionMessagePathNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CVec_BlindedMessagePathZNoneZ
pub union CResult_CVec_BlindedMessagePathZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_BlindedMessagePathZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CVec_BlindedMessagePathZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_BlindedMessagePathZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_BlindedMessagePathZNoneZ {
	/// The contents of this CResult_CVec_BlindedMessagePathZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_BlindedMessagePathZNoneZPtr,
	/// Whether this CResult_CVec_BlindedMessagePathZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_BlindedMessagePathZNoneZ in the success state.
pub extern "C" fn CResult_CVec_BlindedMessagePathZNoneZ_ok(o: crate::c_types::derived::CVec_BlindedMessagePathZ) -> CResult_CVec_BlindedMessagePathZNoneZ {
	CResult_CVec_BlindedMessagePathZNoneZ {
		contents: CResult_CVec_BlindedMessagePathZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_BlindedMessagePathZNoneZ in the error state.
pub extern "C" fn CResult_CVec_BlindedMessagePathZNoneZ_err() -> CResult_CVec_BlindedMessagePathZNoneZ {
	CResult_CVec_BlindedMessagePathZNoneZ {
		contents: CResult_CVec_BlindedMessagePathZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_BlindedMessagePathZNoneZ_is_ok(o: &CResult_CVec_BlindedMessagePathZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_BlindedMessagePathZNoneZ.
pub extern "C" fn CResult_CVec_BlindedMessagePathZNoneZ_free(_res: CResult_CVec_BlindedMessagePathZNoneZ) { }
impl Drop for CResult_CVec_BlindedMessagePathZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_BlindedMessagePathZ, ()>> for CResult_CVec_BlindedMessagePathZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_BlindedMessagePathZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_BlindedMessagePathZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CVec_BlindedMessagePathZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_BlindedMessagePathZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_BlindedMessagePathZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_BlindedMessagePathZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_BlindedMessagePathZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_BlindedMessagePathZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_BlindedMessagePathZNoneZ_clone(orig: &CResult_CVec_BlindedMessagePathZNoneZ) -> CResult_CVec_BlindedMessagePathZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::blinded_path::message::MessageForwardNodes of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_MessageForwardNodeZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::blinded_path::message::MessageForwardNode,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_MessageForwardNodeZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::blinded_path::message::MessageForwardNode> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::blinded_path::message::MessageForwardNode] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::blinded_path::message::MessageForwardNode>> for CVec_MessageForwardNodeZ {
	fn from(v: Vec<crate::lightning::blinded_path::message::MessageForwardNode>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_MessageForwardNodeZ_free(_res: CVec_MessageForwardNodeZ) { }
impl Drop for CVec_MessageForwardNodeZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_MessageForwardNodeZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::blinded_path::message::MessageContext or not
pub enum COption_MessageContextZ {
	/// When we're in this state, this COption_MessageContextZ contains a crate::lightning::blinded_path::message::MessageContext
	Some(crate::lightning::blinded_path::message::MessageContext),
	/// When we're in this state, this COption_MessageContextZ contains nothing
	None
}
impl COption_MessageContextZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::blinded_path::message::MessageContext {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_MessageContextZ containing a crate::lightning::blinded_path::message::MessageContext
pub extern "C" fn COption_MessageContextZ_some(o: crate::lightning::blinded_path::message::MessageContext) -> COption_MessageContextZ {
	COption_MessageContextZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_MessageContextZ containing nothing
pub extern "C" fn COption_MessageContextZ_none() -> COption_MessageContextZ {
	COption_MessageContextZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::blinded_path::message::MessageContext, if we are in the Some state
pub extern "C" fn COption_MessageContextZ_free(_res: COption_MessageContextZ) { }
#[no_mangle]
/// Creates a new COption_MessageContextZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_MessageContextZ_clone(orig: &COption_MessageContextZ) -> COption_MessageContextZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ {
	/// The element at position 0
	pub a: crate::c_types::PublicKey,
	/// The element at position 1
	pub b: crate::lightning::ln::msgs::OnionMessage,
	/// The element at position 2
	pub c: crate::c_types::derived::COption_CVec_SocketAddressZZ,
}
impl From<(crate::c_types::PublicKey, crate::lightning::ln::msgs::OnionMessage, crate::c_types::derived::COption_CVec_SocketAddressZZ)> for C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ {
	fn from (tup: (crate::c_types::PublicKey, crate::lightning::ln::msgs::OnionMessage, crate::c_types::derived::COption_CVec_SocketAddressZZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::PublicKey, crate::lightning::ln::msgs::OnionMessage, crate::c_types::derived::COption_CVec_SocketAddressZZ) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ_clone(orig: &C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ) -> C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ_new(a: crate::c_types::PublicKey, b: crate::lightning::ln::msgs::OnionMessage, c: crate::c_types::derived::COption_CVec_SocketAddressZZ) -> C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ {
	C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ.
pub extern "C" fn C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ_free(_res: C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ) { }
#[repr(C)]
/// The contents of CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ
pub union CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::onion_message::messenger::SendError,
}
#[repr(C)]
/// A CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ on success and a crate::lightning::onion_message::messenger::SendError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	/// The contents of this CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr,
	/// Whether this CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ in the success state.
pub extern "C" fn CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ_ok(o: crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ) -> CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
		contents: CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ in the error state.
pub extern "C" fn CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ_err(e: crate::lightning::onion_message::messenger::SendError) -> CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
		contents: CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ_is_ok(o: &CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ.
pub extern "C" fn CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ_free(_res: CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ) { }
impl Drop for CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ, crate::lightning::onion_message::messenger::SendError>> for CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ, crate::lightning::onion_message::messenger::SendError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::onion_message::messenger::SendError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ_clone(orig: &CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ) -> CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PeeledOnionNoneZ
pub union CResult_PeeledOnionNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::messenger::PeeledOnion,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_PeeledOnionNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::messenger::PeeledOnion on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PeeledOnionNoneZ {
	/// The contents of this CResult_PeeledOnionNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PeeledOnionNoneZPtr,
	/// Whether this CResult_PeeledOnionNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PeeledOnionNoneZ in the success state.
pub extern "C" fn CResult_PeeledOnionNoneZ_ok(o: crate::lightning::onion_message::messenger::PeeledOnion) -> CResult_PeeledOnionNoneZ {
	CResult_PeeledOnionNoneZ {
		contents: CResult_PeeledOnionNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PeeledOnionNoneZ in the error state.
pub extern "C" fn CResult_PeeledOnionNoneZ_err() -> CResult_PeeledOnionNoneZ {
	CResult_PeeledOnionNoneZ {
		contents: CResult_PeeledOnionNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PeeledOnionNoneZ_is_ok(o: &CResult_PeeledOnionNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PeeledOnionNoneZ.
pub extern "C" fn CResult_PeeledOnionNoneZ_free(_res: CResult_PeeledOnionNoneZ) { }
impl Drop for CResult_PeeledOnionNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::PeeledOnion, ()>> for CResult_PeeledOnionNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::PeeledOnion, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PeeledOnionNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_PeeledOnionNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PeeledOnionNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PeeledOnionNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::messenger::PeeledOnion>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PeeledOnionNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PeeledOnionNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PeeledOnionNoneZ_clone(orig: &CResult_PeeledOnionNoneZ) -> CResult_PeeledOnionNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SendSuccessSendErrorZ
pub union CResult_SendSuccessSendErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::messenger::SendSuccess,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::onion_message::messenger::SendError,
}
#[repr(C)]
/// A CResult_SendSuccessSendErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::messenger::SendSuccess on success and a crate::lightning::onion_message::messenger::SendError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SendSuccessSendErrorZ {
	/// The contents of this CResult_SendSuccessSendErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SendSuccessSendErrorZPtr,
	/// Whether this CResult_SendSuccessSendErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SendSuccessSendErrorZ in the success state.
pub extern "C" fn CResult_SendSuccessSendErrorZ_ok(o: crate::lightning::onion_message::messenger::SendSuccess) -> CResult_SendSuccessSendErrorZ {
	CResult_SendSuccessSendErrorZ {
		contents: CResult_SendSuccessSendErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SendSuccessSendErrorZ in the error state.
pub extern "C" fn CResult_SendSuccessSendErrorZ_err(e: crate::lightning::onion_message::messenger::SendError) -> CResult_SendSuccessSendErrorZ {
	CResult_SendSuccessSendErrorZ {
		contents: CResult_SendSuccessSendErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SendSuccessSendErrorZ_is_ok(o: &CResult_SendSuccessSendErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SendSuccessSendErrorZ.
pub extern "C" fn CResult_SendSuccessSendErrorZ_free(_res: CResult_SendSuccessSendErrorZ) { }
impl Drop for CResult_SendSuccessSendErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::SendSuccess, crate::lightning::onion_message::messenger::SendError>> for CResult_SendSuccessSendErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::SendSuccess, crate::lightning::onion_message::messenger::SendError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SendSuccessSendErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SendSuccessSendErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SendSuccessSendErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SendSuccessSendErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::messenger::SendSuccess>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SendSuccessSendErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::onion_message::messenger::SendError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SendSuccessSendErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SendSuccessSendErrorZ_clone(orig: &CResult_SendSuccessSendErrorZ) -> CResult_SendSuccessSendErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneSendErrorZ
pub union CResult_NoneSendErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::onion_message::messenger::SendError,
}
#[repr(C)]
/// A CResult_NoneSendErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::onion_message::messenger::SendError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneSendErrorZ {
	/// The contents of this CResult_NoneSendErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneSendErrorZPtr,
	/// Whether this CResult_NoneSendErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneSendErrorZ in the success state.
pub extern "C" fn CResult_NoneSendErrorZ_ok() -> CResult_NoneSendErrorZ {
	CResult_NoneSendErrorZ {
		contents: CResult_NoneSendErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneSendErrorZ in the error state.
pub extern "C" fn CResult_NoneSendErrorZ_err(e: crate::lightning::onion_message::messenger::SendError) -> CResult_NoneSendErrorZ {
	CResult_NoneSendErrorZ {
		contents: CResult_NoneSendErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneSendErrorZ_is_ok(o: &CResult_NoneSendErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneSendErrorZ.
pub extern "C" fn CResult_NoneSendErrorZ_free(_res: CResult_NoneSendErrorZ) { }
impl Drop for CResult_NoneSendErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::onion_message::messenger::SendError>> for CResult_NoneSendErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::onion_message::messenger::SendError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneSendErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneSendErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneSendErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneSendErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneSendErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::onion_message::messenger::SendError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneSendErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneSendErrorZ_clone(orig: &CResult_NoneSendErrorZ) -> CResult_NoneSendErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedHopDecodeErrorZ
pub union CResult_BlindedHopDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::BlindedHop,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedHopDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::BlindedHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedHopDecodeErrorZ {
	/// The contents of this CResult_BlindedHopDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedHopDecodeErrorZPtr,
	/// Whether this CResult_BlindedHopDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedHopDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedHopDecodeErrorZ_ok(o: crate::lightning::blinded_path::BlindedHop) -> CResult_BlindedHopDecodeErrorZ {
	CResult_BlindedHopDecodeErrorZ {
		contents: CResult_BlindedHopDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedHopDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedHopDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedHopDecodeErrorZ {
	CResult_BlindedHopDecodeErrorZ {
		contents: CResult_BlindedHopDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedHopDecodeErrorZ_is_ok(o: &CResult_BlindedHopDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedHopDecodeErrorZ.
pub extern "C" fn CResult_BlindedHopDecodeErrorZ_free(_res: CResult_BlindedHopDecodeErrorZ) { }
impl Drop for CResult_BlindedHopDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::BlindedHop, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedHopDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::BlindedHop, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedHopDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedHopDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedHopDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedHopDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::BlindedHop>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedHopDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedHopDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedHopDecodeErrorZ_clone(orig: &CResult_BlindedHopDecodeErrorZ) -> CResult_BlindedHopDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::channelmanager::PhantomRouteHintss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_PhantomRouteHintsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::channelmanager::PhantomRouteHints,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_PhantomRouteHintsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::channelmanager::PhantomRouteHints> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::channelmanager::PhantomRouteHints] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::channelmanager::PhantomRouteHints>> for CVec_PhantomRouteHintsZ {
	fn from(v: Vec<crate::lightning::ln::channelmanager::PhantomRouteHints>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_PhantomRouteHintsZ_free(_res: CVec_PhantomRouteHintsZ) { }
impl Drop for CVec_PhantomRouteHintsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_PhantomRouteHintsZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_InvoiceErrorDecodeErrorZ
pub union CResult_InvoiceErrorDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice_error::InvoiceError,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InvoiceErrorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice_error::InvoiceError on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InvoiceErrorDecodeErrorZ {
	/// The contents of this CResult_InvoiceErrorDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InvoiceErrorDecodeErrorZPtr,
	/// Whether this CResult_InvoiceErrorDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InvoiceErrorDecodeErrorZ in the success state.
pub extern "C" fn CResult_InvoiceErrorDecodeErrorZ_ok(o: crate::lightning::offers::invoice_error::InvoiceError) -> CResult_InvoiceErrorDecodeErrorZ {
	CResult_InvoiceErrorDecodeErrorZ {
		contents: CResult_InvoiceErrorDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceErrorDecodeErrorZ in the error state.
pub extern "C" fn CResult_InvoiceErrorDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InvoiceErrorDecodeErrorZ {
	CResult_InvoiceErrorDecodeErrorZ {
		contents: CResult_InvoiceErrorDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InvoiceErrorDecodeErrorZ_is_ok(o: &CResult_InvoiceErrorDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InvoiceErrorDecodeErrorZ.
pub extern "C" fn CResult_InvoiceErrorDecodeErrorZ_free(_res: CResult_InvoiceErrorDecodeErrorZ) { }
impl Drop for CResult_InvoiceErrorDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice_error::InvoiceError, crate::lightning::ln::msgs::DecodeError>> for CResult_InvoiceErrorDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice_error::InvoiceError, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InvoiceErrorDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InvoiceErrorDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InvoiceErrorDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InvoiceErrorDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice_error::InvoiceError>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InvoiceErrorDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceErrorDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InvoiceErrorDecodeErrorZ_clone(orig: &CResult_InvoiceErrorDecodeErrorZ) -> CResult_InvoiceErrorDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TrackedSpendableOutputDecodeErrorZ
pub union CResult_TrackedSpendableOutputDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::sweep::TrackedSpendableOutput,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TrackedSpendableOutputDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::sweep::TrackedSpendableOutput on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TrackedSpendableOutputDecodeErrorZ {
	/// The contents of this CResult_TrackedSpendableOutputDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TrackedSpendableOutputDecodeErrorZPtr,
	/// Whether this CResult_TrackedSpendableOutputDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TrackedSpendableOutputDecodeErrorZ in the success state.
pub extern "C" fn CResult_TrackedSpendableOutputDecodeErrorZ_ok(o: crate::lightning::util::sweep::TrackedSpendableOutput) -> CResult_TrackedSpendableOutputDecodeErrorZ {
	CResult_TrackedSpendableOutputDecodeErrorZ {
		contents: CResult_TrackedSpendableOutputDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TrackedSpendableOutputDecodeErrorZ in the error state.
pub extern "C" fn CResult_TrackedSpendableOutputDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TrackedSpendableOutputDecodeErrorZ {
	CResult_TrackedSpendableOutputDecodeErrorZ {
		contents: CResult_TrackedSpendableOutputDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TrackedSpendableOutputDecodeErrorZ_is_ok(o: &CResult_TrackedSpendableOutputDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TrackedSpendableOutputDecodeErrorZ.
pub extern "C" fn CResult_TrackedSpendableOutputDecodeErrorZ_free(_res: CResult_TrackedSpendableOutputDecodeErrorZ) { }
impl Drop for CResult_TrackedSpendableOutputDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::sweep::TrackedSpendableOutput, crate::lightning::ln::msgs::DecodeError>> for CResult_TrackedSpendableOutputDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::sweep::TrackedSpendableOutput, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TrackedSpendableOutputDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TrackedSpendableOutputDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TrackedSpendableOutputDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TrackedSpendableOutputDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::sweep::TrackedSpendableOutput>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TrackedSpendableOutputDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TrackedSpendableOutputDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TrackedSpendableOutputDecodeErrorZ_clone(orig: &CResult_TrackedSpendableOutputDecodeErrorZ) -> CResult_TrackedSpendableOutputDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OutputSpendStatusDecodeErrorZ
pub union CResult_OutputSpendStatusDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::sweep::OutputSpendStatus,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OutputSpendStatusDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::sweep::OutputSpendStatus on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OutputSpendStatusDecodeErrorZ {
	/// The contents of this CResult_OutputSpendStatusDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OutputSpendStatusDecodeErrorZPtr,
	/// Whether this CResult_OutputSpendStatusDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OutputSpendStatusDecodeErrorZ in the success state.
pub extern "C" fn CResult_OutputSpendStatusDecodeErrorZ_ok(o: crate::lightning::util::sweep::OutputSpendStatus) -> CResult_OutputSpendStatusDecodeErrorZ {
	CResult_OutputSpendStatusDecodeErrorZ {
		contents: CResult_OutputSpendStatusDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OutputSpendStatusDecodeErrorZ in the error state.
pub extern "C" fn CResult_OutputSpendStatusDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OutputSpendStatusDecodeErrorZ {
	CResult_OutputSpendStatusDecodeErrorZ {
		contents: CResult_OutputSpendStatusDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OutputSpendStatusDecodeErrorZ_is_ok(o: &CResult_OutputSpendStatusDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OutputSpendStatusDecodeErrorZ.
pub extern "C" fn CResult_OutputSpendStatusDecodeErrorZ_free(_res: CResult_OutputSpendStatusDecodeErrorZ) { }
impl Drop for CResult_OutputSpendStatusDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::sweep::OutputSpendStatus, crate::lightning::ln::msgs::DecodeError>> for CResult_OutputSpendStatusDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::sweep::OutputSpendStatus, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OutputSpendStatusDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OutputSpendStatusDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OutputSpendStatusDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OutputSpendStatusDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::sweep::OutputSpendStatus>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OutputSpendStatusDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OutputSpendStatusDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OutputSpendStatusDecodeErrorZ_clone(orig: &CResult_OutputSpendStatusDecodeErrorZ) -> CResult_OutputSpendStatusDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// An enum which can either contain a crate::lightning::chain::Filter or not
pub enum COption_FilterZ {
	/// When we're in this state, this COption_FilterZ contains a crate::lightning::chain::Filter
	Some(crate::lightning::chain::Filter),
	/// When we're in this state, this COption_FilterZ contains nothing
	None
}
impl COption_FilterZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::chain::Filter {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_FilterZ containing a crate::lightning::chain::Filter
pub extern "C" fn COption_FilterZ_some(o: crate::lightning::chain::Filter) -> COption_FilterZ {
	COption_FilterZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_FilterZ containing nothing
pub extern "C" fn COption_FilterZ_none() -> COption_FilterZ {
	COption_FilterZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::chain::Filter, if we are in the Some state
pub extern "C" fn COption_FilterZ_free(_res: COption_FilterZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::util::sweep::TrackedSpendableOutputs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_TrackedSpendableOutputZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::util::sweep::TrackedSpendableOutput,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_TrackedSpendableOutputZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::util::sweep::TrackedSpendableOutput> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::util::sweep::TrackedSpendableOutput] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::util::sweep::TrackedSpendableOutput>> for CVec_TrackedSpendableOutputZ {
	fn from(v: Vec<crate::lightning::util::sweep::TrackedSpendableOutput>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_TrackedSpendableOutputZ_free(_res: CVec_TrackedSpendableOutputZ) { }
impl Drop for CVec_TrackedSpendableOutputZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_TrackedSpendableOutputZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_OutputSweeperDecodeErrorZ
pub union CResult_OutputSweeperDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::sweep::OutputSweeper,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OutputSweeperDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::sweep::OutputSweeper on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OutputSweeperDecodeErrorZ {
	/// The contents of this CResult_OutputSweeperDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OutputSweeperDecodeErrorZPtr,
	/// Whether this CResult_OutputSweeperDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OutputSweeperDecodeErrorZ in the success state.
pub extern "C" fn CResult_OutputSweeperDecodeErrorZ_ok(o: crate::lightning::util::sweep::OutputSweeper) -> CResult_OutputSweeperDecodeErrorZ {
	CResult_OutputSweeperDecodeErrorZ {
		contents: CResult_OutputSweeperDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OutputSweeperDecodeErrorZ in the error state.
pub extern "C" fn CResult_OutputSweeperDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OutputSweeperDecodeErrorZ {
	CResult_OutputSweeperDecodeErrorZ {
		contents: CResult_OutputSweeperDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OutputSweeperDecodeErrorZ_is_ok(o: &CResult_OutputSweeperDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OutputSweeperDecodeErrorZ.
pub extern "C" fn CResult_OutputSweeperDecodeErrorZ_free(_res: CResult_OutputSweeperDecodeErrorZ) { }
impl Drop for CResult_OutputSweeperDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::sweep::OutputSweeper, crate::lightning::ln::msgs::DecodeError>> for CResult_OutputSweeperDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::sweep::OutputSweeper, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OutputSweeperDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OutputSweeperDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_BestBlockOutputSweeperZ {
	/// The element at position 0
	pub a: crate::lightning::chain::BestBlock,
	/// The element at position 1
	pub b: crate::lightning::util::sweep::OutputSweeper,
}
impl From<(crate::lightning::chain::BestBlock, crate::lightning::util::sweep::OutputSweeper)> for C2Tuple_BestBlockOutputSweeperZ {
	fn from (tup: (crate::lightning::chain::BestBlock, crate::lightning::util::sweep::OutputSweeper)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_BestBlockOutputSweeperZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::chain::BestBlock, crate::lightning::util::sweep::OutputSweeper) {
		(self.a, self.b)
	}
}
/// Creates a new C2Tuple_BestBlockOutputSweeperZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_BestBlockOutputSweeperZ_new(a: crate::lightning::chain::BestBlock, b: crate::lightning::util::sweep::OutputSweeper) -> C2Tuple_BestBlockOutputSweeperZ {
	C2Tuple_BestBlockOutputSweeperZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_BestBlockOutputSweeperZ.
pub extern "C" fn C2Tuple_BestBlockOutputSweeperZ_free(_res: C2Tuple_BestBlockOutputSweeperZ) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ
pub union CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_BestBlockOutputSweeperZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_BestBlockOutputSweeperZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ {
	/// The contents of this CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZPtr,
	/// Whether this CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ in the success state.
pub extern "C" fn CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ_ok(o: crate::c_types::derived::C2Tuple_BestBlockOutputSweeperZ) -> CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ {
	CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ {
		contents: CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ in the error state.
pub extern "C" fn CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ {
	CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ {
		contents: CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ_is_ok(o: &CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ.
pub extern "C" fn CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ_free(_res: CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ) { }
impl Drop for CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_BestBlockOutputSweeperZ, crate::lightning::ln::msgs::DecodeError>> for CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_BestBlockOutputSweeperZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C2Tuple_BestBlockOutputSweeperZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_DelayedPaymentBasepointDecodeErrorZ
pub union CResult_DelayedPaymentBasepointDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::DelayedPaymentBasepoint,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_DelayedPaymentBasepointDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::DelayedPaymentBasepoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_DelayedPaymentBasepointDecodeErrorZ {
	/// The contents of this CResult_DelayedPaymentBasepointDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_DelayedPaymentBasepointDecodeErrorZPtr,
	/// Whether this CResult_DelayedPaymentBasepointDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentBasepointDecodeErrorZ in the success state.
pub extern "C" fn CResult_DelayedPaymentBasepointDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::DelayedPaymentBasepoint) -> CResult_DelayedPaymentBasepointDecodeErrorZ {
	CResult_DelayedPaymentBasepointDecodeErrorZ {
		contents: CResult_DelayedPaymentBasepointDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentBasepointDecodeErrorZ in the error state.
pub extern "C" fn CResult_DelayedPaymentBasepointDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_DelayedPaymentBasepointDecodeErrorZ {
	CResult_DelayedPaymentBasepointDecodeErrorZ {
		contents: CResult_DelayedPaymentBasepointDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_DelayedPaymentBasepointDecodeErrorZ_is_ok(o: &CResult_DelayedPaymentBasepointDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_DelayedPaymentBasepointDecodeErrorZ.
pub extern "C" fn CResult_DelayedPaymentBasepointDecodeErrorZ_free(_res: CResult_DelayedPaymentBasepointDecodeErrorZ) { }
impl Drop for CResult_DelayedPaymentBasepointDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::DelayedPaymentBasepoint, crate::lightning::ln::msgs::DecodeError>> for CResult_DelayedPaymentBasepointDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::DelayedPaymentBasepoint, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_DelayedPaymentBasepointDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_DelayedPaymentBasepointDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_DelayedPaymentBasepointDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_DelayedPaymentBasepointDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::DelayedPaymentBasepoint>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_DelayedPaymentBasepointDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentBasepointDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_DelayedPaymentBasepointDecodeErrorZ_clone(orig: &CResult_DelayedPaymentBasepointDecodeErrorZ) -> CResult_DelayedPaymentBasepointDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_DelayedPaymentKeyDecodeErrorZ
pub union CResult_DelayedPaymentKeyDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::DelayedPaymentKey,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_DelayedPaymentKeyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::DelayedPaymentKey on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_DelayedPaymentKeyDecodeErrorZ {
	/// The contents of this CResult_DelayedPaymentKeyDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_DelayedPaymentKeyDecodeErrorZPtr,
	/// Whether this CResult_DelayedPaymentKeyDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentKeyDecodeErrorZ in the success state.
pub extern "C" fn CResult_DelayedPaymentKeyDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::DelayedPaymentKey) -> CResult_DelayedPaymentKeyDecodeErrorZ {
	CResult_DelayedPaymentKeyDecodeErrorZ {
		contents: CResult_DelayedPaymentKeyDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentKeyDecodeErrorZ in the error state.
pub extern "C" fn CResult_DelayedPaymentKeyDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_DelayedPaymentKeyDecodeErrorZ {
	CResult_DelayedPaymentKeyDecodeErrorZ {
		contents: CResult_DelayedPaymentKeyDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_DelayedPaymentKeyDecodeErrorZ_is_ok(o: &CResult_DelayedPaymentKeyDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_DelayedPaymentKeyDecodeErrorZ.
pub extern "C" fn CResult_DelayedPaymentKeyDecodeErrorZ_free(_res: CResult_DelayedPaymentKeyDecodeErrorZ) { }
impl Drop for CResult_DelayedPaymentKeyDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::DelayedPaymentKey, crate::lightning::ln::msgs::DecodeError>> for CResult_DelayedPaymentKeyDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::DelayedPaymentKey, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_DelayedPaymentKeyDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_DelayedPaymentKeyDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_DelayedPaymentKeyDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_DelayedPaymentKeyDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::DelayedPaymentKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_DelayedPaymentKeyDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentKeyDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_DelayedPaymentKeyDecodeErrorZ_clone(orig: &CResult_DelayedPaymentKeyDecodeErrorZ) -> CResult_DelayedPaymentKeyDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HtlcBasepointDecodeErrorZ
pub union CResult_HtlcBasepointDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::HtlcBasepoint,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HtlcBasepointDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::HtlcBasepoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HtlcBasepointDecodeErrorZ {
	/// The contents of this CResult_HtlcBasepointDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HtlcBasepointDecodeErrorZPtr,
	/// Whether this CResult_HtlcBasepointDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HtlcBasepointDecodeErrorZ in the success state.
pub extern "C" fn CResult_HtlcBasepointDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::HtlcBasepoint) -> CResult_HtlcBasepointDecodeErrorZ {
	CResult_HtlcBasepointDecodeErrorZ {
		contents: CResult_HtlcBasepointDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HtlcBasepointDecodeErrorZ in the error state.
pub extern "C" fn CResult_HtlcBasepointDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HtlcBasepointDecodeErrorZ {
	CResult_HtlcBasepointDecodeErrorZ {
		contents: CResult_HtlcBasepointDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HtlcBasepointDecodeErrorZ_is_ok(o: &CResult_HtlcBasepointDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HtlcBasepointDecodeErrorZ.
pub extern "C" fn CResult_HtlcBasepointDecodeErrorZ_free(_res: CResult_HtlcBasepointDecodeErrorZ) { }
impl Drop for CResult_HtlcBasepointDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::HtlcBasepoint, crate::lightning::ln::msgs::DecodeError>> for CResult_HtlcBasepointDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::HtlcBasepoint, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HtlcBasepointDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HtlcBasepointDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HtlcBasepointDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HtlcBasepointDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::HtlcBasepoint>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HtlcBasepointDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HtlcBasepointDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HtlcBasepointDecodeErrorZ_clone(orig: &CResult_HtlcBasepointDecodeErrorZ) -> CResult_HtlcBasepointDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HtlcKeyDecodeErrorZ
pub union CResult_HtlcKeyDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::HtlcKey,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HtlcKeyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::HtlcKey on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HtlcKeyDecodeErrorZ {
	/// The contents of this CResult_HtlcKeyDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HtlcKeyDecodeErrorZPtr,
	/// Whether this CResult_HtlcKeyDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HtlcKeyDecodeErrorZ in the success state.
pub extern "C" fn CResult_HtlcKeyDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::HtlcKey) -> CResult_HtlcKeyDecodeErrorZ {
	CResult_HtlcKeyDecodeErrorZ {
		contents: CResult_HtlcKeyDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HtlcKeyDecodeErrorZ in the error state.
pub extern "C" fn CResult_HtlcKeyDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HtlcKeyDecodeErrorZ {
	CResult_HtlcKeyDecodeErrorZ {
		contents: CResult_HtlcKeyDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HtlcKeyDecodeErrorZ_is_ok(o: &CResult_HtlcKeyDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HtlcKeyDecodeErrorZ.
pub extern "C" fn CResult_HtlcKeyDecodeErrorZ_free(_res: CResult_HtlcKeyDecodeErrorZ) { }
impl Drop for CResult_HtlcKeyDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::HtlcKey, crate::lightning::ln::msgs::DecodeError>> for CResult_HtlcKeyDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::HtlcKey, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HtlcKeyDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HtlcKeyDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HtlcKeyDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HtlcKeyDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::HtlcKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HtlcKeyDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HtlcKeyDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HtlcKeyDecodeErrorZ_clone(orig: &CResult_HtlcKeyDecodeErrorZ) -> CResult_HtlcKeyDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RevocationBasepointDecodeErrorZ
pub union CResult_RevocationBasepointDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::RevocationBasepoint,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RevocationBasepointDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::RevocationBasepoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RevocationBasepointDecodeErrorZ {
	/// The contents of this CResult_RevocationBasepointDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RevocationBasepointDecodeErrorZPtr,
	/// Whether this CResult_RevocationBasepointDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RevocationBasepointDecodeErrorZ in the success state.
pub extern "C" fn CResult_RevocationBasepointDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::RevocationBasepoint) -> CResult_RevocationBasepointDecodeErrorZ {
	CResult_RevocationBasepointDecodeErrorZ {
		contents: CResult_RevocationBasepointDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RevocationBasepointDecodeErrorZ in the error state.
pub extern "C" fn CResult_RevocationBasepointDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RevocationBasepointDecodeErrorZ {
	CResult_RevocationBasepointDecodeErrorZ {
		contents: CResult_RevocationBasepointDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RevocationBasepointDecodeErrorZ_is_ok(o: &CResult_RevocationBasepointDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RevocationBasepointDecodeErrorZ.
pub extern "C" fn CResult_RevocationBasepointDecodeErrorZ_free(_res: CResult_RevocationBasepointDecodeErrorZ) { }
impl Drop for CResult_RevocationBasepointDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::RevocationBasepoint, crate::lightning::ln::msgs::DecodeError>> for CResult_RevocationBasepointDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::RevocationBasepoint, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RevocationBasepointDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RevocationBasepointDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RevocationBasepointDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RevocationBasepointDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::RevocationBasepoint>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RevocationBasepointDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RevocationBasepointDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RevocationBasepointDecodeErrorZ_clone(orig: &CResult_RevocationBasepointDecodeErrorZ) -> CResult_RevocationBasepointDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RevocationKeyDecodeErrorZ
pub union CResult_RevocationKeyDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::RevocationKey,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RevocationKeyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::RevocationKey on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RevocationKeyDecodeErrorZ {
	/// The contents of this CResult_RevocationKeyDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RevocationKeyDecodeErrorZPtr,
	/// Whether this CResult_RevocationKeyDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RevocationKeyDecodeErrorZ in the success state.
pub extern "C" fn CResult_RevocationKeyDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::RevocationKey) -> CResult_RevocationKeyDecodeErrorZ {
	CResult_RevocationKeyDecodeErrorZ {
		contents: CResult_RevocationKeyDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RevocationKeyDecodeErrorZ in the error state.
pub extern "C" fn CResult_RevocationKeyDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RevocationKeyDecodeErrorZ {
	CResult_RevocationKeyDecodeErrorZ {
		contents: CResult_RevocationKeyDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RevocationKeyDecodeErrorZ_is_ok(o: &CResult_RevocationKeyDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RevocationKeyDecodeErrorZ.
pub extern "C" fn CResult_RevocationKeyDecodeErrorZ_free(_res: CResult_RevocationKeyDecodeErrorZ) { }
impl Drop for CResult_RevocationKeyDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::RevocationKey, crate::lightning::ln::msgs::DecodeError>> for CResult_RevocationKeyDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::RevocationKey, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RevocationKeyDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RevocationKeyDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RevocationKeyDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RevocationKeyDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::RevocationKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RevocationKeyDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RevocationKeyDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RevocationKeyDecodeErrorZ_clone(orig: &CResult_RevocationKeyDecodeErrorZ) -> CResult_RevocationKeyDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_LockedChannelMonitorNoneZ
pub union CResult_LockedChannelMonitorNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::chainmonitor::LockedChannelMonitor,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_LockedChannelMonitorNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::chainmonitor::LockedChannelMonitor on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_LockedChannelMonitorNoneZ {
	/// The contents of this CResult_LockedChannelMonitorNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_LockedChannelMonitorNoneZPtr,
	/// Whether this CResult_LockedChannelMonitorNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_LockedChannelMonitorNoneZ in the success state.
pub extern "C" fn CResult_LockedChannelMonitorNoneZ_ok(o: crate::lightning::chain::chainmonitor::LockedChannelMonitor) -> CResult_LockedChannelMonitorNoneZ {
	CResult_LockedChannelMonitorNoneZ {
		contents: CResult_LockedChannelMonitorNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_LockedChannelMonitorNoneZ in the error state.
pub extern "C" fn CResult_LockedChannelMonitorNoneZ_err() -> CResult_LockedChannelMonitorNoneZ {
	CResult_LockedChannelMonitorNoneZ {
		contents: CResult_LockedChannelMonitorNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_LockedChannelMonitorNoneZ_is_ok(o: &CResult_LockedChannelMonitorNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_LockedChannelMonitorNoneZ.
pub extern "C" fn CResult_LockedChannelMonitorNoneZ_free(_res: CResult_LockedChannelMonitorNoneZ) { }
impl Drop for CResult_LockedChannelMonitorNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::chainmonitor::LockedChannelMonitor, ()>> for CResult_LockedChannelMonitorNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::chainmonitor::LockedChannelMonitor, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_LockedChannelMonitorNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_LockedChannelMonitorNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_OutPointChannelIdZ {
	/// The element at position 0
	pub a: crate::lightning::chain::transaction::OutPoint,
	/// The element at position 1
	pub b: crate::lightning::ln::types::ChannelId,
}
impl From<(crate::lightning::chain::transaction::OutPoint, crate::lightning::ln::types::ChannelId)> for C2Tuple_OutPointChannelIdZ {
	fn from (tup: (crate::lightning::chain::transaction::OutPoint, crate::lightning::ln::types::ChannelId)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_OutPointChannelIdZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::chain::transaction::OutPoint, crate::lightning::ln::types::ChannelId) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_OutPointChannelIdZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_OutPointChannelIdZ_clone(orig: &C2Tuple_OutPointChannelIdZ) -> C2Tuple_OutPointChannelIdZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_OutPointChannelIdZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_OutPointChannelIdZ_new(a: crate::lightning::chain::transaction::OutPoint, b: crate::lightning::ln::types::ChannelId) -> C2Tuple_OutPointChannelIdZ {
	C2Tuple_OutPointChannelIdZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_OutPointChannelIdZ.
pub extern "C" fn C2Tuple_OutPointChannelIdZ_free(_res: C2Tuple_OutPointChannelIdZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_OutPointChannelIdZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_OutPointChannelIdZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_OutPointChannelIdZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_OutPointChannelIdZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_OutPointChannelIdZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_OutPointChannelIdZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_OutPointChannelIdZ>> for CVec_C2Tuple_OutPointChannelIdZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_OutPointChannelIdZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_OutPointChannelIdZZ_free(_res: CVec_C2Tuple_OutPointChannelIdZZ) { }
impl Drop for CVec_C2Tuple_OutPointChannelIdZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_OutPointChannelIdZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_OutPointCVec_u64ZZ {
	/// The element at position 0
	pub a: crate::lightning::chain::transaction::OutPoint,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_u64Z,
}
impl From<(crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_u64Z)> for C2Tuple_OutPointCVec_u64ZZ {
	fn from (tup: (crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_u64Z)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_OutPointCVec_u64ZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_u64Z) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_OutPointCVec_u64ZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_OutPointCVec_u64ZZ_clone(orig: &C2Tuple_OutPointCVec_u64ZZ) -> C2Tuple_OutPointCVec_u64ZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_OutPointCVec_u64ZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_OutPointCVec_u64ZZ_new(a: crate::lightning::chain::transaction::OutPoint, b: crate::c_types::derived::CVec_u64Z) -> C2Tuple_OutPointCVec_u64ZZ {
	C2Tuple_OutPointCVec_u64ZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_OutPointCVec_u64ZZ.
pub extern "C" fn C2Tuple_OutPointCVec_u64ZZ_free(_res: C2Tuple_OutPointCVec_u64ZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_OutPointCVec_u64ZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_OutPointCVec_u64ZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_OutPointCVec_u64ZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_OutPointCVec_u64ZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_OutPointCVec_u64ZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_OutPointCVec_u64ZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_OutPointCVec_u64ZZ>> for CVec_C2Tuple_OutPointCVec_u64ZZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_OutPointCVec_u64ZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_OutPointCVec_u64ZZZ_free(_res: CVec_C2Tuple_OutPointCVec_u64ZZZ) { }
impl Drop for CVec_C2Tuple_OutPointCVec_u64ZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_OutPointCVec_u64ZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_BlindedMessagePathDecodeErrorZ
pub union CResult_BlindedMessagePathDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::message::BlindedMessagePath,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedMessagePathDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::message::BlindedMessagePath on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedMessagePathDecodeErrorZ {
	/// The contents of this CResult_BlindedMessagePathDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedMessagePathDecodeErrorZPtr,
	/// Whether this CResult_BlindedMessagePathDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedMessagePathDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedMessagePathDecodeErrorZ_ok(o: crate::lightning::blinded_path::message::BlindedMessagePath) -> CResult_BlindedMessagePathDecodeErrorZ {
	CResult_BlindedMessagePathDecodeErrorZ {
		contents: CResult_BlindedMessagePathDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedMessagePathDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedMessagePathDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedMessagePathDecodeErrorZ {
	CResult_BlindedMessagePathDecodeErrorZ {
		contents: CResult_BlindedMessagePathDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedMessagePathDecodeErrorZ_is_ok(o: &CResult_BlindedMessagePathDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedMessagePathDecodeErrorZ.
pub extern "C" fn CResult_BlindedMessagePathDecodeErrorZ_free(_res: CResult_BlindedMessagePathDecodeErrorZ) { }
impl Drop for CResult_BlindedMessagePathDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::message::BlindedMessagePath, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedMessagePathDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::message::BlindedMessagePath, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedMessagePathDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedMessagePathDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedMessagePathDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedMessagePathDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::message::BlindedMessagePath>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedMessagePathDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedMessagePathDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedMessagePathDecodeErrorZ_clone(orig: &CResult_BlindedMessagePathDecodeErrorZ) -> CResult_BlindedMessagePathDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedMessagePathNoneZ
pub union CResult_BlindedMessagePathNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::message::BlindedMessagePath,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_BlindedMessagePathNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::message::BlindedMessagePath on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedMessagePathNoneZ {
	/// The contents of this CResult_BlindedMessagePathNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedMessagePathNoneZPtr,
	/// Whether this CResult_BlindedMessagePathNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedMessagePathNoneZ in the success state.
pub extern "C" fn CResult_BlindedMessagePathNoneZ_ok(o: crate::lightning::blinded_path::message::BlindedMessagePath) -> CResult_BlindedMessagePathNoneZ {
	CResult_BlindedMessagePathNoneZ {
		contents: CResult_BlindedMessagePathNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedMessagePathNoneZ in the error state.
pub extern "C" fn CResult_BlindedMessagePathNoneZ_err() -> CResult_BlindedMessagePathNoneZ {
	CResult_BlindedMessagePathNoneZ {
		contents: CResult_BlindedMessagePathNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedMessagePathNoneZ_is_ok(o: &CResult_BlindedMessagePathNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedMessagePathNoneZ.
pub extern "C" fn CResult_BlindedMessagePathNoneZ_free(_res: CResult_BlindedMessagePathNoneZ) { }
impl Drop for CResult_BlindedMessagePathNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::message::BlindedMessagePath, ()>> for CResult_BlindedMessagePathNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::message::BlindedMessagePath, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedMessagePathNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_BlindedMessagePathNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedMessagePathNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedMessagePathNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::message::BlindedMessagePath>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedMessagePathNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedMessagePathNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedMessagePathNoneZ_clone(orig: &CResult_BlindedMessagePathNoneZ) -> CResult_BlindedMessagePathNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_MessageContextDecodeErrorZ
pub union CResult_MessageContextDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::message::MessageContext,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_MessageContextDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::message::MessageContext on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_MessageContextDecodeErrorZ {
	/// The contents of this CResult_MessageContextDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_MessageContextDecodeErrorZPtr,
	/// Whether this CResult_MessageContextDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_MessageContextDecodeErrorZ in the success state.
pub extern "C" fn CResult_MessageContextDecodeErrorZ_ok(o: crate::lightning::blinded_path::message::MessageContext) -> CResult_MessageContextDecodeErrorZ {
	CResult_MessageContextDecodeErrorZ {
		contents: CResult_MessageContextDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_MessageContextDecodeErrorZ in the error state.
pub extern "C" fn CResult_MessageContextDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_MessageContextDecodeErrorZ {
	CResult_MessageContextDecodeErrorZ {
		contents: CResult_MessageContextDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_MessageContextDecodeErrorZ_is_ok(o: &CResult_MessageContextDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_MessageContextDecodeErrorZ.
pub extern "C" fn CResult_MessageContextDecodeErrorZ_free(_res: CResult_MessageContextDecodeErrorZ) { }
impl Drop for CResult_MessageContextDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::message::MessageContext, crate::lightning::ln::msgs::DecodeError>> for CResult_MessageContextDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::message::MessageContext, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_MessageContextDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_MessageContextDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_MessageContextDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_MessageContextDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::message::MessageContext>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_MessageContextDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_MessageContextDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_MessageContextDecodeErrorZ_clone(orig: &CResult_MessageContextDecodeErrorZ) -> CResult_MessageContextDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OffersContextDecodeErrorZ
pub union CResult_OffersContextDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::message::OffersContext,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OffersContextDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::message::OffersContext on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OffersContextDecodeErrorZ {
	/// The contents of this CResult_OffersContextDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OffersContextDecodeErrorZPtr,
	/// Whether this CResult_OffersContextDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OffersContextDecodeErrorZ in the success state.
pub extern "C" fn CResult_OffersContextDecodeErrorZ_ok(o: crate::lightning::blinded_path::message::OffersContext) -> CResult_OffersContextDecodeErrorZ {
	CResult_OffersContextDecodeErrorZ {
		contents: CResult_OffersContextDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OffersContextDecodeErrorZ in the error state.
pub extern "C" fn CResult_OffersContextDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OffersContextDecodeErrorZ {
	CResult_OffersContextDecodeErrorZ {
		contents: CResult_OffersContextDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OffersContextDecodeErrorZ_is_ok(o: &CResult_OffersContextDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OffersContextDecodeErrorZ.
pub extern "C" fn CResult_OffersContextDecodeErrorZ_free(_res: CResult_OffersContextDecodeErrorZ) { }
impl Drop for CResult_OffersContextDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::message::OffersContext, crate::lightning::ln::msgs::DecodeError>> for CResult_OffersContextDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::message::OffersContext, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OffersContextDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OffersContextDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OffersContextDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OffersContextDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::message::OffersContext>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OffersContextDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OffersContextDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OffersContextDecodeErrorZ_clone(orig: &CResult_OffersContextDecodeErrorZ) -> CResult_OffersContextDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_AsyncPaymentsContextDecodeErrorZ
pub union CResult_AsyncPaymentsContextDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::message::AsyncPaymentsContext,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_AsyncPaymentsContextDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::message::AsyncPaymentsContext on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_AsyncPaymentsContextDecodeErrorZ {
	/// The contents of this CResult_AsyncPaymentsContextDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_AsyncPaymentsContextDecodeErrorZPtr,
	/// Whether this CResult_AsyncPaymentsContextDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_AsyncPaymentsContextDecodeErrorZ in the success state.
pub extern "C" fn CResult_AsyncPaymentsContextDecodeErrorZ_ok(o: crate::lightning::blinded_path::message::AsyncPaymentsContext) -> CResult_AsyncPaymentsContextDecodeErrorZ {
	CResult_AsyncPaymentsContextDecodeErrorZ {
		contents: CResult_AsyncPaymentsContextDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_AsyncPaymentsContextDecodeErrorZ in the error state.
pub extern "C" fn CResult_AsyncPaymentsContextDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_AsyncPaymentsContextDecodeErrorZ {
	CResult_AsyncPaymentsContextDecodeErrorZ {
		contents: CResult_AsyncPaymentsContextDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_AsyncPaymentsContextDecodeErrorZ_is_ok(o: &CResult_AsyncPaymentsContextDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_AsyncPaymentsContextDecodeErrorZ.
pub extern "C" fn CResult_AsyncPaymentsContextDecodeErrorZ_free(_res: CResult_AsyncPaymentsContextDecodeErrorZ) { }
impl Drop for CResult_AsyncPaymentsContextDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::message::AsyncPaymentsContext, crate::lightning::ln::msgs::DecodeError>> for CResult_AsyncPaymentsContextDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::message::AsyncPaymentsContext, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_AsyncPaymentsContextDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_AsyncPaymentsContextDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_AsyncPaymentsContextDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_AsyncPaymentsContextDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::message::AsyncPaymentsContext>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_AsyncPaymentsContextDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_AsyncPaymentsContextDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_AsyncPaymentsContextDecodeErrorZ_clone(orig: &CResult_AsyncPaymentsContextDecodeErrorZ) -> CResult_AsyncPaymentsContextDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_DNSResolverContextDecodeErrorZ
pub union CResult_DNSResolverContextDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::message::DNSResolverContext,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_DNSResolverContextDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::message::DNSResolverContext on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_DNSResolverContextDecodeErrorZ {
	/// The contents of this CResult_DNSResolverContextDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_DNSResolverContextDecodeErrorZPtr,
	/// Whether this CResult_DNSResolverContextDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_DNSResolverContextDecodeErrorZ in the success state.
pub extern "C" fn CResult_DNSResolverContextDecodeErrorZ_ok(o: crate::lightning::blinded_path::message::DNSResolverContext) -> CResult_DNSResolverContextDecodeErrorZ {
	CResult_DNSResolverContextDecodeErrorZ {
		contents: CResult_DNSResolverContextDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_DNSResolverContextDecodeErrorZ in the error state.
pub extern "C" fn CResult_DNSResolverContextDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_DNSResolverContextDecodeErrorZ {
	CResult_DNSResolverContextDecodeErrorZ {
		contents: CResult_DNSResolverContextDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_DNSResolverContextDecodeErrorZ_is_ok(o: &CResult_DNSResolverContextDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_DNSResolverContextDecodeErrorZ.
pub extern "C" fn CResult_DNSResolverContextDecodeErrorZ_free(_res: CResult_DNSResolverContextDecodeErrorZ) { }
impl Drop for CResult_DNSResolverContextDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::message::DNSResolverContext, crate::lightning::ln::msgs::DecodeError>> for CResult_DNSResolverContextDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::message::DNSResolverContext, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_DNSResolverContextDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_DNSResolverContextDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_DNSResolverContextDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_DNSResolverContextDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::message::DNSResolverContext>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_DNSResolverContextDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_DNSResolverContextDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_DNSResolverContextDecodeErrorZ_clone(orig: &CResult_DNSResolverContextDecodeErrorZ) -> CResult_DNSResolverContextDecodeErrorZ { Clone::clone(&orig) }
