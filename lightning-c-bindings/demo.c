#include <lightning.h>

#include <assert.h>
#include <stdio.h>
#include <string.h>

void print_log(const void *this_arg, const LDKRecord record) {
	LDKStr mod = Record_get_module_path(&record);
	LDKStr str = Record_get_args(&record);
	printf("%.*s:%d - %.*s\n", (int)mod.len, mod.chars, Record_get_line(&record), (int)str.len, str.chars);
	Str_free(str);
	Str_free(mod);
	Record_free(record);
}

uint32_t get_fee(const void *this_arg, LDKConfirmationTarget target) {
	if (target == LDKConfirmationTarget_AnchorChannelFee || target == LDKConfirmationTarget_MinAllowedAnchorChannelRemoteFee) {
		return 253;
	} else {
		return 507;
	}
}

void broadcast_txn(const void *this_arg, LDKCVec_TransactionZ txn) {
	//TODO
	CVec_TransactionZ_free(txn);
}

LDKCResult_ChannelMonitorUpdateStatusNoneZ add_channel_monitor(const void *this_arg, LDKOutPoint funding_txo, LDKChannelMonitor monitor) {
	return CResult_ChannelMonitorUpdateStatusNoneZ_ok(ChannelMonitorUpdateStatus_completed());
}
LDKChannelMonitorUpdateStatus update_channel_monitor(const void *this_arg, LDKOutPoint funding_txo, const LDKChannelMonitorUpdate *monitor) {
	return ChannelMonitorUpdateStatus_completed();
}
LDKCVec_C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZZ monitors_pending_monitor_events(const void *this_arg) {
	LDKCVec_C4Tuple_OutPointChannelIdCVec_MonitorEventZPublicKeyZZ empty_htlc_vec = {
		.data = NULL,
		.datalen = 0,
	};
	return empty_htlc_vec;
}

LDKCResult_NoneReplayEventZ never_handle_event(const void *this_arg, const struct LDKEvent event) {
	// Note that we never actually generate any events to handle in the code below.
	assert(false);
	return CResult_NoneReplayEventZ_ok();
}

LDKCResult_RouteLightningErrorZ do_find_route(const void *this_arg, LDKPublicKey payer, const LDKRouteParameters *route_params, LDKCVec_ChannelDetailsZ *first_hops, const LDKInFlightHtlcs inflight_htlcs) {
	LDKStr reason = { .chars = (const unsigned char*)"", .len = 0, .chars_is_owned = false };
	return CResult_RouteLightningErrorZ_err(LightningError_new(reason, ErrorAction_ignore_error()));
}

LDKCResult_RouteLightningErrorZ do_find_route_with_id(const void *this_arg, LDKPublicKey payer, const LDKRouteParameters *route_params, LDKCVec_ChannelDetailsZ *first_hops, const LDKInFlightHtlcs inflight_htlcs, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_id) {
	LDKStr reason = { .chars = (const unsigned char*)"", .len = 0, .chars_is_owned = false };
	return CResult_RouteLightningErrorZ_err(LightningError_new(reason, ErrorAction_ignore_error()));
}

int main() {
	uint8_t node_seed[32];
	memset(node_seed, 0, 32);

	LDKNetwork net = LDKNetwork_Bitcoin;

	LDKLogger logger = {
		.this_arg = NULL,
		.log = print_log,
		.free = NULL,
	};

	LDKFeeEstimator fee_est = {
		.this_arg = NULL,
		.get_est_sat_per_1000_weight = get_fee,
		.free = NULL
	};

	LDKWatch mon = {
		.this_arg = NULL,
		.watch_channel = add_channel_monitor,
		.update_channel = update_channel_monitor,
		.release_pending_monitor_events = monitors_pending_monitor_events,
		.free = NULL,
	};

	LDKBroadcasterInterface broadcast = {
		.this_arg = NULL,
		.broadcast_transactions = broadcast_txn,
		.free = NULL,
	};

	LDKRouter router = {
		.this_arg = NULL,
		.find_route = do_find_route,
		.find_route_with_id = do_find_route_with_id,
		.free = NULL,
	};

	LDKMessageRouter msg_router = {
		.this_arg = NULL,
		.find_path = NULL,
		.create_blinded_paths = NULL,
		.create_compact_blinded_paths = NULL,
		.free = NULL,
	};

	LDKKeysManager keys = KeysManager_new(&node_seed, 0, 0);
	LDKEntropySource entropy_source = KeysManager_as_EntropySource(&keys);
	LDKNodeSigner node_signer = KeysManager_as_NodeSigner(&keys);
	LDKSignerProvider signer_provider = KeysManager_as_SignerProvider(&keys);

	LDKUserConfig config = UserConfig_default();
	LDKThirtyTwoBytes chain_tip;
	memset(&chain_tip, 0, 32);
	LDKChainParameters chain = ChainParameters_new(net, BestBlock_new(chain_tip, 0));
	LDKChannelManager cm = ChannelManager_new(fee_est, mon, broadcast, router, msg_router, logger, entropy_source, node_signer, signer_provider, config, chain, 42);

	LDKCVec_ChannelDetailsZ channels = ChannelManager_list_channels(&cm);
	assert((unsigned long)channels.data < 4096); // There's an offset, but it should still be an offset against null in the 0 page
	assert(channels.datalen == 0);
	CVec_ChannelDetailsZ_free(channels);

	LDKEventsProvider prov = ChannelManager_as_EventsProvider(&cm);
	// Check that no events were generated by asserting if any events are passed to never_handle_event.
	LDKEventHandler handler = { .handle_event = never_handle_event, .free = NULL };
	(prov.process_pending_events)(prov.this_arg, handler);

	ChannelManager_free(cm);
	KeysManager_free(keys);

	// Check that passing empty vecs to rust doesn't blow it up:
	LDKCVec_MonitorEventZ empty_htlc_vec = {
		.data = NULL,
		.datalen = 0,
	};
	CVec_MonitorEventZ_free(empty_htlc_vec);
}
